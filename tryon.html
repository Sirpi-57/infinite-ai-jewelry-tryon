<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Infinite AI - Virtual Try-On Experience</title>
    
    <!-- Load MediaPipe dependencies -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh@0.4.1633559619/face_mesh.js" defer></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1646424915/hands.js" defer></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils@0.3.1620248257/drawing_utils.js" defer></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils@0.3.1620248257/camera_utils.js" defer></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/pose@0.5.1675469404/pose.js" defer></script>
    <script src="https://html2canvas.hertzen.com/dist/html2canvas.min.js"></script>
    
    <!-- Stylesheets -->
    <link href="https://cdnjs.cloudflare.com/ajax/libs/tailwindcss/2.2.19/tailwind.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    
    <!-- Our custom CSS -->
    <style>
        :root {
            --color-primary: #7B2CBF;      /* Main purple - represents luxury and creativity */
            --color-secondary: #9D4EDD;    /* Lighter purple - adds depth and versatility */
            --color-accent: #C77DFF;       /* Lavender - adds brightness and engagement */
            --color-dark: #240046;         /* Deep purple - professional and bold */
            --color-light: rgba(123, 44, 191, 0.05); /* Soft purple with low opacity */
            --color-background: #FAF5FF;   /* Very light lavender - clean, elegant background */
            --color-surface: #FFFFFF;      /* Pure white for surface elements */
            --color-border: rgba(123, 44, 191, 0.2); /* Soft purple border */
            --color-text: #3A0063;         /* Dark purple for text - softer than pure black */
            
            /* Mobile-specific dimensions */
            --nav-height: 56px;
            --preview-bar-height: 150px;
            --preview-bar-collapsed-height: 10px;
            --capture-btn-offset: 140px; /* New variable for capture button positioning */
            --controls-width: 300px;
            
            /* Transitions */
            --transition-speed: 0.3s;
            --transition-timing: cubic-bezier(0.4, 0, 0.2, 1);
        }
        
        /* Base Styles */
        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background-color: var(--color-background);
            margin: 0;
            padding: 0;
            color: var(--color-text);
            height: 100vh;
            width: 100vw;
            overscroll-behavior: none; /* Prevent pull-to-refresh */
            overflow: hidden;
            position: fixed; /* Prevent body scrolling */
        }
        
        /* Disable long-press menu on mobile */
        * {
            -webkit-touch-callout: none;
            -webkit-tap-highlight-color: transparent;
        }
        
        /* Main Container */
        .app-container {
            position: relative;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        
        /* Loading Screen */
        .loading-screen {
            position: fixed;
            inset: 0;
            background: var(--color-surface);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
            z-index: 1000;
            opacity: 1;
            visibility: visible;
            transition: opacity 0.3s ease-in-out, visibility 0.3s ease-in-out;
        }
        
        .loading-screen.hidden {
            opacity: 0;
            visibility: hidden;
            pointer-events: none;
        }
        
        .loading-error {
            color: #dc2626;
            margin-top: 1rem;
            text-align: center;
            max-width: 80%;
        }
        
        /* Infinity Loader */
        .loading-spinner {
            width: 80px;
            height: 40px;
            position: relative;
            margin-bottom: 2rem;
        }
        
        .loading-spinner svg {
            width: 100%;
            height: 100%;
        }
        
        .infinity-path {
            fill: none;
            stroke: rgba(131, 39, 41, 0.2);
            stroke-width: 4;
            stroke-linecap: round;
        }
        
        .infinity-highlight {
            fill: none;
            stroke: var(--color-primary);
            stroke-width: 4;
            stroke-linecap: round;
            stroke-linejoin: round;
            stroke-dasharray: 50 150;
            stroke-dashoffset: 0;
            animation: moveHighlight 2s linear infinite;
        }
        
        @keyframes moveHighlight {
            from { stroke-dashoffset: 0; }
            to { stroke-dashoffset: -200; }
        }
        
        /* Loading Brand */
        .loading-brand {
            position: absolute;
            bottom: 2rem;
            left: 50%;
            transform: translateX(-50%);
            font-size: 1.2rem;
            opacity: 0.9;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            color: var(--color-primary);
        }
        
        .brand-text {
            font-weight: 700;
            background: linear-gradient(45deg, var(--color-primary), var(--color-secondary));
            background-clip: text;
            -webkit-background-clip: text;
            color: transparent;
            -webkit-text-fill-color: transparent;
            letter-spacing: 0.5px;
        }
        
        /* Top Navigation */
        .top-nav {
            height: var(--nav-height);
            background-color: var(--color-primary);
            color: white;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 1rem;
            position: relative;
            z-index: 10;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        
        .nav-brand {
            font-weight: 600;
            font-size: 1.2rem;
        }
        
        .nav-controls {
            display: flex;
            gap: 1rem;
        }
        
        /* Pill category buttons */
        .category-pills {
            position: absolute;
            top: var(--nav-height);
            left: 0;
            width: 100%;
            padding: 10px 0;
            background: linear-gradient(to bottom, rgba(0,0,0,0.3), transparent);
            z-index: 10;
        }
        
        .pills-scroll {
            display: flex;
            overflow-x: auto;
            padding: 0 10px;
            scrollbar-width: none;
            -ms-overflow-style: none;
        }
        
        .pills-scroll::-webkit-scrollbar {
            display: none;
        }
        
        .pill-btn {
            display: flex;
            align-items: center;
            gap: 5px;
            background: rgba(255, 255, 255, 0.2);
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            border: none;
            color: white;
            padding: 8px 16px;
            border-radius: 50px;
            margin-right: 8px;
            font-size: 0.9rem;
            white-space: nowrap;
            transition: all 0.2s ease;
        }
        
        .pill-btn.active {
            background: var(--color-primary);
            box-shadow: 0 2px 8px rgba(131, 39, 41, 0.4);
        }
        
        .pill-btn i {
            font-size: 1rem;
        }
        
        /* Camera Container */
        .camera-container {
            flex: 1;
            position: relative;
            background: #000;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        
        .camera-feed-wrapper {
            position: relative;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
        }
        
        #cameraFeed {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: contain;
            transform: scaleX(-1); /* Mirror the camera */
        }
        
        #jewelryCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: contain;
            transform: scaleX(-1); /* Mirror to match video */
            pointer-events: none;
            z-index: 5;
        }
        
        /* Camera Error */
        .camera-error {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: var(--color-surface);
            padding: 2rem;
            border-radius: 1rem;
            text-align: center;
            width: 85%;
            max-width: 400px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
            z-index: 5;
        }
        
        .camera-error.hidden {
            display: none;
        }
        
        /* Preview bar (swipeable jewelry selector) */
        .preview-bar {
            position: absolute;
            bottom: 50px;
            left: 0;
            width: 100%;
            height: var(--preview-bar-height);
            background: rgba(0, 0, 0, 0.2);
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            transition: transform 0.3s cubic-bezier(0.2, 0.8, 0.2, 1);
            z-index: 20;
        }
        
        .preview-bar.collapsed {
            transform: translateY(calc(var(--preview-bar-height) - var(--preview-bar-collapsed-height)));
        }
        
        .preview-handle {
            height: var(--preview-bar-collapsed-height);
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: grab;
            touch-action: none;
        }
        
        .handle-indicator {
            width: 40px;
            height: 4px;
            background: rgba(255, 255, 255, 0.5);
            border-radius: 4px;
        }
        
        .carousel-container {
            display: flex;
            overflow-x: auto;
            scroll-snap-type: x mandatory;
            padding: 0 10px;
            scrollbar-width: none;
            -ms-overflow-style: none;
            height: calc(var(--preview-bar-height) - var(--preview-bar-collapsed-height));
        }
        
        .carousel-container::-webkit-scrollbar {
            display: none;
        }
        
        .carousel-item {
            flex: 0 0 80px;
            height: 80px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            margin-right: 10px;
            overflow: hidden;
            scroll-snap-align: start;
            position: relative;
            transition: all 0.2s ease;
        }
        
        .carousel-item.active {
            border: 2px solid var(--color-primary);
            background: rgba(255, 255, 255, 0.3);
        }
        
        .carousel-img {
            width: 100%;
            height: 100%;
            object-fit: contain;
            padding: 5px;
        }
        
        /* Floating controls - UPDATED FOR TRANSPARENCY */
        .floating-controls {
            background: transparent;
            position: absolute;
            z-index: 25;
            transition: opacity 0.3s ease, transform 0.3s ease;
            pointer-events: auto;
        }
        
        .floating-controls.hidden {
            opacity: 0;
            pointer-events: none;
            transform: translateY(10px);
        }
        
        .controls-wrapper {
            background: transparent;
            backdrop-filter: none;
            -webkit-backdrop-filter: none;
            border-radius: 16px;
            padding: 15px;
            box-shadow: none;
            max-width: var(--controls-width);
            width: 100%;
            border: none;
        }
        
        .control-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
            padding-bottom: 10px;
        }
        
        .control-title {
            font-size: 1rem;
            font-weight: 600;
            color: white; /* Changed from dark to white for better visibility */
            margin: 0;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
        }
        
        .close-control-btn {
            background: rgba(0, 0, 0, 0.1);
            border: none;
            color: white;
            font-size: 1rem;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            opacity: 0.9;
        }
        
        .control-group {
            margin-bottom: 20px;
        }
        
        .control-label {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.9rem;
            margin-bottom: 8px;
            color: white;
        }
        
        .control-value {
            font-size: 0.8rem;
            font-weight: 600;
            color: white;
            background: rgba(0, 0, 0, 0.2);
            padding: 2px 6px;
            border-radius: 4px;
        }
        
        /* Enhanced sliders - UPDATED FOR TRANSPARENCY */
        input[type="range"] {
            -webkit-appearance: none;
            appearance: none;
            width: 100%;
            height: 4px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 2px;
            outline: none;
            margin: 10px 0;
        }
        
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 18px;
            height: 18px;
            background: white;
            border: 2px solid rgba(0, 0, 0, 0.1);
            border-radius: 50%;
            cursor: pointer;
            transition: transform 0.1s ease, box-shadow 0.1s ease;
            box-shadow: 0 1px 6px rgba(0, 0, 0, 0.2);
        }
        
        input[type="range"]:active::-webkit-slider-thumb {
            transform: scale(1.2);
            box-shadow: 0 1px 10px rgba(0, 0, 0, 0.3);
        }
        
        input[type="range"]::-moz-range-thumb {
            width: 18px;
            height: 18px;
            background: white;
            border: 2px solid rgba(0, 0, 0, 0.1);
            border-radius: 50%;
            cursor: pointer;
            transition: transform 0.1s ease, box-shadow 0.1s ease;
            box-shadow: 0 1px 6px rgba(0, 0, 0, 0.2);
        }
        
        input[type="range"]:active::-moz-range-thumb {
            transform: scale(1.2);
            box-shadow: 0 1px 10px rgba(0, 0, 0, 0.3);
        }
        
        /* Control buttons */
        .control-buttons {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
        }
        
        .control-btn {
            background: rgba(131, 39, 41, 0.1);
            border: none;
            border-radius: 8px;
            height: 36px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--color-primary);
            font-size: 1rem;
            transition: all 0.2s ease;
        }
        
        .control-btn:active {
            background: rgba(131, 39, 41, 0.2);
            transform: scale(0.95);
        }
        
        /* Capture Button */
        .capture-btn {
            position: absolute;
            bottom: calc(var(--preview-bar-height) + 40px);
            right: 20px;
            width: 60px;
            height: 60px;
            background: var(--color-primary);
            color: white;
            border: none;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
            z-index: 15;
            transition: transform 0.2s ease, background-color 0.2s ease;
        }
        
        .capture-btn:active {
            transform: scale(0.95);
            background-color: var(--color-secondary);
        }
        
        /* Toast Notification */
        .toast {
            position: fixed;
            top: calc(var(--nav-height) + 20px);
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 0.75rem 1.5rem;
            border-radius: 20px;
            font-size: 0.9rem;
            z-index: 1000;
            opacity: 0;
            transition: opacity 0.3s ease, transform 0.3s ease;
            pointer-events: none;
        }
        
        .toast.visible {
            opacity: 1;
            transform: translateX(-50%) translateY(0);
        }
        
        /* Remove button */
        .remove-btn {
            background: rgba(220, 38, 38, 0.1);
            color: #dc2626;
            border: none;
            border-radius: 8px;
            padding: 10px;
            font-size: 0.9rem;
            font-weight: 500;
            width: 100%;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 5px;
        }
        
        .remove-btn:active {
            background: rgba(220, 38, 38, 0.2);
            transform: scale(0.98);
        }
        
        /* Empty category message */
        .empty-category {
            width: 100%;
            text-align: center;
            color: rgba(255, 255, 255, 0.7);
            padding: 20px 0;
            font-size: 0.9rem;
        }
        
        /* Auto-hide animation */
        @keyframes fadeOut {
            from { 
                opacity: 1; 
                visibility: visible; 
            }
            to { 
                opacity: 0; 
                visibility: hidden; 
            }
        }
        
        .auto-hide {
            animation: fadeOut 3s forwards;
            animation-delay: 5s;
        }
        
        .auto-hide:hover,
        .auto-hide:active {
            animation: none;
            opacity: 1;
            visibility: visible;
        }
        
        /* Utility Classes */
        .hidden {
            display: none !important;
        }
        
        .w-full {
            width: 100%;
        }
        
        .primary-button {
            background: var(--color-primary);
            color: white;
            border: none;
            border-radius: 0.5rem;
            padding: 0.75rem 1rem;
            font-weight: 600;
            cursor: pointer;
        }
        
        .primary-button:active {
            transform: scale(0.98);
        }
        
        /* Ultra-transparent controls - ADDED FOR JEWELRY CONTROLS */
        .ultra-transparent-controls {
            background: transparent;
            backdrop-filter: none;
            -webkit-backdrop-filter: none;
            border-radius: 10px;
            padding: 10px;
            color: white;
            box-shadow: none;
            border: none;
        }
        
        /* Control container spacing */
        .transparent-size-control,
        .transparent-opacity-control,
        .transparent-position-control {
            margin-bottom: 15px;
        }
        
        /* Transparent control labels */
        .transparent-label {
            color: white;
            opacity: 0.9;
            font-size: 0.9rem;
            font-weight: 500;
            text-shadow: 0 0 3px rgba(0,0,0,0.7);
        }
        
        .transparent-value {
            color: white;
            background: rgba(0, 0, 0, 0.3);
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 0.8rem;
            font-weight: 600;
            text-shadow: 0 0 2px rgba(0,0,0,0.8);
        }
        
        /* Transparent sliders */
        .transparent-slider {
            width: 100%;
            background: rgba(255, 255, 255, 0.2);
            -webkit-appearance: none;
            appearance: none;
            height: 5px;
            border-radius: 2.5px;
            outline: none;
            opacity: 0.7;
            transition: opacity 0.2s;
            margin: 8px 0;
        }
        
        .transparent-slider:hover {
            opacity: 1;
        }
        
        .transparent-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            background: rgba(255, 255, 255, 0.9);
            cursor: pointer;
            border-radius: 50%;
            border: 1px solid rgba(0, 0, 0, 0.1);
        }
        
        .transparent-slider::-moz-range-thumb {
            width: 18px;
            height: 18px;
            background: rgba(255, 255, 255, 0.9);
            cursor: pointer;
            border-radius: 50%;
            border: 1px solid rgba(0, 0, 0, 0.1);
        }
        
        /* Grid buttons for positioning */
        .transparent-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 5px;
        }
        
        .transparent-grid button {
            background: rgba(255, 255, 255, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: white;
            padding: 8px;
            border-radius: 5px;
            transition: background 0.2s, transform 0.1s;
            font-size: 1.1rem;
        }
        
        .transparent-grid button:active {
            background: rgba(255, 255, 255, 0.3);
            transform: scale(0.95);
        }
        
        /* Action buttons */
        .transparent-action-buttons {
            display: flex;
            justify-content: space-between;
            margin-top: 15px;
        }
        
        .transparent-close-btn,
        .transparent-remove-btn {
            background: rgba(255, 255, 255, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: white;
            padding: 8px 15px;
            border-radius: 5px;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .transparent-remove-btn {
            background: rgba(220, 38, 38, 0.15);
        }
        
        .transparent-close-btn:active,
        .transparent-remove-btn:active {
            transform: scale(0.95);
        }
        
        .transparent-close-btn:active {
            background: rgba(255, 255, 255, 0.3);
        }
        
        .transparent-remove-btn:active {
            background: rgba(220, 38, 38, 0.3);
        }
        
        .transparent-close-btn i,
        .transparent-remove-btn i {
            font-size: 1rem;
        }
    
        /* Ghost style class for complete transparency */
        .ghost-style {
            background: transparent !important;
            box-shadow: none !important;
            backdrop-filter: none !important;
            -webkit-backdrop-filter: none !important;
            border: none !important;
            pointer-events: auto;
        }
    
        /* Ensure all containers with ghost-style class are transparent */
        .controls-wrapper.ghost-style,
        .ultra-transparent-controls.ghost-style,
        .floating-controls.ghost-style,
        .mobile-translucent-controls.ghost-style {
            background-color: rgba(255, 255, 255, 0) !important;
            background: rgba(255, 255, 255, 0) !important;
            opacity: 1; /* Keep opacity at 1 for the container so children are visible */
        }
    
        /* Override any pseudo-elements */
        .controls-wrapper::before,
        .controls-wrapper::after,
        .ultra-transparent-controls::before,
        .ultra-transparent-controls::after,
        .floating-controls::before,
        .floating-controls::after {
            content: none !important;
            background: transparent !important;
            opacity: 0 !important;
            display: none !important;
        }
    
        /* Override mobile-translucent-controls class */
        .mobile-translucent-controls {
            background: transparent !important;
            backdrop-filter: none !important;
            -webkit-backdrop-filter: none !important;
            box-shadow: none !important;
        }
        
        /* Responsive adjustments */
        @media (min-width: 768px) {
            :root {
                --preview-bar-height: 120px;
            }
            
            .carousel-item {
                flex: 0 0 100px;
                height: 100px;
            }
            
            .capture-btn {
                width: 70px;
                height: 70px;
                font-size: 1.8rem;
                right: 30px;
            }
            
            .controls-wrapper.ghost-style {
                box-shadow: none !important;
            }
        }
        
        @media (min-width: 1024px) {
            .controls-wrapper {
                max-width: 350px;
            }
        }
        
        /* Handle orientation changes */
        @media (orientation: landscape) and (max-height: 500px) {
            :root {
                --preview-bar-height: 80px;
                --nav-height: 40px;
            }
            
            .category-pills {
                right: 0;
                width: auto;
                height: 100%;
                top: var(--nav-height);
                background: linear-gradient(to left, rgba(0,0,0,0.3), transparent);
                padding: 0 10px;
            }
            
            .pills-scroll {
                flex-direction: column;
                padding: 10px 0;
                height: 100%;
            }
            
            .pill-btn {
                margin-right: 0;
                margin-bottom: 8px;
            }
            
            .capture-btn {
                bottom: 20px;
            }
        }
        
        /* Keyframes for subtle animations */
        @keyframes pulseEffect {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }
        
        .carousel-item.active:after {
            content: '';
            position: absolute;
            inset: 0;
            border-radius: 12px;
            box-shadow: 0 0 0 2px var(--color-primary);
            animation: pulseEffect 2s infinite;
        }
        
        /* Camera feed wrapper optimization */
        @media (orientation: portrait) {
            .camera-feed-wrapper {
                width: 100%;
                height: auto;
                aspect-ratio: 3/4; /* Common front camera aspect ratio */
            }
        }
        
        @media (orientation: landscape) {
            .camera-feed-wrapper {
                width: auto;
                height: 100%;
                aspect-ratio: 4/3; /* Common front camera aspect ratio */
            }
        }
        
        .action-buttons {
            margin-top: 20px;
        }
        
        .secondary-button {
            background: rgba(255, 255, 255, 0.8);
            color: var(--color-dark);
            border: 1px solid var(--color-border);
            border-radius: 8px;
            padding: 8px 12px;
            font-size: 0.9rem;
            font-weight: 500;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 5px;
            transition: all 0.2s ease;
        }
        
        .secondary-button:active {
            background: rgba(255, 255, 255, 0.6);
            transform: scale(0.98);
        }

        /* Star Rating Animations */
        .star.active {
            color: #7B2CBF;
            transform: scale(1.3);
        }
        
        .star.pulse {
            animation: starPulse 0.5s ease-in-out;
        }
        
        @keyframes starPulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.5); }
            100% { transform: scale(1.3); }
        }
        
        /* Feature Button Selected State */
        .feature-btn.selected {
            background-color: rgba(123, 44, 191, 0.1);
            border-color: #7B2CBF;
            color: #7B2CBF;
        }
        
        /* Thumbs-Up Animation */
        .thumbs-up-animation {
            animation: thumbsUp 1s ease-in-out;
        }
        
        @keyframes thumbsUp {
            0% { transform: scale(0) rotate(-20deg); opacity: 0; }
            50% { transform: scale(1.5) rotate(10deg); opacity: 1; }
            100% { transform: scale(1) rotate(0deg); opacity: 1; }
        }
        
        /* Shake Animation for Low Ratings */
        .shake-animation {
            animation: shake 0.5s ease-in-out;
        }
        
        @keyframes shake {
            0% { transform: translateX(0); }
            25% { transform: translateX(-5px); }
            50% { transform: translateX(5px); }
            75% { transform: translateX(-5px); }
            100% { transform: translateX(0); }
        }
        
        /* Celebration Animation for High Ratings */
        .celebrate-animation {
            animation: celebrate 0.7s ease-in-out;
        }
        
        @keyframes celebrate {
            0% { transform: translateY(0); }
            50% { transform: translateY(-10px); }
            100% { transform: translateY(0); }
        }

        /* Fix for the review modal z-index issue */
        #reviewModal {
            position: fixed;
            inset: 0;
            background-color: rgba(0, 0, 0, 0.5);
            z-index: 3000; /* Higher z-index value */
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        /* Make sure modal content is above everything */
        #reviewModal > div {
            position: relative;
            z-index: 3001; /* Even higher z-index */
        }
        
        /* Ensure canvas and video are below the modal */
        #cameraFeed, #jewelryCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: contain;
            transform: scaleX(-1); /* Mirror to match video */
            pointer-events: none;
            z-index: 5; /* Lower z-index than modal */
        }
        
        /* Modal blocker to prevent interaction with background */
        #modalBlocker {
            position: fixed;
            inset: 0;
            z-index: 2999; /* Just below modal */
            background-color: transparent;
            pointer-events: auto; /* Capture all interactions when displayed */
        }

        /* Tour container that covers the entire screen */
        .tour-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            z-index: 9000;
            opacity: 0;
            transition: opacity 0.3s ease;
            pointer-events: none;
        }
        
        .tour-overlay.active {
            opacity: 1;
            pointer-events: auto;
        }
        
        /* The highlighted element will have this outline */
        .tour-highlight {
            position: absolute;
            border-radius: 4px;
            box-shadow: 0 0 0 2000px rgba(0, 0, 0, 0.7);
            transition: all 0.3s ease;
            z-index: 9001;
            pointer-events: none;
        }
        
        /* Pulsing animation for the highlight */
        .tour-highlight::after {
            content: '';
            position: absolute;
            top: -4px;
            left: -4px;
            right: -4px;
            bottom: -4px;
            border: 2px solid var(--color-primary);
            border-radius: 6px;
            animation: pulse 1.5s infinite;
            pointer-events: none;
        }
        
        @keyframes pulse {
            0% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.05); opacity: 0.8; }
            100% { transform: scale(1); opacity: 1; }
        }
        
        /* Tooltip styling */
        .tour-tooltip {
            position: absolute;
            background-color: white;
            color: #333;
            padding: 15px 20px;
            border-radius: 12px;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.2);
            max-width: 300px;
            z-index: 9002;
            transform: translateY(20px);
            opacity: 0;
            transition: all 0.3s ease;
        }
        
        .tour-tooltip.active {
            transform: translateY(0);
            opacity: 1;
        }
        
        /* Arrow for the tooltip */
        .tour-tooltip::before {
            content: '';
            position: absolute;
            width: 15px;
            height: 15px;
            background: white;
            transform: rotate(45deg);
            z-index: -1;
        }
        
        .tour-tooltip.top::before {
            bottom: -7px;
            left: 50%;
            margin-left: -7px;
        }
        
        .tour-tooltip.bottom::before {
            top: -7px;
            left: 50%;
            margin-left: -7px;
        }
        
        .tour-tooltip.left::before {
            right: -7px;
            top: 50%;
            margin-top: -7px;
        }
        
        .tour-tooltip.right::before {
            left: -7px;
            top: 50%;
            margin-top: -7px;
        }
        
        /* Tooltip content */
        .tour-tooltip-title {
            font-weight: bold;
            font-size: 1.1rem;
            margin-bottom: 8px;
            color: var(--color-primary);
        }
        
        .tour-tooltip-content {
            font-size: 0.95rem;
            margin-bottom: 15px;
            line-height: 1.4;
        }
        
        /* Tooltip navigation buttons */
        .tour-tooltip-nav {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 10px;
        }
        
        .tour-tooltip-progress {
            font-size: 0.8rem;
            color: #666;
        }
        
        .tour-button {
            background-color: var(--color-primary);
            color: white;
            border: none;
            padding: 8px 15px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.9rem;
            transition: background-color 0.2s ease;
        }
        
        .tour-button:hover {
            background-color: var(--color-secondary);
        }
        
        .tour-button.skip {
            background-color: transparent;
            color: #666;
        }
        
        .tour-button.skip:hover {
            color: #333;
        }
        
        /* Welcome modal for initial introduction */
        .tour-welcome-modal {
            position: fixed;
            inset: 0;
            background-color: rgba(0, 0, 0, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 9005;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s ease;
        }
        
        .tour-welcome-modal.active {
            opacity: 1;
            visibility: visible;
        }
        
        .tour-welcome-content {
            background-color: white;
            border-radius: 15px;
            padding: 30px;
            max-width: 90%;
            width: 400px;
            text-align: center;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
            transform: scale(0.9);
            transition: transform 0.3s ease;
        }
        
        .tour-welcome-modal.active .tour-welcome-content {
            transform: scale(1);
        }
        
        .tour-welcome-title {
            font-size: 1.5rem;
            font-weight: bold;
            margin-bottom: 15px;
            color: var(--color-primary);
        }
        
        .tour-welcome-icon {
            font-size: 3rem;
            color: var(--color-primary);
            margin-bottom: 20px;
        }
        
        .tour-welcome-buttons {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-top: 25px;
        }
        
        /* Mobile responsiveness */
        @media (max-width: 768px) {
            .tour-tooltip {
                max-width: 250px;
                padding: 12px 15px;
            }
            
            .tour-tooltip-title {
                font-size: 1rem;
            }
            
            .tour-tooltip-content {
                font-size: 0.9rem;
            }
            
            .tour-button {
                padding: 7px 12px;
                font-size: 0.85rem;
            }
            
            .tour-welcome-content {
                padding: 20px;
                width: 300px;
            }
        }
    </style>
</head>
<body>
    <!-- Loading Screen -->
    <div class="loading-screen" id="loadingScreen">
        <div class="loading-spinner">
            <svg viewBox="0 0 100 50" xmlns="http://www.w3.org/2000/svg">
                <path class="infinity-path" 
                      d="M10,25 C10,5 40,5 50,25 C60,45 90,45 90,25 C90,5 60,5 50,25 C40,45 10,45 10,25 Z" 
                      fill="none" stroke="black" stroke-width="2"/>
                <path class="infinity-highlight" 
                      d="M10,25 C10,5 40,5 50,25 C60,45 90,45 90,25 C90,5 60,5 50,25 C40,45 10,45 10,25 Z" 
                      fill="none" stroke="gray" stroke-width="2"/>
            </svg>
        </div>
        <p class="text-gray-600">Initializing Virtual Try-On Experience...</p>
        <p class="loading-error hidden"></p>
        
        <div class="loading-brand">
            <i class="fas fa-infinity"></i>
            <span class="brand-text">Powered by Infinite AI</span>
        </div>
    </div>

    <!-- Main App Container -->
    <div class="app-container">
        <!-- Top Navigation Bar -->
        <nav class="top-nav">
            <div class="nav-brand">
                <span>Virtual Try-On</span>
            </div>
            <div class="nav-controls">
                <button id="menuButton" class="text-white text-xl p-2">
                    <i class="fas fa-sliders-h"></i>
                </button>
            </div>
        </nav>

        <!-- Category Pills -->
        <div class="category-pills">
            <div class="pills-scroll">
                <button class="pill-btn active" data-category="face">
                    <i class="fas fa-mask"></i>
                    <span>Face</span>
                </button>
                <button class="pill-btn" data-category="ear">
                    <i class="fas fa-gem"></i>
                    <span>Ear</span>
                </button>
                <button class="pill-btn" data-category="neck">
                    <i class="fas fa-gem"></i>
                    <span>Neck</span>
                </button>
                <button class="pill-btn" data-category="hand">
                    <i class="fas fa-ring"></i>
                    <span>Hand</span>
                </button>
                <button class="pill-btn" data-category="active">
                    <i class="fas fa-th-list"></i>
                    <span>Active</span>
                </button>
            </div>
        </div>

        <!-- Camera Container -->
        <div class="camera-container">
            <div class="camera-feed-wrapper">
                <video id="cameraFeed" autoplay playsinline></video>
                <canvas id="jewelryCanvas"></canvas>
            </div>
            
            <!-- Camera Error Message -->
            <div class="camera-error hidden" id="cameraError">
                <i class="fas fa-video-slash text-3xl text-red-500 mb-4"></i>
                <h3 class="text-xl font-bold text-gray-800 mb-2">Camera Access Required</h3>
                <p class="text-gray-600 mb-4">Please allow camera access to use the virtual try-on experience.</p>
                <button onclick="requestCameraAccess()" class="primary-button">
                    Enable Camera
                </button>
            </div>
        </div>

        <!-- Preview Bar (swipeable jewelry selector) -->
        <div class="preview-bar" id="previewBar">
            <div class="preview-handle" id="previewHandle">
                <div class="handle-indicator"></div>
            </div>
            <div class="carousel-container" id="jewelryCarousel">
                <!-- Jewelry items will be inserted here dynamically -->
            </div>
        </div>

        <!-- Floating Controls -->
        <div class="floating-controls hidden" id="floatingControls">
            <div class="controls-wrapper">
                <div class="control-header">
                    <h4 class="control-title" id="controlTitle">Adjust Jewelry</h4>
                    <button class="close-control-btn" id="closeControlBtn">
                        <i class="fas fa-times"></i>
                    </button>
                </div>
                <div id="controlContent">
                    <!-- Controls will be populated dynamically -->
                </div>
            </div>
        </div>

        <!-- Capture Button -->
        <button class="capture-btn" id="captureBtn">
            <i class="fas fa-camera"></i>
        </button>

        <!-- Toast Notification -->
        <div class="toast" id="toast"></div>

        <!-- Review System Modal (initially hidden) -->
        <div id="reviewModal" class="fixed inset-0 bg-black bg-opacity-50 z-[3000] flex items-center justify-center hidden">
            <div class="bg-white rounded-2xl shadow-xl p-6 max-w-md w-full mx-4">
                <!-- Step 1: Star Rating -->
                <div id="reviewStep1" class="review-step">
                    <div class="text-center mb-4">
                        <h3 class="text-2xl font-bold text-gray-800">How was your experience?</h3>
                        <p class="text-gray-600 mt-2">We'd love to hear your thoughts!</p>
                    </div>
                    
                    <!-- Star Rating with Animation -->
                    <div class="star-rating flex justify-center space-x-3 text-4xl my-6">
                        <button class="star transition-transform" data-rating="1">☆</button>
                        <button class="star transition-transform" data-rating="2">☆</button>
                        <button class="star transition-transform" data-rating="3">☆</button>
                        <button class="star transition-transform" data-rating="4">☆</button>
                        <button class="star transition-transform" data-rating="5">☆</button>
                    </div>
                    
                    <!-- Rating Feedback Message (appears after rating) -->
                    <div id="ratingFeedback" class="text-center mb-6 opacity-0 transition-opacity duration-300">
                        <!-- Content will be dynamically updated based on rating -->
                    </div>
                    
                    <!-- Progress & Next Button -->
                    <div class="flex justify-between items-center">
                        <div class="text-gray-400 text-sm">Step 1 of 3</div>
                        <button id="nextToStep2" class="px-6 py-2 bg-purple-600 text-white rounded-lg opacity-50 cursor-not-allowed transition-opacity">
                            Next <i class="fas fa-arrow-right ml-1"></i>
                        </button>
                    </div>
                </div>
                
                <!-- Step 2: Quick Categories -->
                <div id="reviewStep2" class="review-step hidden">
                    <div class="text-center mb-4">
                        <h3 class="text-2xl font-bold text-gray-800">What did you like most?</h3>
                        <p class="text-gray-600 mt-2">Select all that apply</p>
                    </div>
                    
                    <!-- Feature Categories -->
                    <div class="grid grid-cols-2 gap-3 my-6">
                        <button class="feature-btn p-3 border border-gray-300 rounded-xl text-gray-700 hover:border-purple-500 hover:bg-purple-50 transition-colors">
                            <i class="fas fa-magic mr-2"></i> Innovative Idea
                        </button>
                        <button class="feature-btn p-3 border border-gray-300 rounded-xl text-gray-700 hover:border-purple-500 hover:bg-purple-50 transition-colors">
                            <i class="fas fa-check-circle mr-2"></i> Very Useful
                        </button>
                        <button class="feature-btn p-3 border border-gray-300 rounded-xl text-gray-700 hover:border-purple-500 hover:bg-purple-50 transition-colors">
                            <i class="fas fa-shopping-cart mr-2"></i> Helps Decision Making
                        </button>
                        <button class="feature-btn p-3 border border-gray-300 rounded-xl text-gray-700 hover:border-purple-500 hover:bg-purple-50 transition-colors">
                            <i class="fas fa-user-friends mr-2"></i> Fun to Use
                        </button>
                        <button class="feature-btn p-3 border border-gray-300 rounded-xl text-gray-700 hover:border-purple-500 hover:bg-purple-50 transition-colors">
                            <i class="fas fa-thumbs-up mr-2"></i> Accurate Results
                        </button>
                        <button class="feature-btn p-3 border border-gray-300 rounded-xl text-gray-700 hover:border-purple-500 hover:bg-purple-50 transition-colors">
                            <i class="fas fa-bolt mr-2"></i> Fast & Responsive
                        </button>
                    </div>
                    
                    <!-- Progress & Navigation -->
                    <div class="flex justify-between items-center">
                        <button id="backToStep1" class="px-4 py-2 text-gray-600 hover:text-gray-800">
                            <i class="fas fa-arrow-left mr-1"></i> Back
                        </button>
                        <div class="text-gray-400 text-sm">Step 2 of 3</div>
                        <button id="nextToStep3" class="px-6 py-2 bg-purple-600 text-white rounded-lg">
                            Next <i class="fas fa-arrow-right ml-1"></i>
                        </button>
                    </div>
                </div>
                
                <!-- Step 3: Written Feedback & Sharing -->
                <div id="reviewStep3" class="review-step hidden">
                    <div class="text-center mb-4">
                        <h3 class="text-2xl font-bold text-gray-800">Any other thoughts?</h3>
                        <p class="text-gray-600 mt-2">Leave a quick review (optional)</p>
                    </div>
                    
                    <!-- Written Feedback -->
                    <textarea id="reviewText" class="w-full p-3 border rounded-lg h-20 mb-4" 
                              placeholder="Your feedback helps us improve!"></textarea>
                    
                    <!-- Name Input (Optional) -->
                    <input type="text" id="reviewName" class="w-full p-3 border rounded-lg mb-4" 
                           placeholder="Your name (optional)">
                    
                    <!-- Progress & Navigation -->
                    <div class="flex justify-between items-center">
                        <button id="backToStep2" class="px-4 py-2 text-gray-600 hover:text-gray-800">
                            <i class="fas fa-arrow-left mr-1"></i> Back
                        </button>
                        <div class="text-gray-400 text-sm">Step 3 of 3</div>
                        <button id="submitReview" class="px-6 py-2 bg-purple-600 text-white rounded-lg">
                            Submit <i class="fas fa-check ml-1"></i>
                        </button>
                    </div>
                </div>
                
                <!-- Social Sharing Step (appears after submission) -->
                <div id="socialSharingStep" class="review-step hidden">
                    <div class="text-center mb-2">
                        <div class="inline-flex items-center justify-center w-16 h-16 bg-green-100 rounded-full mb-4">
                            <i class="fas fa-check text-3xl text-green-500"></i>
                        </div>
                        <h3 class="text-2xl font-bold text-gray-800">Thanks for your feedback!</h3>
                        <p class="text-gray-600 mt-2 mb-6">Share your experience with friends</p>
                    </div>
                    
                    <!-- Preview Image (thumbnail of screenshot) -->
                    <div id="sharePreviewImage" class="w-full h-40 bg-gray-100 rounded-lg mb-6 flex items-center justify-center overflow-hidden">
                        <img id="shareImage" class="max-w-full max-h-full object-contain" src="" alt="Your try-on image">
                    </div>
                    
                    <!-- Social Sharing Buttons -->
                    <div class="grid grid-cols-4 gap-3 mb-6">
                        <a href="#" id="shareInstagram" class="social-btn flex flex-col items-center justify-center p-3 border rounded-xl hover:bg-purple-50 transition-colors">
                            <i class="fab fa-instagram text-2xl text-pink-600 mb-1"></i>
                            <span class="text-xs">Instagram</span>
                        </a>
                        <a href="#" id="shareTwitter" class="social-btn flex flex-col items-center justify-center p-3 border rounded-xl hover:bg-purple-50 transition-colors">
                            <i class="fab fa-twitter text-2xl text-blue-400 mb-1"></i>
                            <span class="text-xs">Twitter</span>
                        </a>
                        <a href="#" id="shareFacebook" class="social-btn flex flex-col items-center justify-center p-3 border rounded-xl hover:bg-purple-50 transition-colors">
                            <i class="fab fa-facebook text-2xl text-blue-600 mb-1"></i>
                            <span class="text-xs">Facebook</span>
                        </a>
                        <a href="#" id="shareWhatsapp" class="social-btn flex flex-col items-center justify-center p-3 border rounded-xl hover:bg-purple-50 transition-colors">
                            <i class="fab fa-whatsapp text-2xl text-green-500 mb-1"></i>
                            <span class="text-xs">WhatsApp</span>
                        </a>
                    </div>
                    
                    <!-- Done Button -->
                    <button id="finishReview" class="w-full px-6 py-3 bg-gray-800 text-white rounded-lg">
                        Done
                    </button>
                </div>
                
                <!-- Confetti Canvas for Celebration Animation -->
                <canvas id="confettiCanvas" class="fixed inset-0 pointer-events-none z-[3001] hidden"></canvas>
            </div>
        </div>
    </div>
    
    <script>
        // API endpoint URL - replace with your actual API Gateway URL from Step 3
        const API_URL = 'https://kdkpbjjeze.execute-api.ap-south-1.amazonaws.com/prod1';
        
        // Initial empty JEWELRY object
        let JEWELRY = {};

        function getUrlParameter(name) {
            name = name.replace(/[\[]/, '\\[').replace(/[\]]/, '\\]');
            const regex = new RegExp('[\\?&]' + name + '=([^&#]*)');
            const results = regex.exec(location.search);
            return results === null ? '' : decodeURIComponent(results[1].replace(/\+/g, ' '));
        }
        
        // Function to fetch jewelry data from DynamoDB via API
        // Modify the fetchJewelryData function to create SKU mappings
        async function fetchJewelryData() {
            try {
                console.log('Fetching jewelry data from DynamoDB...');
                
                const response = await fetch(`${API_URL}/jewelry-data`);
                
                if (!response.ok) {
                    throw new Error(`API request failed: ${response.status}`);
                }
                
                const data = await response.json();
                
                if (!data.JEWELRY) {
                    throw new Error('Invalid API response: JEWELRY object not found');
                }
                
                // Replace the empty JEWELRY object with the data from API
                JEWELRY = data.JEWELRY;
                
                // Create mapping from SKU to ID
                for (const [id, item] of Object.entries(JEWELRY)) {
                    if (item.sku) {
                        appState.skuToJewelryId[item.sku] = id;
                    }
                    
                    // If no SKU exists but the ID looks like a SKU (e.g., "TIK-0001"),
                    // use the ID itself as a mapping key
                    if (id.match(/^[A-Z]{3}-\d{4}$/)) {
                        appState.skuToJewelryId[id] = id;
                    }
                }
                
                console.log(`Successfully loaded ${Object.keys(JEWELRY).length} jewelry items`);
                console.log('SKU to ID mapping created:', appState.skuToJewelryId);
                return true;
            } catch (error) {
                console.error('Error fetching jewelry data:', error);
                
                const loadingError = document.querySelector('.loading-error');
                if (loadingError) {
                    loadingError.textContent = `Failed to load jewelry data: ${error.message}. Please refresh the page or try again later.`;
                    loadingError.classList.remove('hidden');
                }
                return false;
            }
        }

        const LANDMARKS = {
            tikka: {
                center: 151,
                top: 10,
                reference: 9
            },
            earrings: {
                leftLobe: 58,
                rightLobe: 288,
                leftRef: 234,
                rightRef: 454
            }
        };

        // App State
        let appState = {
            activeJewelry: new Map(),
            currentCategory: 'face',  // Change default to face
            selectedJewelryId: null,
            mirrorCamera: true,       // New property for camera mirroring
            performanceMode: 'medium', // New property for performance mode
            faceLandmarks: null,
            handLandmarks: null,
            poseLandmarks: null,
            isCameraReady: false,
            isResourcesLoaded: false,
            isInitialized: false,
            initialJewelryId: null,
            categorySwitched: false,
            skuToJewelryId: {} // For mapping SKUs to internal IDs
        };
        
        // DOM Elements
        let elements = {
            video: null,
            canvas: null,
            ctx: null,
            loadingScreen: null,
            bottomPanel: null,
            controlsPanel: null,
            captureBtn: null,
            tabButtons: null,
            itemGrid: null,
            controlsContent: null,
            productCard: null,
            toast: null
        };
        
        // MediaPipe Models
        let faceMesh, hands, pose;
        
        // Initialization
        document.addEventListener('DOMContentLoaded', init);
        
        // Modify your init function to handle the URL parameter
        async function init() {
            try {
                console.log("Starting initialization...");
                updateLoadingStatus("Initializing...");
                
                // Get the jewelry ID from URL
                const jewelryIdFromUrl = getUrlParameter('jewelryId');
                if (jewelryIdFromUrl) {
                    console.log(`Found jewelry ID in URL: ${jewelryIdFromUrl}`);
                    appState.initialJewelryId = jewelryIdFromUrl;
                }
                
                // Initialize elements and event listeners
                initializeElements();
                setupEventListeners();
                
                // Fetch jewelry data
                updateLoadingStatus("Loading jewelry data...");
                const dataLoaded = await fetchJewelryData();
                if (!dataLoaded) {
                    throw new Error("Failed to load jewelry data from API");
                }
                
                // Initialize camera, AI models, and preload images
                await initializeCamera();
                await initializeAIModels();
                await preloadJewelryImages();
                
                // Initialize UI and gesture handlers
                initializeUI();
                setupGestureHandlers();
                
                // Auto-select jewelry if ID was provided
                if (appState.initialJewelryId) {
                    // First check if we have a direct ID match
                    let jewelryId = appState.initialJewelryId;
                    
                    // Check if the ID is in our mapping (for SKUs)
                    if (!JEWELRY[jewelryId] && appState.skuToJewelryId[jewelryId]) {
                        jewelryId = appState.skuToJewelryId[jewelryId];
                    }
                    
                    // If we found a matching jewelry item, load it
                    if (JEWELRY[jewelryId]) {
                        console.log(`Auto-selecting jewelry with ID: ${jewelryId}`);
                        
                        // Get the jewelry item
                        const jewelryItem = JEWELRY[jewelryId];
                        
                        // Switch to the appropriate category
                        if (jewelryItem.group) {
                            switchCategory(jewelryItem.group);
                        }
                        
                        // Add the jewelry
                        addJewelry(jewelryId);
                        
                        // Show toast notification
                        showToast(`${jewelryItem.name} automatically applied`);
                    } else {
                        console.warn(`Jewelry with ID/SKU ${appState.initialJewelryId} not found!`);
                        showToast(`Jewelry item not found`, 'warning');
                    }
                }
                
                // Start detection loop
                appState.isInitialized = true;
                requestAnimationFrame(detectAll);
                
                // Hide loading screen
                hideLoadingScreen();
                
                console.log("Initialization complete!");
            } catch (error) {
                console.error("Initialization error:", error);
                showError(error.message || "Error initializing app. Please refresh the page.");
            }
        }
        
        function initializeElements() {
            elements.video = document.getElementById('cameraFeed');
            elements.canvas = document.getElementById('jewelryCanvas');
            elements.ctx = elements.canvas.getContext('2d');
            elements.loadingScreen = document.getElementById('loadingScreen');
            
            // Replace bottom panel with preview bar
            elements.previewBar = document.getElementById('previewBar');
            elements.previewHandle = document.getElementById('previewHandle');
            elements.jewelryCarousel = document.getElementById('jewelryCarousel');
            
            // Replace controls panel with floating controls
            elements.floatingControls = document.getElementById('floatingControls');
            elements.controlTitle = document.getElementById('controlTitle');
            elements.controlContent = document.getElementById('controlContent');
            elements.closeControlBtn = document.getElementById('closeControlBtn');
            
            // Replace tab buttons with pill buttons
            elements.categoryPills = document.querySelectorAll('.pill-btn');
            
            elements.captureBtn = document.getElementById('captureBtn');
            elements.menuButton = document.getElementById('menuButton');
            
            // Create toast if it doesn't exist
            elements.toast = document.getElementById('toast') || document.createElement('div');
            if (!elements.toast.id) {
                elements.toast.className = 'toast';
                elements.toast.id = 'toast';
                document.body.appendChild(elements.toast);
            }
            
            if (!elements.video || !elements.canvas || !elements.ctx) {
                throw new Error("Required elements not found");
            }
        }

        function setupEventListeners() {
            // Category pill buttons
            elements.categoryPills.forEach(btn => {
                btn.addEventListener('click', () => {
                    const category = btn.dataset.category;
                    switchCategory(category);
                });
            });
            
            // Preview bar handle for collapsing
            elements.previewHandle.addEventListener('click', togglePreviewBar);
            
            // Touch gestures for preview bar
            let startY = 0;
            elements.previewHandle.addEventListener('touchstart', (e) => {
                startY = e.touches[0].clientY;
            });
            
            elements.previewHandle.addEventListener('touchmove', (e) => {
                const deltaY = e.touches[0].clientY - startY;
                // If swiping up, expand preview bar
                if (deltaY < -10) {
                    elements.previewBar.classList.remove('collapsed');
                }
                // If swiping down, collapse preview bar
                else if (deltaY > 10) {
                    elements.previewBar.classList.add('collapsed');
                }
                e.preventDefault();
            });
            
            // Capture button
            elements.captureBtn.addEventListener('click', captureScreenshot);
            
            // Menu button
            elements.menuButton.addEventListener('click', showAppSettings);
            
            // Close controls button
            elements.closeControlBtn.addEventListener('click', hideFloatingControls);
            
            // Add canvas click to hide controls if clicked outside
            elements.canvas.addEventListener('click', (e) => {
                // Check if click was outside floating controls
                const controlsRect = elements.floatingControls.getBoundingClientRect();
                if (e.clientX < controlsRect.left || e.clientX > controlsRect.right ||
                    e.clientY < controlsRect.top || e.clientY > controlsRect.bottom) {
                    hideFloatingControls();
                }
            });
            
            // Initialize pinch-to-zoom and drag gestures
            setupGestureHandlers();
        }

        function togglePreviewBar() {
            elements.previewBar.classList.toggle('collapsed');
            // Adjust capture button position based on preview bar state
            const bottomOffset = elements.previewBar.classList.contains('collapsed') 
                ? 'var(--preview-bar-collapsed-height)' 
                : 'var(--preview-bar-height)';
            elements.captureBtn.style.bottom = `calc(${bottomOffset} + 20px)`;
        }
        
        async function initializeCamera() {
            try {
                updateLoadingStatus("Accessing camera...");
                
                const constraints = {
                    video: {
                        facingMode: 'user',
                        width: { ideal: 1280 },
                        height: { ideal: 720 }
                    }
                };
                
                const stream = await navigator.mediaDevices.getUserMedia(constraints);
                elements.video.srcObject = stream;
                
                await new Promise((resolve) => {
                    elements.video.onloadedmetadata = () => {
                        elements.canvas.width = elements.video.videoWidth;
                        elements.canvas.height = elements.video.videoHeight;
                        console.log("Video dimensions:", elements.video.videoWidth, elements.video.videoHeight);
                        appState.isCameraReady = true;
                        resolve();
                    };
                });
                
                await elements.video.play();
                console.log("Camera initialized successfully");
                
                document.getElementById('cameraError').classList.add('hidden');
            } catch (error) {
                console.error("Camera access error:", error);
                document.getElementById('cameraError').classList.remove('hidden');
                throw new Error("Camera access denied. Please enable camera permissions.");
            }
        }
        
        async function initializeAIModels() {
            try {
                updateLoadingStatus("Loading AI models...");
                
                // Initialize FaceMesh
                faceMesh = new FaceMesh({
                    locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh@0.4.1633559619/${file}`
                });
                
                // Initialize Hands
                hands = new Hands({
                    locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1646424915/${file}`
                });
                
                // Initialize Pose
                pose = new Pose({
                    locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/pose@0.5.1675469404/${file}`
                });
                
                // Configure models
                faceMesh.setOptions({
                    maxNumFaces: 1,
                    refineLandmarks: true,
                    minDetectionConfidence: 0.5,
                    minTrackingConfidence: 0.5
                });
                
                hands.setOptions({
                    maxNumHands: 2,
                    modelComplexity: 0,
                    minDetectionConfidence: 0.5,
                    minTrackingConfidence: 0.5
                });
                
                pose.setOptions({
                    modelComplexity: 0,
                    smoothLandmarks: true,
                    minDetectionConfidence: 0.5,
                    minTrackingConfidence: 0.5
                });
                
                // Set up callbacks
                faceMesh.onResults(onFaceMeshResults);
                hands.onResults(onHandResults);
                pose.onResults(onPoseResults);
                
                // Initialize models
                updateLoadingStatus("Loading face detection...");
                await faceMesh.initialize();
                
                updateLoadingStatus("Loading hand detection...");
                await hands.initialize();
                
                updateLoadingStatus("Loading pose detection...");
                await pose.initialize();
                
                console.log("AI models initialized successfully");
                return true;
            } catch (error) {
                console.error("Model initialization error:", error);
                throw new Error("Failed to initialize AI models. Please try refreshing the page.");
            }
        }
        
        async function preloadJewelryImages() {
            updateLoadingStatus("Loading jewelry assets...");
            const preloadPromises = [];
            
            for (const [id, jewelry] of Object.entries(JEWELRY)) {
                try {
                    if (jewelry.type === 'earrings') {
                        const leftImg = new Image();
                        const rightImg = new Image();
                        
                        // Add crossOrigin attribute
                        leftImg.crossOrigin = "anonymous";
                        rightImg.crossOrigin = "anonymous";
                        
                        leftImg.src = jewelry.left;
                        rightImg.src = jewelry.right;
                        
                        const leftPromise = new Promise((resolve, reject) => {
                            leftImg.onload = resolve;
                            leftImg.onerror = () => reject(new Error(`Failed to load ${jewelry.left}`));
                        });
                        
                        const rightPromise = new Promise((resolve, reject) => {
                            rightImg.onload = resolve;
                            rightImg.onerror = () => reject(new Error(`Failed to load ${jewelry.right}`));
                        });
                        
                        preloadPromises.push(Promise.all([leftPromise, rightPromise])
                            .then(() => {
                                jewelry.leftImage = leftImg;
                                jewelry.rightImage = rightImg;
                            }));
                    } else {
                        const img = new Image();
                        
                        // Add crossOrigin attribute
                        img.crossOrigin = "anonymous";
                        
                        img.src = jewelry.image;
                        
                        const imgPromise = new Promise((resolve, reject) => {
                            img.onload = resolve;
                            img.onerror = () => reject(new Error(`Failed to load ${jewelry.image}`));
                        });
                        
                        preloadPromises.push(imgPromise.then(() => {
                            jewelry.loadedImage = img;
                        }));
                    }
                    
                    // Preload thumbnail if available
                    if (jewelry.thumbnail) {
                        const thumbImg = new Image();
                        
                        // Add crossOrigin attribute
                        thumbImg.crossOrigin = "anonymous";
                        
                        thumbImg.src = jewelry.thumbnail;
                        
                        const thumbPromise = new Promise((resolve) => {
                            thumbImg.onload = resolve;
                            thumbImg.onerror = resolve; // Continue even if thumbnail fails
                        });
                        
                        preloadPromises.push(thumbPromise.then(() => {
                            jewelry.thumbnailImage = thumbImg;
                        }));
                    }
                } catch (error) {
                    console.warn(`Error setting up preload for ${id}:`, error);
                }
            }
            
            // Wait for all preload promises
            try {
                await Promise.all(preloadPromises);
                console.log("All jewelry images preloaded successfully");
            } catch (error) {
                console.warn("Some images failed to preload:", error);
            }
            
            appState.isResourcesLoaded = true;
        }
        
        function initializeUI() {
            // Show first category
            switchCategory('face');
            
            // Set up controls activity monitoring
            elements.floatingControls.addEventListener('mousemove', resetControlsTimer);
            elements.floatingControls.addEventListener('touchstart', resetControlsTimer);
            elements.floatingControls.addEventListener('click', resetControlsTimer);
            
            // Ensure camera is mirrored initially
            elements.video.style.transform = 'scaleX(-1)';
            elements.canvas.style.transform = 'scaleX(-1)';
        }
        
        // Update the switchCategory function
        function switchCategory(category) {
            console.log(`Switching to category: ${category}`);
            
            // Update active pill
            elements.categoryPills.forEach(btn => {
                if (btn.dataset.category === category) {
                    btn.classList.add('active');
                } else {
                    btn.classList.remove('active');
                }
            });
            
            appState.currentCategory = category;
            
            // Hide floating controls when switching categories
            hideFloatingControls();
            
            // Make sure preview bar is expanded
            elements.previewBar.classList.remove('collapsed');
            
            // Render appropriate items
            if (category === 'active') {
                renderActiveItems();
            } else {
                renderCategoryItems(category);
            }
            
            // Mark that we've performed a category switch
            appState.categorySwitched = true;
        }
        
        function renderCategoryItems(category) {
            const carousel = elements.jewelryCarousel;
            carousel.innerHTML = '';
            
            // Filter items by category
            const categoryItems = Object.entries(JEWELRY)
                .filter(([_, item]) => item.group === category);
            
            if (categoryItems.length === 0) {
                carousel.innerHTML = '<div class="empty-category">No items available</div>';
                return;
            }
            
            // Create carousel items
            categoryItems.forEach(([id, item]) => {
                const isActive = appState.activeJewelry.has(id);
                
                const card = document.createElement('div');
                card.className = `carousel-item ${isActive ? 'active' : ''}`;
                card.dataset.jewelryId = id;
                
                // Use thumbnail if available, otherwise use main image
                const imageSrc = item.thumbnail || 
                    (item.type === 'earrings' ? item.left : item.image);
                
                card.innerHTML = `<img src="${imageSrc}" alt="${item.name}" class="carousel-img">`;
                
                card.addEventListener('click', () => handleItemClick(id));
                carousel.appendChild(card);
            });
        }
        
        function renderActiveItems() {
            const carousel = elements.jewelryCarousel;
            carousel.innerHTML = '';
            
            if (appState.activeJewelry.size === 0) {
                carousel.innerHTML = '<div class="empty-category">No active jewelry</div>';
                return;
            }
            
            // Create carousel items for active jewelry
            appState.activeJewelry.forEach((item, id) => {
                const originalItem = JEWELRY[id];
                if (!originalItem) return;
                
                const card = document.createElement('div');
                card.className = 'carousel-item active';
                card.dataset.jewelryId = id;
                
                // Use thumbnail if available
                const imageSrc = originalItem.thumbnail || 
                    (originalItem.type === 'earrings' ? originalItem.left : originalItem.image);
                
                card.innerHTML = `<img src="${imageSrc}" alt="${originalItem.name}" class="carousel-img">`;
                
                card.addEventListener('click', () => {
                    // Show floating controls for this jewelry
                    renderFloatingControls(id);
                    showFloatingControls(id);
                });
                
                carousel.appendChild(card);
            });
        }
        
        function handleItemClick(id) {
            const item = JEWELRY[id];
            
            // If item is already active, remove it instead of showing controls
            if (appState.activeJewelry.has(id)) {
                removeJewelry(id);
                showToast(`${item.name} removed`);
                return;
            }
            
            // Add new jewelry item
            addJewelry(id);
            
            // Show toast notification
            showToast(`Added: ${item.name}`);
            
            // Update carousel UI
            const carouselItems = elements.jewelryCarousel.querySelectorAll('.carousel-item');
            carouselItems.forEach(card => {
                if (card.dataset.jewelryId === id) {
                    card.classList.add('active');
                }
            });
        }
        
        // Product Details Function
        function showProductDetails(id) {
            const item = JEWELRY[id];
            if (!item) return;
            
            // Just show a toast notification instead of a product card
            showToast(`Added: ${item.name}`);
            
            // Mark item as active in carousel
            const carouselItems = elements.jewelryCarousel.querySelectorAll('.carousel-item');
            carouselItems.forEach(card => {
                if (card.dataset.jewelryId === id) {
                    card.classList.add('active');
                }
            });
        }
        
        // 2. Controls Panel Toggle - Replaced with Floating Controls
        function toggleControlsPanel(show, jewelryId = null) {
            // Added a null check to prevent unnecessary processing
            if (show && jewelryId && appState.activeJewelry.has(jewelryId)) {
                renderFloatingControls(jewelryId);
                showFloatingControls(jewelryId);
            } else {
                hideFloatingControls();
            }
        }
        
        function renderFloatingControls(id) {
            if (!id || !appState.activeJewelry.has(id)) return;
            
            const jewelry = appState.activeJewelry.get(id);
            const originalJewelry = JEWELRY[id];
            
            // Update control title
            elements.controlTitle.textContent = originalJewelry.name;
            
            // Clear previous controls
            elements.controlContent.innerHTML = '';
            
            // Create a more transparent, minimalist control layout
            const controlsHTML = `
                <div class="ghost-style ultra-transparent-controls">
                    <div class="transparent-size-control">
                        <div class="control-label">
                            <span class="transparent-label">Size</span>
                            <span class="transparent-value" id="sizeValue">${Math.round(jewelry.scale * 100)}%</span>
                        </div>
                        <input type="range" 
                               min="0.5" 
                               max="2.0" 
                               step="0.05" 
                               value="${jewelry.scale}" 
                               oninput="updateJewelrySize('${id}', this.value)"
                               class="transparent-slider">
                    </div>
                    
                    <div class="transparent-opacity-control">
                        <div class="control-label">
                            <span class="transparent-label">Opacity</span>
                            <span class="transparent-value" id="opacityValue">${Math.round((jewelry.opacity || 1.0) * 100)}%</span>
                        </div>
                        <input type="range" 
                               min="0.2" 
                               max="1.0" 
                               step="0.05" 
                               value="${jewelry.opacity || 1.0}" 
                               oninput="updateJewelryOpacity('${id}', this.value)"
                               class="transparent-slider">
                    </div>
                    
                    <div class="transparent-position-control">
                        <div class="control-label transparent-label">Position</div>
                        <div class="transparent-grid">
                            <button onclick="moveJewelry('${id}', 'up-left')">↖</button>
                            <button onclick="moveJewelry('${id}', 'up')">↑</button>
                            <button onclick="moveJewelry('${id}', 'up-right')">↗</button>
                            <button onclick="moveJewelry('${id}', 'left')">←</button>
                            <button onclick="moveJewelry('${id}', 'center')">•</button>
                            <button onclick="moveJewelry('${id}', 'right')">→</button>
                            <button onclick="moveJewelry('${id}', 'down-left')">↙</button>
                            <button onclick="moveJewelry('${id}', 'down')">↓</button>
                            <button onclick="moveJewelry('${id}', 'down-right')">↘</button>
                        </div>
                    </div>
                    
                    <div class="transparent-action-buttons">
                        <button class="transparent-close-btn" onclick="hideFloatingControls()">
                            <i class="fas fa-times"></i> Close
                        </button>
                        <button class="transparent-remove-btn" onclick="removeJewelry('${id}')">
                            <i class="fas fa-trash"></i> Remove
                        </button>
                    </div>
                </div>
            `;
            
            elements.controlContent.innerHTML = controlsHTML;
            
            // Add ghost-style class to the main floating controls element
            elements.floatingControls.classList.add('ghost-style', 'auto-hide');
            
            // Remove any classes that might add backgrounds
            elements.floatingControls.classList.remove('mobile-translucent-controls');
            
            // Force transparency with inline styles
            elements.floatingControls.style.background = 'transparent';
            elements.floatingControls.style.boxShadow = 'none';
            elements.floatingControls.style.backdropFilter = 'none';
            elements.floatingControls.style.webkitBackdropFilter = 'none';
            
            // Remove auto-hide when user interacts with controls
            elements.floatingControls.addEventListener('touchstart', function() {
                this.classList.remove('auto-hide');
            });
            
            // Show the controls
            elements.floatingControls.classList.remove('hidden');
        }

        function showFloatingControls(id) {
            const position = getJewelryPosition(id);
            
            elements.floatingControls.style.top = `${position.y}px`;
            elements.floatingControls.style.left = `${position.x}px`;
            
            // Add ghost styling and remove any background-creating classes
            elements.floatingControls.classList.add('ghost-style');
            elements.floatingControls.classList.remove('mobile-translucent-controls');
            
            // Force transparency with inline styles
            elements.floatingControls.style.background = 'transparent';
            elements.floatingControls.style.boxShadow = 'none';
            elements.floatingControls.style.backdropFilter = 'none';
            elements.floatingControls.style.webkitBackdropFilter = 'none';
            elements.floatingControls.style.border = 'none';
            
            // More explicit visibility management
            elements.floatingControls.style.opacity = '1';
            elements.floatingControls.style.visibility = 'visible';
            elements.floatingControls.classList.remove('hidden');
            elements.floatingControls.classList.add('auto-hide');
            
            appState.selectedJewelryId = id;
            
            // Simplified interaction handler
            const clearAutoHideHandler = () => {
                elements.floatingControls.classList.remove('auto-hide');
                elements.floatingControls.removeEventListener('click', clearAutoHideHandler);
            };
            
            elements.floatingControls.addEventListener('click', clearAutoHideHandler, { once: true });
            
            resetControlsTimer();
        }
        
        function hideFloatingControls() {
            // More robust hiding mechanism
            elements.floatingControls.classList.add('hidden');
            elements.floatingControls.classList.remove('mobile-translucent-controls', 'auto-hide', 'ghost-style');
            
            // Reset styles explicitly
            elements.floatingControls.style.opacity = '0';
            elements.floatingControls.style.visibility = 'hidden';
            
            // Clear inline styles for transparency
            elements.floatingControls.style.background = '';
            elements.floatingControls.style.boxShadow = '';
            elements.floatingControls.style.backdropFilter = '';
            elements.floatingControls.style.webkitBackdropFilter = '';
            elements.floatingControls.style.border = '';
            
            appState.selectedJewelryId = null;
            clearTimeout(controlsActivityTimer);
        }
        
        // Auto-hide controls after period of inactivity
        let controlsActivityTimer;
        
        function resetControlsTimer() {
            clearTimeout(controlsActivityTimer);
            
            if (!elements.floatingControls.classList.contains('hidden')) {
                controlsActivityTimer = setTimeout(() => {
                    hideFloatingControls();
                }, 5000); // Hide after 5 seconds of inactivity
            }
        }
        
        // Calculate position for floating controls near jewelry
        function getJewelryPosition(jewelryId) {
            // Get capture button dimensions and position
            const captureBtn = document.getElementById('captureBtn');
            const captureBtnRect = captureBtn.getBoundingClientRect();
            
            // Set controls width and height (adjust as needed)
            const controlsWidth = 300;
            const controlsHeight = 350;
            
            // Position in the right corner, just above the capture button
            const x = window.innerWidth - controlsWidth - 20; // 20px from right edge
            const y = captureBtnRect.top - controlsHeight - 20; // 20px above capture button
            
            return { x, y };
        }
        
        // 3. Global Settings
        function renderGlobalSettings() {
            showAppSettings();
        }


       function showAppSettings() {
            // Clear control content
            elements.controlTitle.textContent = "App Settings";
            elements.controlContent.innerHTML = '';
            
            // Create settings HTML
            const settingsHTML = `
                <div class="control-group">
                    <div class="control-label">
                        <span>Camera Mirror</span>
                    </div>
                    <label class="toggle-switch">
                        <input type="checkbox" id="mirrorToggle" ${appState.mirrorCamera ? 'checked' : ''}>
                        <span class="toggle-slider"></span>
                    </label>
                    <p class="text-sm text-gray-500 mt-1">Mirror camera horizontally</p>
                </div>
                
                <div class="control-group">
                    <div class="control-label">
                        <span>Performance Mode</span>
                    </div>
                    <div class="flex gap-2 mt-2">
                        <button class="control-btn ${appState.performanceMode === 'low' ? 'bg-primary text-white' : ''}" 
                            onclick="setPerformanceMode('low')">Low</button>
                        <button class="control-btn ${appState.performanceMode === 'medium' ? 'bg-primary text-white' : ''}" 
                            onclick="setPerformanceMode('medium')">Medium</button>
                        <button class="control-btn ${appState.performanceMode === 'high' ? 'bg-primary text-white' : ''}" 
                            onclick="setPerformanceMode('high')">High</button>
                    </div>
                    <p class="text-sm text-gray-500 mt-1">Higher performance uses more battery</p>
                </div>
                
                <div class="control-group">
                    <button class="primary-button w-full" onclick="hideFloatingControls()">
                        Close Settings
                    </button>
                </div>
            `;
            
            elements.controlContent.innerHTML = settingsHTML;
            
            // Position controls in center of screen
            elements.floatingControls.style.top = '50%';
            elements.floatingControls.style.left = '50%';
            elements.floatingControls.style.transform = 'translate(-50%, -50%)';
            
            // Show controls
            elements.floatingControls.classList.remove('hidden');
            elements.floatingControls.classList.remove('auto-hide');
            
            // Add event listener for mirror toggle
            document.getElementById('mirrorToggle').addEventListener('change', (e) => {
                appState.mirrorCamera = e.target.checked;
                elements.video.style.transform = appState.mirrorCamera ? 'scaleX(-1)' : 'none';
                elements.canvas.style.transform = appState.mirrorCamera ? 'scaleX(-1)' : 'none';
            });
        } 
        
        /// Update jewelry size with visual feedback
        function updateJewelrySize(id, value) {
            if (!appState.activeJewelry.has(id)) return;
            
            const scale = parseFloat(value);
            const jewelry = appState.activeJewelry.get(id);
            jewelry.scale = scale;
            
            // Update size display with animation
            const sizeValue = document.getElementById('sizeValue');
            if (sizeValue) {
                // Add pulse animation
                sizeValue.classList.add('pulse-animation');
                sizeValue.textContent = `${Math.round(scale * 100)}%`;
                
                // Remove animation after it completes
                setTimeout(() => {
                    sizeValue.classList.remove('pulse-animation');
                }, 300);
            }
            
            // Reset auto-hide timer on interaction
            resetControlsTimer();
        }
        
        // Update jewelry opacity
        function updateJewelryOpacity(id, value) {
            if (!appState.activeJewelry.has(id)) return;
            
            const opacity = parseFloat(value);
            const jewelry = appState.activeJewelry.get(id);
            jewelry.opacity = opacity;
            
            // Update opacity display
            const opacityValue = document.getElementById('opacityValue');
            if (opacityValue) {
                opacityValue.textContent = `${Math.round(opacity * 100)}%`;
            }
            
            // Reset auto-hide timer on interaction
            resetControlsTimer();
        }
        
        // 4. Move Jewelry Function
        function moveJewelry(id, direction) {
            if (!appState.activeJewelry.has(id)) return;
            
            const jewelry = appState.activeJewelry.get(id);
            const step = 5; // Movement step in pixels
            
            // Reverse left/right directions if camera is mirrored
            if (appState.mirrorCamera) {
                if (direction === 'left') direction = 'right';
                else if (direction === 'right') direction = 'left';
                else if (direction === 'up-left') direction = 'up-right';
                else if (direction === 'up-right') direction = 'up-left';
                else if (direction === 'down-left') direction = 'down-right';
                else if (direction === 'down-right') direction = 'down-left';
            }
            
            switch (direction) {
                case 'up':
                    jewelry.offset.y -= step;
                    break;
                case 'down':
                    jewelry.offset.y += step;
                    break;
                case 'left':
                    jewelry.offset.x -= step;
                    break;
                case 'right':
                    jewelry.offset.x += step;
                    break;
                case 'up-left':
                    jewelry.offset.x -= step;
                    jewelry.offset.y -= step;
                    break;
                case 'up-right':
                    jewelry.offset.x += step;
                    jewelry.offset.y -= step;
                    break;
                case 'down-left':
                    jewelry.offset.x -= step;
                    jewelry.offset.y += step;
                    break;
                case 'down-right':
                    jewelry.offset.x += step;
                    jewelry.offset.y += step;
                    break;
                case 'center':
                    jewelry.offset = { x: 0, y: 0 };
                    break;
            }
            
            // Reset auto-hide timer on interaction
            resetControlsTimer();
        }
        // 5. Add Jewelry Function
        // Update the addJewelry function to handle auto-loaded items
        function addJewelry(id) {
            const originalJewelry = JEWELRY[id];
            if (!originalJewelry) {
                console.error(`Jewelry not found with ID: ${id}`);
                return;
            }
            
            // Skip if already active
            if (appState.activeJewelry.has(id)) {
                console.log(`Jewelry ${id} is already active, skipping`);
                return;
            }
            
            console.log(`Adding jewelry: ${id}, type: ${originalJewelry.type}, group: ${originalJewelry.group}`);
            
            // Create a deep copy of the jewelry item with loaded images
            const jewelryCopy = JSON.parse(JSON.stringify(originalJewelry));
            
            // Add loaded images (which can't be JSON stringified)
            if (originalJewelry.type === 'earrings') {
                jewelryCopy.leftImage = originalJewelry.leftImage;
                jewelryCopy.rightImage = originalJewelry.rightImage;
            } else {
                jewelryCopy.loadedImage = originalJewelry.loadedImage;
            }
            
            // Initialize with default values
            jewelryCopy.scale = originalJewelry.defaultScale || 1.0;
            jewelryCopy.offset = { x: 0, y: 0 };
            jewelryCopy.visible = true;
            jewelryCopy.opacity = 1.0;
            
            // For hand jewelry, set default hand and finger
            if (originalJewelry.type === 'hand') {
                jewelryCopy.handIndex = 0; // Default to first detected hand
            }
            
            // Add to active jewelry
            appState.activeJewelry.set(id, jewelryCopy);
            
            // Update UI
            if (appState.currentCategory === 'active') {
                renderActiveItems();
            } else {
                // Update just the particular carousel item to show as active
                const carouselItems = elements.jewelryCarousel.querySelectorAll('.carousel-item');
                carouselItems.forEach(card => {
                    if (card.dataset.jewelryId === id) {
                        card.classList.add('active');
                    }
                });
            }
            
            // Show toast notification only if not auto-loaded
            if (id !== appState.initialJewelryId) {
                showToast(`${originalJewelry.name} added`);
            }
        }    
        
        // 6. Remove Jewelry Function
        function removeJewelry(id) {
            const jewelry = JEWELRY[id];
            if (!jewelry) return;
            
            // Remove from active jewelry
            appState.activeJewelry.delete(id);
            
            // Hide floating controls if they were for this jewelry
            if (appState.selectedJewelryId === id) {
                hideFloatingControls();
            }
            
            // Show toast
            showToast(`${jewelry.name} removed`);
            
            // Re-render carousel if needed
            if (appState.currentCategory === 'active') {
                renderActiveItems();
            } else {
                // Update just the particular carousel item to show as inactive
                const carouselItems = elements.jewelryCarousel.querySelectorAll('.carousel-item');
                carouselItems.forEach(card => {
                    if (card.dataset.jewelryId === id) {
                        card.classList.remove('active');
                    }
                });
            }
        }
        
        function showToast(message) {
            const toast = elements.toast;
            toast.textContent = message;
            toast.classList.add('visible');
            
            // Hide toast after 2 seconds
            setTimeout(() => {
                toast.classList.remove('visible');
            }, 2000);
        }
        
        // AI detection loop
        async function detectAll() {
            if (!appState.isInitialized || !appState.isCameraReady) {
                requestAnimationFrame(detectAll);
                return;
            }
        
            if (!elements.video.videoWidth) {
                console.log("Video not ready yet");
                requestAnimationFrame(detectAll);
                return;
            }
        
            try {
                await Promise.all([
                    faceMesh.send({image: elements.video}),
                    hands.send({image: elements.video}),
                    pose.send({image: elements.video})
                ]);
            } catch (error) {
                console.error("Detection error:", error);
            }
            
            requestAnimationFrame(detectAll);
        }
        
        // MediaPipe result handlers
        function onFaceMeshResults(results) {
            appState.faceLandmarks = results.multiFaceLandmarks && results.multiFaceLandmarks.length > 0 
                ? results.multiFaceLandmarks[0] 
                : null;
            
            renderJewelry();
        }
        
        function onHandResults(results) {
            appState.handLandmarks = results.multiHandLandmarks || [];
            renderJewelry();
        }
        
        function onPoseResults(results) {
            appState.poseLandmarks = results.poseLandmarks || null;
            renderJewelry();
        }
        
        // Main rendering function
        function renderJewelry() {
            if (!elements.canvas || !elements.ctx) return;
            
            // Make sure canvas dimensions match video
            if (elements.canvas.width !== elements.video.videoWidth || 
                elements.canvas.height !== elements.video.videoHeight) {
                elements.canvas.width = elements.video.videoWidth;
                elements.canvas.height = elements.video.videoHeight;
            }
            
            // Clear canvas
            elements.ctx.clearRect(0, 0, elements.canvas.width, elements.canvas.height);
            
            // Nothing to render if no jewelry or no landmarks
            if (appState.activeJewelry.size === 0) return;
            
            // Render each active jewelry item
            appState.activeJewelry.forEach((jewelry, id) => {
                if (!jewelry.visible) return;
                
                if (jewelry.type === 'necklace') {
                    if (appState.poseLandmarks) {
                        drawNecklace(jewelry, id);
                    }
                } else if (jewelry.type === 'earrings') {
                    if (appState.faceLandmarks) {
                        drawEarrings(jewelry, id);
                    }
                } else if (jewelry.type === 'single') { // tikka, etc.
                    if (appState.faceLandmarks) {
                        drawSinglePiece(jewelry, id);
                    }
                } else if (jewelry.type === 'hand') {
                    if (appState.handLandmarks && appState.handLandmarks.length > 0) {
                        if (id.startsWith('ring')) {
                            drawRing(jewelry, id);
                        } else if (id.startsWith('bangle')) {
                            drawBangle(jewelry, id);
                        }
                    }
                }
            });
        }
        
        // Drawing functions for each jewelry type
        function drawNecklace(jewelry, id) {
            if (!jewelry.loadedImage) return;
            
            const leftShoulder = appState.poseLandmarks[11];
            const rightShoulder = appState.poseLandmarks[12];
            
            if (!leftShoulder || !rightShoulder) return;
        
            // Calculate base positions from shoulders
            const shoulderWidth = Math.abs(rightShoulder.x - leftShoulder.x) * elements.canvas.width;
            const collarOffset = 0.15;
            const leftX = leftShoulder.x * elements.canvas.width + shoulderWidth * collarOffset;
            const rightX = rightShoulder.x * elements.canvas.width - shoulderWidth * collarOffset;
            const baseY = leftShoulder.y * elements.canvas.height;
        
            // Apply measurements with mobile-friendly adjustments
            const VERTICAL_OFFSET = -115;
            const DROP_HEIGHT = 45;
            
            const adjustedY = baseY + VERTICAL_OFFSET + jewelry.offset.y;
            const centerX = (leftX + rightX) / 2 + jewelry.offset.x;
            
            // Calculate necklace dimensions
            const necklaceWidth = shoulderWidth * jewelry.scale;
            const necklaceHeight = jewelry.loadedImage.height * (necklaceWidth / jewelry.loadedImage.width);
        
            // Calculate the actual drawing position in canvas coordinates
            const drawX = centerX - necklaceWidth/2;
            const drawY = adjustedY - DROP_HEIGHT/2;
        
            // Set opacity if defined
            if (jewelry.opacity !== undefined) {
                elements.ctx.globalAlpha = jewelry.opacity;
            }
        
            // Draw the necklace
            elements.ctx.save();
            elements.ctx.shadowColor = 'rgba(0,0,0,0.3)';
            elements.ctx.shadowBlur = 8;
            elements.ctx.shadowOffsetX = 2;
            elements.ctx.shadowOffsetY = 2;
        
            elements.ctx.drawImage(
                jewelry.loadedImage,
                drawX, drawY, necklaceWidth, necklaceHeight
            );
            
            elements.ctx.restore();
        }
        
        function drawEarrings(jewelry, id) {
            if (!jewelry.leftImage || !jewelry.rightImage) return;
            
            const landmarks = appState.faceLandmarks;
            if (!landmarks) return;
            
            const nose = landmarks[1];
            const leftEar = landmarks[234];
            const rightEar = landmarks[454];
            
            if (!nose || !leftEar || !rightEar) return;
            
            const faceRotation = (rightEar.z - leftEar.z);
            let gap = jewelry.gap || 0;
            
            // Adjust gap based on face rotation
            if (Math.abs(faceRotation) <= 0.1) {
                gap += 3;
            } else {
                gap += 24;
            }
            
            const leftLobe = landmarks[177];
            const rightLobe = landmarks[401];
            
            if (!leftLobe || !rightLobe) return;
            
            const faceWidth = Math.abs(rightEar.x - leftEar.x) * elements.canvas.width;
            const gapAdjustment = (gap / 100) * faceWidth;
            
            const earHeight = Math.abs(landmarks[234].y - leftLobe.y) * elements.canvas.height;
            const baseScale = (earHeight * 0.8) / jewelry.leftImage.height;
            const scale = baseScale * jewelry.scale; // Combine base scale with user adjustable scale
            
            // Set opacity if defined
            if (jewelry.opacity !== undefined) {
                elements.ctx.globalAlpha = jewelry.opacity;
            }
            
            elements.ctx.save();
            elements.ctx.shadowColor = 'rgba(0,0,0,0.3)';
            elements.ctx.shadowBlur = 5;
            elements.ctx.shadowOffsetX = 2;
            elements.ctx.shadowOffsetY = 2;
            
            // Draw left earring if face is not turned too far right
            if (faceRotation > -0.1) {
                const leftX = leftLobe.x * elements.canvas.width - gapAdjustment + jewelry.offset.x;
                const leftY = leftLobe.y * elements.canvas.height + jewelry.offset.y;
                
                const leftWidth = jewelry.leftImage.width * scale;
                const leftHeight = jewelry.leftImage.height * scale;
                elements.ctx.drawImage(
                    jewelry.leftImage,
                    leftX - leftWidth/2,
                    leftY - leftHeight/2,
                    leftWidth,
                    leftHeight
                );
            }
            
            // Draw right earring if face is not turned too far left
            if (faceRotation < 0.1) {
                const rightX = rightLobe.x * elements.canvas.width + gapAdjustment + jewelry.offset.x + 5;
                const rightY = rightLobe.y * elements.canvas.height + jewelry.offset.y;
                
                const rightWidth = jewelry.rightImage.width * scale;
                const rightHeight = jewelry.rightImage.height * scale;
                elements.ctx.drawImage(
                    jewelry.rightImage,
                    rightX - rightWidth/2,
                    rightY - rightHeight/2,
                    rightWidth,
                    rightHeight
                );
            }
            
            elements.ctx.restore();
        }
        
        function drawSinglePiece(jewelry, id) {
            if (!jewelry.loadedImage) return;
            
            const landmarks = appState.faceLandmarks;
            if (!landmarks) return;
            
            let x, y, baseScale, scale;
            
            // For tikka
            if (jewelry.landmark === 151) {
                const centerPoint = landmarks[151]; // Center of forehead
                const topPoint = landmarks[10];     // Top of forehead
                const refPoint = landmarks[9];      // Reference point
                
                if (!centerPoint || !topPoint || !refPoint) return;
                
                // Calculate position on the forehead
                x = ((centerPoint.x + refPoint.x) / 2) * elements.canvas.width + jewelry.offset.x;
                y = ((centerPoint.y + topPoint.y) / 2) * elements.canvas.height - 20 + jewelry.offset.y - 5;
                
                // Scale based on forehead width
                const foreheadWidth = Math.abs(landmarks[71].x - landmarks[301].x) * elements.canvas.width;
                baseScale = (foreheadWidth * 0.4) / jewelry.loadedImage.width;
                scale = baseScale * jewelry.scale;
            } else {
                // Default to center of face if landmark isn't recognized
                const nose = landmarks[1];
                if (!nose) return;
                
                x = nose.x * elements.canvas.width + jewelry.offset.x;
                y = nose.y * elements.canvas.height + jewelry.offset.y;
                scale = jewelry.scale;
            }
            
            // Set opacity if defined
            if (jewelry.opacity !== undefined) {
                elements.ctx.globalAlpha = jewelry.opacity;
            }
            
            // Draw the jewelry
            elements.ctx.save();
            elements.ctx.shadowColor = 'rgba(0,0,0,0.3)';
            elements.ctx.shadowBlur = 8;
            elements.ctx.shadowOffsetX = 2;
            elements.ctx.shadowOffsetY = 2;
            
            const width = jewelry.loadedImage.width * scale;
            const height = jewelry.loadedImage.height * scale;
            
            elements.ctx.drawImage(
                jewelry.loadedImage,
                x - width/2,
                y - height/2,
                width,
                height
            );
            
            elements.ctx.restore();
        }

        function drawRing(jewelry, id) {
            if (!jewelry.loadedImage) return;
            
            // Check if we have hand landmarks and the right hand index
            const handIndex = jewelry.handIndex || 0;
            if (!appState.handLandmarks || !appState.handLandmarks[handIndex]) return;
            
            const handLandmarks = appState.handLandmarks[handIndex];
            const fingerTip = handLandmarks[jewelry.fingerIndex];
            const fingerBase = handLandmarks[jewelry.fingerIndex - 3];
            
            if (!fingerTip || !fingerBase) return;
            
            // Calculate position along the finger (closer to base)
            const positionRatio = 0.3; // 30% from base to tip
            const x = (fingerBase.x + (fingerTip.x - fingerBase.x) * positionRatio) * elements.canvas.width + jewelry.offset.x;
            const y = (fingerBase.y + (fingerTip.y - fingerBase.y) * positionRatio) * elements.canvas.height + jewelry.offset.y;
            
            // Calculate rotation angle
            const angle = Math.atan2(
                fingerTip.y - fingerBase.y,
                fingerTip.x - fingerBase.x
            );
            
            // Set opacity if defined
            if (jewelry.opacity !== undefined) {
                elements.ctx.globalAlpha = jewelry.opacity;
            }
            
            // Draw rotated ring
            elements.ctx.save();
            elements.ctx.translate(x, y);
            elements.ctx.rotate(angle - Math.PI/2);
            
            const width = jewelry.loadedImage.width * jewelry.scale;
            const height = jewelry.loadedImage.height * jewelry.scale;
            
            elements.ctx.drawImage(
                jewelry.loadedImage,
                -width/2,
                -height/2,
                width,
                height
            );
            
            elements.ctx.restore();
        }
        
        function drawBangle(jewelry, id) {
            if (!jewelry.loadedImage) return;
            
            // Check if we have hand landmarks and the right hand index
            const handIndex = jewelry.handIndex || 0;
            if (!appState.handLandmarks || !appState.handLandmarks[handIndex]) return;
            
            const handLandmarks = appState.handLandmarks[handIndex];
            const wrist = handLandmarks[0];
            const palmBase = handLandmarks[9];
            
            if (!wrist || !palmBase) return;
            
            // Add offsets to position bangle
            const verticalOffset = 30;
            const horizontalOffset = -20;
            
            const x = wrist.x * elements.canvas.width + horizontalOffset + jewelry.offset.x;
            const y = wrist.y * elements.canvas.height + verticalOffset + jewelry.offset.y;
            
            // Calculate rotation angle
            const angle = Math.atan2(
                palmBase.y - wrist.y,
                palmBase.x - wrist.x
            );
            
            // Calculate size based on wrist width
            const wristLeft = handLandmarks[17];
            const wristRight = handLandmarks[5];
            
            if (!wristLeft || !wristRight) return;
            
            const wristWidth = Math.abs(wristRight.x - wristLeft.x) * elements.canvas.width;
            const baseScale = 3.2;
            
            // Set opacity if defined
            if (jewelry.opacity !== undefined) {
                elements.ctx.globalAlpha = jewelry.opacity;
            }
            
            // Draw rotated bangle
            elements.ctx.save();
            elements.ctx.translate(x, y);
            elements.ctx.rotate(angle - Math.PI/2);
            
            const width = wristWidth * baseScale * jewelry.scale;
            const height = jewelry.loadedImage.height * (width / jewelry.loadedImage.width);
            
            elements.ctx.drawImage(
                jewelry.loadedImage,
                -width/2,
                -height/2,
                width,
                height
            );
            
            elements.ctx.restore();
        }
        
        // Camera access request
        async function requestCameraAccess() {
            try {
                document.getElementById('cameraError').classList.add('hidden');
                await initializeCamera();
                if (!appState.isInitialized) {
                    // If we haven't fully initialized yet, continue initialization
                    await initializeAIModels();
                    await preloadJewelryImages();
                    initializeUI();
                    appState.isInitialized = true;
                    requestAnimationFrame(detectAll);
                }
            } catch (error) {
                console.error("Camera request error:", error);
                document.getElementById('cameraError').classList.remove('hidden');
            }
        }
        
        function captureScreenshot() {
            try {
                // Pause the video stream
                elements.video.pause();
                
                // Create a new full-size canvas matching video dimensions
                const captureCanvas = document.createElement('canvas');
                captureCanvas.width = elements.video.videoWidth;
                captureCanvas.height = elements.video.videoHeight;
                const ctx = captureCanvas.getContext('2d');
                
                // Draw the video frame with mirroring if enabled
                ctx.save();
                if (appState.mirrorCamera) {
                    ctx.scale(-1, 1);
                    ctx.drawImage(
                        elements.video, 
                        -captureCanvas.width, 0, 
                        captureCanvas.width, 
                        captureCanvas.height
                    );
                } else {
                    ctx.drawImage(
                        elements.video,
                        0, 0,
                        captureCanvas.width,
                        captureCanvas.height
                    );
                }
                ctx.restore();
                
                // Draw jewelry canvas with the same mirroring if enabled
                ctx.save();
                if (appState.mirrorCamera) {
                    ctx.scale(-1, 1);
                    ctx.drawImage(
                        elements.canvas, 
                        -captureCanvas.width, 0, 
                        captureCanvas.width, 
                        captureCanvas.height
                    );
                } else {
                    ctx.drawImage(
                        elements.canvas,
                        0, 0,
                        captureCanvas.width,
                        captureCanvas.height
                    );
                }
                ctx.restore();
                
                // Try to get the data URL (this is where it might fail)
                const dataUrl = captureCanvas.toDataURL('image/png');
                
                // Create modal for preview and save
                const modal = document.createElement('div');
                modal.style.position = 'fixed';
                modal.style.top = '0';
                modal.style.left = '0';
                modal.style.width = '100%';
                modal.style.height = '100%';
                modal.style.backgroundColor = 'rgba(0,0,0,0.8)';
                modal.style.zIndex = '3000';
                modal.style.display = 'flex';
                modal.style.flexDirection = 'column';
                modal.style.alignItems = 'center';
                modal.style.justifyContent = 'center';
                
                const previewImg = document.createElement('img');
                previewImg.src = dataUrl;
                previewImg.style.maxWidth = '90%';
                previewImg.style.maxHeight = '80%';
                previewImg.style.objectFit = 'contain';
                
                const buttonContainer = document.createElement('div');
                buttonContainer.style.marginTop = '20px';
                
                const saveButton = document.createElement('button');
                saveButton.textContent = 'Save';
                saveButton.style.margin = '0 10px';
                saveButton.style.padding = '10px 20px';
                saveButton.style.backgroundColor = 'white';
                saveButton.style.color = '#7B2CBF';
                saveButton.style.fontWeight = 'bold';
                saveButton.style.border = 'none';
                saveButton.style.borderRadius = '5px';
                saveButton.style.cursor = 'pointer';
                saveButton.onclick = () => {
                    const link = document.createElement('a');
                    link.download = 'jewelry-tryon-' + new Date().toISOString().slice(0, 10) + '.png';
                    link.href = dataUrl;
                    link.click();
                    document.body.removeChild(modal);
                    elements.video.play();
                    
                    // Show review modal with the screenshot
                    showReviewModal(dataUrl);
                };
                
                const cancelButton = document.createElement('button');
                cancelButton.textContent = 'Cancel';
                cancelButton.style.margin = '0 10px';
                cancelButton.style.padding = '10px 20px';
                cancelButton.style.backgroundColor = 'white';
                cancelButton.style.color = '#7B2CBF';
                cancelButton.style.fontWeight = 'bold';
                cancelButton.style.border = 'none';
                cancelButton.style.borderRadius = '5px';
                cancelButton.style.cursor = 'pointer';
                cancelButton.onclick = () => {
                    document.body.removeChild(modal);
                    elements.video.play();
                    
                    // Show review modal even if they cancel
                    showReviewModal(dataUrl);
                };
                
                buttonContainer.appendChild(saveButton);
                buttonContainer.appendChild(cancelButton);
                
                modal.appendChild(previewImg);
                modal.appendChild(buttonContainer);
                
                document.body.appendChild(modal);
                
            } catch (error) {
                console.error("Screenshot error:", error);
                
                // Resume video playback
                elements.video.play();
                
                // Show error message to user
                showToast("Cannot capture screenshot due to image security restrictions. Please try reloading the page.");
                
                // You can still show the review modal with a placeholder image
                const placeholderImage = "https://via.placeholder.com/800x600?text=Screenshot+Unavailable";
                showReviewModal(placeholderImage);
            }
        }

        function showReviewModal(imageUrl) {
            // Set the screenshot in reviewData and preview
            reviewData.screenshot = imageUrl;
            const shareImage = document.getElementById('shareImage');
            if (shareImage) {
                shareImage.src = imageUrl;
            }
            
            // Activate the modal blocker to prevent interactions with the camera view
            const modalBlocker = document.getElementById('modalBlocker');
            if (modalBlocker) {
                modalBlocker.style.display = 'block';
                modalBlocker.style.pointerEvents = 'auto';
            }
            
            // Show the review modal with proper z-index
            const reviewModal = document.getElementById('reviewModal');
            if (reviewModal) {
                reviewModal.classList.remove('hidden');
                reviewModal.style.zIndex = '3000';
            }
            
            // Reset to first step
            resetReviewForm();
        }
        
        // Add this to your finishReview event handler
        function closeReviewModal() {
            document.getElementById('reviewModal').classList.add('hidden');
            
            // Hide the modal blocker
            const modalBlocker = document.getElementById('modalBlocker');
            if (modalBlocker) {
                modalBlocker.style.display = 'none';
                modalBlocker.style.pointerEvents = 'none';
            }
            
            resetReviewForm();
        }
        
        function resetReviewForm() {
            // Reset reviewData
            reviewData = {
                rating: 0,
                features: [],
                feedback: '',
                name: '',
                screenshot: reviewData.screenshot
            };
            
            // Reset UI elements
            const stars = document.querySelectorAll('.star');
            stars.forEach(star => {
                star.textContent = "☆";
                star.classList.remove('active', 'pulse');
            });
            
            const featureButtons = document.querySelectorAll('.feature-btn');
            featureButtons.forEach(button => {
                button.classList.remove('selected');
            });
            
            const reviewText = document.getElementById('reviewText');
            const reviewName = document.getElementById('reviewName');
            if (reviewText) reviewText.value = '';
            if (reviewName) reviewName.value = '';
            
            // Reset to first step
            const steps = [
                document.getElementById('reviewStep1'),
                document.getElementById('reviewStep2'),
                document.getElementById('reviewStep3'),
                document.getElementById('socialSharingStep')
            ];
            
            if (steps[0]) steps[0].classList.remove('hidden');
            if (steps[1]) steps[1].classList.add('hidden');
            if (steps[2]) steps[2].classList.add('hidden');
            if (steps[3]) steps[3].classList.add('hidden');
            
            // Reset next button state
            const nextToStep2 = document.getElementById('nextToStep2');
            if (nextToStep2) {
                nextToStep2.classList.add('opacity-50', 'cursor-not-allowed');
            }
            
            // Hide rating feedback
            const ratingFeedback = document.getElementById('ratingFeedback');
            if (ratingFeedback) {
                ratingFeedback.classList.add('opacity-0');
            }
        }
        
        // 15. Setup Gesture Handlers
        function setupGestureHandlers() {
            initializeDragGesture();
            initializePinchGesture();
            initializeTapGesture();
            
            // Add preview bar gestures
            const previewHandle = elements.previewHandle;
            if (previewHandle) {
                let startY = 0;
                
                previewHandle.addEventListener('click', togglePreviewBar);
                
                previewHandle.addEventListener('touchstart', (e) => {
                    startY = e.touches[0].clientY;
                    e.preventDefault();
                });
                
                previewHandle.addEventListener('touchmove', (e) => {
                    const deltaY = e.touches[0].clientY - startY;
                    
                    // If swiping up more than 10px, expand preview bar
                    if (deltaY < -10) {
                        elements.previewBar.classList.remove('collapsed');
                    }
                    // If swiping down more than 10px, collapse preview bar
                    else if (deltaY > 10) {
                        elements.previewBar.classList.add('collapsed');
                    }
                    
                    e.preventDefault();
                });
            }
        }
        
        // 14. Initialize Drag Gesture
        function initializeDragGesture() {
            const canvas = elements.canvas;
            let isDragging = false;
            let dragJewelryId = null;
            let dragStartPosition = { x: 0, y: 0 };
            let jewelryStartOffset = { x: 0, y: 0 };
            
            // For canvas jewelry dragging
            canvas.addEventListener('touchstart', (e) => {
                if (e.touches.length !== 1 || appState.activeJewelry.size === 0) return;
                
                const touch = e.touches[0];
                const position = { x: touch.clientX, y: touch.clientY };
                
                // Find jewelry at touch point
                const jewelryId = findJewelryAtPoint(position.x, position.y);
                if (jewelryId) {
                    isDragging = true;
                    dragJewelryId = jewelryId;
                    dragStartPosition = position;
                    
                    // Store starting offset
                    const jewelry = appState.activeJewelry.get(jewelryId);
                    jewelryStartOffset = { ...jewelry.offset };
                    
                    // Prevent scrolling while dragging jewelry
                    e.preventDefault();
                }
            });
            
            canvas.addEventListener('touchmove', (e) => {
                if (!isDragging || !dragJewelryId) return;
                
                const touch = e.touches[0];
                const position = { x: touch.clientX, y: touch.clientY };
                
                // Calculate movement delta
                const deltaX = position.x - dragStartPosition.x;
                const deltaY = position.y - dragStartPosition.y;
                
                // Update jewelry position
                const jewelry = appState.activeJewelry.get(dragJewelryId);
                if (jewelry) {
                    jewelry.offset.x = jewelryStartOffset.x + deltaX;
                    jewelry.offset.y = jewelryStartOffset.y + deltaY;
                }
                
                // Reset auto-hide timer when dragging
                resetControlsTimer();
                
                // Prevent scrolling
                e.preventDefault();
            });
            
            canvas.addEventListener('touchend', (e) => {
                isDragging = false;
                dragJewelryId = null;
            });
            
            canvas.addEventListener('touchcancel', (e) => {
                isDragging = false;
                dragJewelryId = null;
            });
            
            // For dragging the floating controls panel
            const controlHeader = elements.floatingControls.querySelector('.control-header');
            let isDraggingControls = false;
            let controlsStartX = 0;
            let controlsStartY = 0;
            
            if (controlHeader) {
                controlHeader.addEventListener('mousedown', (e) => {
                    isDraggingControls = true;
                    controlsStartX = e.clientX - elements.floatingControls.getBoundingClientRect().left;
                    controlsStartY = e.clientY - elements.floatingControls.getBoundingClientRect().top;
                    controlHeader.style.cursor = 'grabbing';
                    e.preventDefault();
                });
                
                controlHeader.addEventListener('touchstart', (e) => {
                    isDraggingControls = true;
                    controlsStartX = e.touches[0].clientX - elements.floatingControls.getBoundingClientRect().left;
                    controlsStartY = e.touches[0].clientY - elements.floatingControls.getBoundingClientRect().top;
                    e.preventDefault();
                });
            }
            
            window.addEventListener('mousemove', (e) => {
                if (!isDraggingControls) return;
                
                const x = e.clientX - controlsStartX;
                const y = e.clientY - controlsStartY;
                
                // Constrain to viewport
                const maxX = window.innerWidth - elements.floatingControls.offsetWidth;
                const maxY = window.innerHeight - elements.floatingControls.offsetHeight;
                
                elements.floatingControls.style.left = `${Math.max(0, Math.min(maxX, x))}px`;
                elements.floatingControls.style.top = `${Math.max(0, Math.min(maxY, y))}px`;
                
                // Remove any transform that might be applied
                elements.floatingControls.style.transform = 'none';
                
                // Reset auto-hide timer when dragging controls
                resetControlsTimer();
            });
            
            window.addEventListener('touchmove', (e) => {
                if (!isDraggingControls) return;
                
                const x = e.touches[0].clientX - controlsStartX;
                const y = e.touches[0].clientY - controlsStartY;
                
                // Constrain to viewport
                const maxX = window.innerWidth - elements.floatingControls.offsetWidth;
                const maxY = window.innerHeight - elements.floatingControls.offsetHeight;
                
                elements.floatingControls.style.left = `${Math.max(0, Math.min(maxX, x))}px`;
                elements.floatingControls.style.top = `${Math.max(0, Math.min(maxY, y))}px`;
                
                // Remove any transform that might be applied
                elements.floatingControls.style.transform = 'none';
                
                // Reset auto-hide timer when dragging controls
                resetControlsTimer();
                
                e.preventDefault();
            });
            
            window.addEventListener('mouseup', () => {
                if (isDraggingControls && controlHeader) {
                    controlHeader.style.cursor = 'grab';
                }
                isDraggingControls = false;
            });
            
            window.addEventListener('touchend', () => {
                isDraggingControls = false;
            });
        }
        
        // 13. Initialize Pinch Gesture
        function initializePinchGesture() {
            const canvas = elements.canvas;
            let initialDistance = 0;
            let selectedJewelryId = null;
            
            canvas.addEventListener('touchstart', (e) => {
                if (e.touches.length !== 2 || appState.activeJewelry.size === 0) return;
                
                // Calculate initial distance between touch points
                const touch1 = e.touches[0];
                const touch2 = e.touches[1];
                initialDistance = Math.hypot(
                    touch2.clientX - touch1.clientX,
                    touch2.clientY - touch1.clientY
                );
                
                // Find jewelry at midpoint of touch
                const midX = (touch1.clientX + touch2.clientX) / 2;
                const midY = (touch1.clientY + touch2.clientY) / 2;
                selectedJewelryId = findJewelryAtPoint(midX, midY);
                
                if (selectedJewelryId) {
                    e.preventDefault(); // Prevent default zoom behavior
                }
            });
            
            canvas.addEventListener('touchmove', (e) => {
                if (e.touches.length !== 2 || !selectedJewelryId) return;
                
                // Calculate new distance between touch points
                const touch1 = e.touches[0];
                const touch2 = e.touches[1];
                const currentDistance = Math.hypot(
                    touch2.clientX - touch1.clientX,
                    touch2.clientY - touch1.clientY
                );
                
                // Calculate scale factor
                const scaleFactor = currentDistance / initialDistance;
                
                // Get jewelry and update scale
                const jewelry = appState.activeJewelry.get(selectedJewelryId);
                if (jewelry) {
                    // Apply a dampening factor to make the scale change smoother
                    const dampening = 0.03;
                    const newScale = jewelry.scale * (1 + (scaleFactor - 1) * dampening);
                    
                    // Limit scale to reasonable bounds
                    jewelry.scale = Math.max(0.2, Math.min(3.0, newScale));
                    
                    // Update size value in control panel if visible
                    const sizeValue = document.getElementById('sizeValue');
                    if (sizeValue) {
                        sizeValue.textContent = `${Math.round(jewelry.scale * 100)}%`;
                    }
                }
                
                // Reset auto-hide timer on interaction
                resetControlsTimer();
                
                e.preventDefault(); // Prevent default zoom behavior
            });
            
            canvas.addEventListener('touchend', (e) => {
                if (e.touches.length === 0) {
                    selectedJewelryId = null;
                }
            });
        }
        
        // 12. Initialize Tap Gesture
        function initializeTapGesture() {
            const canvas = elements.canvas;
            let lastTapTime = 0;
            let lastTapPosition = { x: 0, y: 0 };
            
            canvas.addEventListener('touchend', (e) => {
                if (e.touches.length > 0 || appState.activeJewelry.size === 0) return;
                
                const touch = e.changedTouches[0];
                const currentTime = new Date().getTime();
                const tapPosition = { x: touch.clientX, y: touch.clientY };
                
                // Detect if this is a genuine tap
                const moveDistance = Math.sqrt(
                    Math.pow(tapPosition.x - lastTapPosition.x, 2) + 
                    Math.pow(tapPosition.y - lastTapPosition.y, 2)
                );
                
                if (moveDistance < 10) {
                    // Find jewelry at tap position
                    const jewelryId = findJewelryAtPoint(tapPosition.x, tapPosition.y);
                    if (jewelryId) {
                        // If double tap, toggle controls
                        if (currentTime - lastTapTime < 300) {
                            if (elements.floatingControls.classList.contains('hidden')) {
                                appState.selectedJewelryId = jewelryId;
                                renderFloatingControls(jewelryId);
                                showFloatingControls(jewelryId);
                            } else {
                                hideFloatingControls();
                            }
                        }
                        
                        lastTapTime = currentTime;
                    } else {
                        // If tap on empty space, hide controls
                        hideFloatingControls();
                    }
                }
                
                lastTapPosition = tapPosition;
            });
            
            // Single click for desktop support
            canvas.addEventListener('click', (e) => {
                if (appState.activeJewelry.size === 0) return;
                
                // Find jewelry at click position
                const jewelryId = findJewelryAtPoint(e.clientX, e.clientY);
                if (jewelryId) {
                    // Toggle controls
                    if (elements.floatingControls.classList.contains('hidden') || 
                        appState.selectedJewelryId !== jewelryId) {
                        appState.selectedJewelryId = jewelryId;
                        renderFloatingControls(jewelryId);
                        showFloatingControls(jewelryId);
                    } else {
                        hideFloatingControls();
                    }
                } else {
                    // If click on empty space, hide controls
                    hideFloatingControls();
                }
            });
        }
        
        // 11. Find Jewelry at Point
        function findJewelryAtPoint(clientX, clientY) {
            // Convert client coordinates to canvas coordinates
            const rect = elements.canvas.getBoundingClientRect();
            const canvasX = (clientX - rect.left) * (elements.canvas.width / rect.width);
            const canvasY = (clientY - rect.top) * (elements.canvas.height / rect.height);
            
            // Check each active jewelry
            for (const [id, jewelry] of appState.activeJewelry.entries()) {
                if (!jewelry.visible) continue;
                
                // Simplified hit testing based on jewelry type
                let hit = false;
                
                if (jewelry.type === 'earrings' && appState.faceLandmarks) {
                    // Test both earrings
                    const leftLobe = appState.faceLandmarks[177];
                    const rightLobe = appState.faceLandmarks[401];
                    
                    if (leftLobe && rightLobe) {
                        const leftX = leftLobe.x * elements.canvas.width + jewelry.offset.x;
                        const leftY = leftLobe.y * elements.canvas.height + jewelry.offset.y;
                        const rightX = rightLobe.x * elements.canvas.width + jewelry.offset.x;
                        const rightY = rightLobe.y * elements.canvas.height + jewelry.offset.y;
                        
                        // Hit radius based on scale
                        const radius = 50 * jewelry.scale;
                        
                        // Check if touch is inside either earring's hit area
                        const leftDist = Math.sqrt(Math.pow(canvasX - leftX, 2) + Math.pow(canvasY - leftY, 2));
                        const rightDist = Math.sqrt(Math.pow(canvasX - rightX, 2) + Math.pow(canvasY - rightY, 2));
                        
                        if (leftDist < radius || rightDist < radius) {
                            hit = true;
                        }
                    }
                } else if (jewelry.type === 'necklace' && appState.poseLandmarks) {
                    const leftShoulder = appState.poseLandmarks[11];
                    const rightShoulder = appState.poseLandmarks[12];
                    
                    if (leftShoulder && rightShoulder) {
                        const centerX = (leftShoulder.x + rightShoulder.x) / 2 * elements.canvas.width + jewelry.offset.x;
                        const centerY = leftShoulder.y * elements.canvas.height - 100 + jewelry.offset.y;
                        
                        // Hit area based on necklace size
                        const hitRadius = 100 * jewelry.scale;
                        
                        const dist = Math.sqrt(Math.pow(canvasX - centerX, 2) + Math.pow(canvasY - centerY, 2));
                        if (dist < hitRadius) {
                            hit = true;
                        }
                    }
                } else if (jewelry.type === 'single' && appState.faceLandmarks) {
                    const centerPoint = appState.faceLandmarks[151];
                    
                    if (centerPoint) {
                        const x = centerPoint.x * elements.canvas.width + jewelry.offset.x;
                        const y = centerPoint.y * elements.canvas.height - 20 + jewelry.offset.y;
                        
                        // Hit radius based on scale
                        const radius = 50 * jewelry.scale;
                        
                        const dist = Math.sqrt(Math.pow(canvasX - x, 2) + Math.pow(canvasY - y, 2));
                        if (dist < radius) {
                            hit = true;
                        }
                    }
                } else if (jewelry.type === 'hand' && appState.handLandmarks && appState.handLandmarks.length > 0) {
                    const handIndex = jewelry.handIndex || 0;
                    
                    if (appState.handLandmarks[handIndex]) {
                        // For ring
                        if (id.startsWith('ring')) {
                            const handLandmarks = appState.handLandmarks[handIndex];
                            const fingerTip = handLandmarks[jewelry.fingerIndex];
                            const fingerBase = handLandmarks[jewelry.fingerIndex - 3];
                            
                            if (fingerTip && fingerBase) {
                                // Position ring between tip and base
                                const positionRatio = 0.3;
                                const x = (fingerBase.x + (fingerTip.x - fingerBase.x) * positionRatio) * elements.canvas.width + jewelry.offset.x;
                                const y = (fingerBase.y + (fingerTip.y - fingerBase.y) * positionRatio) * elements.canvas.height + jewelry.offset.y;
                                
                                // Hit radius based on ring size
                                const radius = 30 * jewelry.scale;
                                
                                const dist = Math.sqrt(Math.pow(canvasX - x, 2) + Math.pow(canvasY - y, 2));
                                if (dist < radius) {
                                    hit = true;
                                }
                            }
                        } else if (id.startsWith('bangle')) {
                            const handLandmarks = appState.handLandmarks[handIndex];
                            const wrist = handLandmarks[0];
                            
                            if (wrist) {
                                const x = wrist.x * elements.canvas.width + jewelry.offset.x;
                                const y = wrist.y * elements.canvas.height + jewelry.offset.y;
                                
                                // Hit radius based on bangle size
                                const radius = 40 * jewelry.scale;
                                
                                const dist = Math.sqrt(Math.pow(canvasX - x, 2) + Math.pow(canvasY - y, 2));
                                if (dist < radius) {
                                    hit = true;
                                }
                            }
                        }
                    }
                }
                
                if (hit) {
                    return id;
                }
            }
            
            return null; // No jewelry found at touch point
        }
        
        // 10. Add to Cart Function
        function addToCart(id) {
            const item = JEWELRY[id];
            if (!item) return;
            
            // Just show toast notification
            showToast(`${item.name} added to cart`);
        }
        
        // Helper function for loading status updates
        function updateLoadingStatus(message) {
            const loadingScreen = document.getElementById('loadingScreen');
            const statusText = loadingScreen.querySelector('p:not(.loading-error)');
            if (statusText) {
                statusText.textContent = message;
            }
        }
        
        function showError(message) {
            const loadingScreen = document.getElementById('loadingScreen');
            const errorElement = loadingScreen.querySelector('.loading-error');
            if (errorElement) {
                errorElement.textContent = message;
                errorElement.classList.remove('hidden');
            }
        }
        
        function hideLoadingScreen() {
            document.getElementById('loadingScreen').classList.add('hidden');
        }
        
        function setPerformanceMode(mode) {
            appState.performanceMode = mode;
            
            // Update UI buttons
            const lowBtn = document.querySelector('button[onclick="setPerformanceMode(\'low\')"]');
            const mediumBtn = document.querySelector('button[onclick="setPerformanceMode(\'medium\')"]');
            const highBtn = document.querySelector('button[onclick="setPerformanceMode(\'high\')"]');
            
            if (lowBtn) lowBtn.classList.toggle('bg-primary', mode === 'low');
            if (lowBtn) lowBtn.classList.toggle('text-white', mode === 'low');
            if (mediumBtn) mediumBtn.classList.toggle('bg-primary', mode === 'medium');
            if (mediumBtn) mediumBtn.classList.toggle('text-white', mode === 'medium');
            if (highBtn) highBtn.classList.toggle('bg-primary', mode === 'high');
            if (highBtn) highBtn.classList.toggle('text-white', mode === 'high');
            
            // Apply performance settings to AI models
            switch(mode) {
                case 'low':
                    if (faceMesh) faceMesh.setOptions({ 
                        maxNumFaces: 1,
                        refineLandmarks: false, 
                        minDetectionConfidence: 0.7, 
                        minTrackingConfidence: 0.7 
                    });
                    if (hands) hands.setOptions({ 
                        maxNumHands: 1, 
                        modelComplexity: 0, 
                        minDetectionConfidence: 0.7, 
                        minTrackingConfidence: 0.7 
                    });
                    if (pose) pose.setOptions({ 
                        modelComplexity: 0, 
                        smoothLandmarks: true,
                        minDetectionConfidence: 0.7, 
                        minTrackingConfidence: 0.7 
                    });
                    showToast('Low performance mode active');
                    break;
                    
                case 'medium':
                    if (faceMesh) faceMesh.setOptions({ 
                        maxNumFaces: 1,
                        refineLandmarks: true, 
                        minDetectionConfidence: 0.5, 
                        minTrackingConfidence: 0.5 
                    });
                    if (hands) hands.setOptions({ 
                        maxNumHands: 2, 
                        modelComplexity: 0, 
                        minDetectionConfidence: 0.5, 
                        minTrackingConfidence: 0.5 
                    });
                    if (pose) pose.setOptions({ 
                        modelComplexity: 0, 
                        smoothLandmarks: true,
                        minDetectionConfidence: 0.5, 
                        minTrackingConfidence: 0.5 
                    });
                    showToast('Medium performance mode active');
                    break;
                    
                case 'high':
                    if (faceMesh) faceMesh.setOptions({ 
                        maxNumFaces: 1,
                        refineLandmarks: true, 
                        minDetectionConfidence: 0.5, 
                        minTrackingConfidence: 0.5 
                    });
                    if (hands) hands.setOptions({ 
                        maxNumHands: 2, 
                        modelComplexity: 1, 
                        minDetectionConfidence: 0.5, 
                        minTrackingConfidence: 0.5 
                    });
                    if (pose) pose.setOptions({ 
                        modelComplexity: 1, 
                        smoothLandmarks: true,
                        minDetectionConfidence: 0.5, 
                        minTrackingConfidence: 0.5 
                    });
                    showToast('High performance mode active');
                    break;
            }
        }
        
        // Window resize handler
        window.addEventListener('resize', () => {
            // Update canvas dimensions to match video
            if (elements.video && elements.canvas) {
                elements.canvas.width = elements.video.videoWidth;
                elements.canvas.height = elements.video.videoHeight;
            }
            
            // Hide floating controls to prevent them being in wrong position
            hideFloatingControls();
            
            // Re-render active jewelry after resize
            renderJewelry();
        });
        
        // Handle orientation change
        window.addEventListener('orientationchange', () => {
            // Short delay to allow UI to stabilize after rotation
            setTimeout(() => {
                // Update canvas dimensions
                if (elements.video && elements.canvas) {
                    elements.canvas.width = elements.video.videoWidth;
                    elements.canvas.height = elements.video.videoHeight;
                }
                
                // Hide floating controls
                hideFloatingControls();
                
                // Re-render active jewelry
                renderJewelry();
            }, 300);
        });
        
        // Initialize the app when the document is loaded
        document.addEventListener('DOMContentLoaded', init);
        let reviewData = {
            rating: 0,
            features: [],
            feedback: '',
            name: '',
            screenshot: null
        };
        
        // DOM Elements
        const reviewModal = document.getElementById('reviewModal');
        const reviewStep1 = document.getElementById('reviewStep1');
        const reviewStep2 = document.getElementById('reviewStep2');
        const reviewStep3 = document.getElementById('reviewStep3');
        const socialSharingStep = document.getElementById('socialSharingStep');
        const ratingFeedback = document.getElementById('ratingFeedback');
        const nextToStep2 = document.getElementById('nextToStep2');
        const backToStep1 = document.getElementById('backToStep1');
        const nextToStep3 = document.getElementById('nextToStep3');
        const backToStep2 = document.getElementById('backToStep2');
        const submitReview = document.getElementById('submitReview');
        const finishReview = document.getElementById('finishReview');
        const stars = document.querySelectorAll('.star');
        const featureButtons = document.querySelectorAll('.feature-btn');
        const confettiCanvas = document.getElementById('confettiCanvas');
        
        // Initialize confetti context
        const confettiCtx = confettiCanvas ? confettiCanvas.getContext('2d') : null;
        // Initialize event listeners for review system after DOM is loaded
        document.addEventListener('DOMContentLoaded', function() {
            // Initialize star rating
            const stars = document.querySelectorAll('.star');
            stars.forEach(star => {
                star.addEventListener('click', () => {
                    const rating = parseInt(star.dataset.rating);
                    reviewData.rating = rating;
                    
                    // Update visual appearance of stars
                    stars.forEach((s, index) => {
                        const starRating = parseInt(s.dataset.rating);
                        // Remove all classes first
                        s.classList.remove('active', 'pulse');
                        
                        // Add appropriate classes
                        if (starRating <= rating) {
                            s.textContent = "★";
                            s.classList.add('active');
                            // Add pulse animation to the clicked star
                            if (starRating === rating) {
                                s.classList.add('pulse');
                            }
                        } else {
                            s.textContent = "☆";
                        }
                    });
                    
                    // Show appropriate feedback based on rating
                    const ratingFeedback = document.getElementById('ratingFeedback');
                    ratingFeedback.classList.remove('opacity-0');
                    
                    if (rating <= 2) {
                        // Low rating feedback with shake animation
                        ratingFeedback.innerHTML = `
                            <div class="shake-animation flex flex-col items-center text-orange-500">
                                <i class="fas fa-wrench text-3xl mb-2"></i>
                                <p>We'll work hard to make it better!</p>
                            </div>
                        `;
                    } else if (rating === 3) {
                        // Medium rating feedback
                        ratingFeedback.innerHTML = `
                            <div class="flex flex-col items-center text-blue-500">
                                <i class="fas fa-thumbs-up text-3xl mb-2"></i>
                                <p>Thanks for your feedback!</p>
                            </div>
                        `;
                    } else {
                        // High rating feedback (4-5) with celebration animation
                        ratingFeedback.innerHTML = `
                            <div class="celebrate-animation flex flex-col items-center text-green-500">
                                <i class="fas fa-star text-3xl mb-2"></i>
                                <p>We're thrilled you enjoyed it!</p>
                            </div>
                        `;
                        
                        // Show confetti for high ratings
                        showConfetti();
                    }
                    
                    // Enable the next button
                    const nextToStep2 = document.getElementById('nextToStep2');
                    nextToStep2.classList.remove('opacity-50', 'cursor-not-allowed');
                    
                    // Remove animation classes after they play
                    setTimeout(() => {
                        ratingFeedback.classList.remove('shake-animation', 'celebrate-animation');
                    }, 1000);
                });
            });
            
            // Initialize feature buttons
            const featureButtons = document.querySelectorAll('.feature-btn');
            featureButtons.forEach(button => {
                button.addEventListener('click', () => {
                    button.classList.toggle('selected');
                    
                    // Update the features array in reviewData
                    const featureText = button.textContent.trim();
                    if (button.classList.contains('selected')) {
                        // Add to features if not already included
                        if (!reviewData.features.includes(featureText)) {
                            reviewData.features.push(featureText);
                        }
                    } else {
                        // Remove from features
                        reviewData.features = reviewData.features.filter(feature => feature !== featureText);
                    }
                });
            });
            
            // Initialize navigation buttons
            const nextToStep2 = document.getElementById('nextToStep2');
            if (nextToStep2) {
                nextToStep2.addEventListener('click', () => {
                    if (reviewData.rating > 0) {
                        document.getElementById('reviewStep1').classList.add('hidden');
                        document.getElementById('reviewStep2').classList.remove('hidden');
                    }
                });
            }
            
            const backToStep1 = document.getElementById('backToStep1');
            if (backToStep1) {
                backToStep1.addEventListener('click', () => {
                    document.getElementById('reviewStep2').classList.add('hidden');
                    document.getElementById('reviewStep1').classList.remove('hidden');
                });
            }
            
            const nextToStep3 = document.getElementById('nextToStep3');
            if (nextToStep3) {
                nextToStep3.addEventListener('click', () => {
                    document.getElementById('reviewStep2').classList.add('hidden');
                    document.getElementById('reviewStep3').classList.remove('hidden');
                });
            }
            
            const backToStep2 = document.getElementById('backToStep2');
            if (backToStep2) {
                backToStep2.addEventListener('click', () => {
                    document.getElementById('reviewStep3').classList.add('hidden');
                    document.getElementById('reviewStep2').classList.remove('hidden');
                });
            }
            
            // Initialize submit review
            const submitReview = document.getElementById('submitReview');
            if (submitReview) {
                submitReview.addEventListener('click', () => {
                    // Collect final data
                    const reviewText = document.getElementById('reviewText');
                    const reviewName = document.getElementById('reviewName');
                    reviewData.feedback = reviewText ? reviewText.value : '';
                    reviewData.name = reviewName && reviewName.value ? reviewName.value : 'Anonymous';
                    
                    // Here you would typically send this data to your server
                    console.log('Review submitted:', reviewData);
                    
                    // Show thumbs up animation before moving to social step
                    const thumbsUp = document.createElement('div');
                    thumbsUp.innerHTML = `
                        <div class="fixed inset-0 flex items-center justify-center z-[1002]">
                            <i class="fas fa-thumbs-up text-green-500 text-7xl thumbs-up-animation"></i>
                        </div>
                    `;
                    document.body.appendChild(thumbsUp);
                    
                    // Show social sharing step after a brief delay
                    setTimeout(() => {
                        document.body.removeChild(thumbsUp);
                        document.getElementById('reviewStep3').classList.add('hidden');
                        document.getElementById('socialSharingStep').classList.remove('hidden');
                    }, 1500);
                });
            }
            
            // Initialize social sharing
            const shareInstagram = document.getElementById('shareInstagram');
            if (shareInstagram) {
                shareInstagram.addEventListener('click', (e) => {
                    e.preventDefault();
                    window.open('https://www.instagram.com', '_blank');
                });
            }
            
            const shareTwitter = document.getElementById('shareTwitter');
            if (shareTwitter) {
                shareTwitter.addEventListener('click', (e) => {
                    e.preventDefault();
                    const text = `Just tried this amazing virtual jewelry try-on experience! #InfiniteAITryOn`;
                    const shareUrl = `https://twitter.com/intent/tweet?text=${encodeURIComponent(text)}`;
                    window.open(shareUrl, '_blank');
                });
            }
            
            const shareFacebook = document.getElementById('shareFacebook');
            if (shareFacebook) {
                shareFacebook.addEventListener('click', (e) => {
                    e.preventDefault();
                    const shareUrl = `https://www.facebook.com/sharer/sharer.php?u=${encodeURIComponent(window.location.href)}&quote=${encodeURIComponent('Check out this amazing virtual jewelry try-on experience! #InfiniteAITryOn')}`;
                    window.open(shareUrl, '_blank');
                });
            }
            
            const shareWhatsapp = document.getElementById('shareWhatsapp');
            if (shareWhatsapp) {
                shareWhatsapp.addEventListener('click', (e) => {
                    e.preventDefault();
                    const text = `Check out my virtual jewelry try-on! #InfiniteAITryOn ${window.location.href}`;
                    const shareUrl = `https://wa.me/?text=${encodeURIComponent(text)}`;
                    window.open(shareUrl, '_blank');
                });
            }
            
            // Initialize close button
            // In the finish review function
            const finishReview = document.getElementById('finishReview');
            if (finishReview) {
                finishReview.addEventListener('click', () => {
                    // Replace the existing code with the closeReviewModal function
                    closeReviewModal();
                });
            }
        }); // Add this closing brace
        
        // Confetti Animation Function
        function showConfetti() {
            const confettiCanvas = document.getElementById('confettiCanvas');
            if (!confettiCanvas) return;
            
            const confettiCtx = confettiCanvas.getContext('2d');
            confettiCanvas.classList.remove('hidden');
            
            // Set canvas dimensions
            confettiCanvas.width = window.innerWidth;
            confettiCanvas.height = window.innerHeight;
            
            const particles = [];
            const particleCount = 150;
            const gravity = 0.5;
            const colors = ['#7B2CBF', '#9D4EDD', '#C77DFF', '#FFFF00', '#FFD700'];
            const shapes = ['circle', 'square', 'triangle'];
            
            // Create particles
            for (let i = 0; i < particleCount; i++) {
                particles.push({
                    x: Math.random() * confettiCanvas.width,
                    y: Math.random() * confettiCanvas.height - confettiCanvas.height,
                    color: colors[Math.floor(Math.random() * colors.length)],
                    size: Math.random() * 10 + 5,
                    shape: shapes[Math.floor(Math.random() * shapes.length)],
                    velocity: {
                        x: Math.random() * 6 - 3,
                        y: Math.random() * 3 + 2
                    },
                    rotation: Math.random() * 360,
                    rotationSpeed: Math.random() * 10 - 5
                });
            }
            
            // Animation loop
            function animate() {
                if (confettiCanvas.classList.contains('hidden')) return;
                
                confettiCtx.clearRect(0, 0, confettiCanvas.width, confettiCanvas.height);
                
                let stillAnimating = false;
                
                particles.forEach(p => {
                    p.y += p.velocity.y;
                    p.x += p.velocity.x;
                    p.velocity.y += gravity / 10;
                    p.rotation += p.rotationSpeed;
                    
                    // Check if any particles are still visible
                    if (p.y < confettiCanvas.height) {
                        stillAnimating = true;
                    }
                    
                    confettiCtx.save();
                    confettiCtx.translate(p.x, p.y);
                    confettiCtx.rotate(p.rotation * Math.PI / 180);
                    
                    confettiCtx.fillStyle = p.color;
                    
                    if (p.shape === 'circle') {
                        confettiCtx.beginPath();
                        confettiCtx.arc(0, 0, p.size, 0, Math.PI * 2);
                        confettiCtx.fill();
                    } else if (p.shape === 'square') {
                        confettiCtx.fillRect(-p.size/2, -p.size/2, p.size, p.size);
                    } else if (p.shape === 'triangle') {
                        confettiCtx.beginPath();
                        confettiCtx.moveTo(0, -p.size);
                        confettiCtx.lineTo(p.size, p.size);
                        confettiCtx.lineTo(-p.size, p.size);
                        confettiCtx.closePath();
                        confettiCtx.fill();
                    }
                    
                    confettiCtx.restore();
                });
                
                if (stillAnimating) {
                    requestAnimationFrame(animate);
                } else {
                    confettiCanvas.classList.add('hidden');
                }
            }
            
            animate();
        }

        // Guided Tour Implementation
        class GuidedTour {
            constructor() {
                // Tour elements
                this.overlay = document.getElementById('tourOverlay');
                this.highlight = document.getElementById('tourHighlight');
                this.tooltip = document.getElementById('tourTooltip');
                this.tooltipTitle = document.getElementById('tourTooltipTitle');
                this.tooltipContent = document.getElementById('tourTooltipContent');
                this.progressText = document.getElementById('tourProgress');
                this.nextButton = document.getElementById('tourNext');
                this.skipButton = document.getElementById('tourSkip');
                this.welcomeModal = document.getElementById('tourWelcomeModal');
                this.startButton = document.getElementById('tourStart');
                this.dismissButton = document.getElementById('tourDismiss');
                this.restartButton = document.getElementById('restartTour');
                
                // Check if elements exist
                if (!this.overlay || !this.highlight || !this.tooltip) {
                    console.error('Tour elements not found in the DOM');
                    return;
                }
                
                // Tour state
                this.currentStep = 0;
                this.tourActive = false;
                this.hasSeenTour = localStorage.getItem('hasSeenTour') === 'true';
                
                // Tour steps configuration
                this.tourSteps = [
                    {
                        element: '.category-pills',
                        title: 'Jewelry Categories',
                        content: 'These pills let you switch between different jewelry categories like Face, Ear, Neck, and Hand',
                        position: 'bottom',
                        spotlight: 'rect',
                        padding: 10,
                    },
                    {
                        element: '[data-category="active"]',
                        title: 'Active Items',
                        content: 'Click here to see all the jewelry items you are currently wearing to adjust their position & size ',
                        position: 'bottom',
                        spotlight: 'rect',
                        padding: 5,
                    },
                    {
                        element: '#jewelryCarousel',
                        title: 'Jewelry Selection',
                        content: 'Browse and select jewelry items from this carousel. Tap an item once to try it on! Tap again to remove it!',
                        position: 'top',
                        spotlight: 'rect',
                        padding: 10,
                    },
                    {
                        element: '#captureBtn',
                        title: 'Capture Button',
                        content: 'Tap here to take a screenshot of your look. You can save or share it!',
                        position: 'left',
                        spotlight: 'circle',
                        padding: 10,
                    },
                    {
                        element: 'body',
                        title: 'Perfect Positioning',
                        content: 'For best results, keep your face at eye level and about an arm\'s length from the camera.',
                        position: 'center',
                        spotlight: 'none',
                        padding: 0,
                        isModal: true
                    },
                    {
                        element: 'body',
                        title: 'You\'re Ready!',
                        content: 'Now you\'re ready to try on different jewelry styles. Have fun exploring!',
                        position: 'center',
                        spotlight: 'none',
                        padding: 0,
                        isModal: true,
                        isLast: true
                    }
                ];
                
                // Initialize event listeners
                this.initEventListeners();
                console.log('GuidedTour initialized successfully');
            }
            
            initEventListeners() {
                // Welcome modal buttons
                if (this.startButton) {
                    this.startButton.addEventListener('click', () => {
                        console.log('Start tour clicked');
                        this.hideWelcomeModal();
                        this.startTour();
                    });
                }
                
                if (this.dismissButton) {
                    this.dismissButton.addEventListener('click', () => {
                        console.log('Dismiss tour clicked');
                        this.hideWelcomeModal();
                        localStorage.setItem('hasSeenTour', 'true');
                        this.showRestartButton();
                    });
                }
                
                // Tour navigation buttons
                if (this.nextButton) {
                    this.nextButton.addEventListener('click', () => {
                        console.log('Next button clicked');
                        this.nextStep();
                    });
                }
                
                if (this.skipButton) {
                    this.skipButton.addEventListener('click', () => {
                        console.log('Skip button clicked');
                        this.endTour();
                    });
                }
                
                // Restart tour button
                if (this.restartButton) {
                    this.restartButton.addEventListener('click', () => {
                        console.log('Restart tour clicked');
                        this.startTour();
                    });
                }
                
                // Listen for window resize to reposition elements
                window.addEventListener('resize', () => {
                    if (this.tourActive) {
                        console.log('Window resized, repositioning tour elements');
                        this.positionElements();
                    }
                });
                
                console.log('Tour event listeners initialized');
            }
            
            showWelcomeModal() {
                console.log('Showing welcome modal');
                if (this.welcomeModal) {
                    this.welcomeModal.classList.add('active');
                }
            }
            
            hideWelcomeModal() {
                console.log('Hiding welcome modal');
                if (this.welcomeModal) {
                    this.welcomeModal.classList.remove('active');
                }
            }
            
            showRestartButton() {
                console.log('Showing restart button');
                if (this.restartButton) {
                    this.restartButton.style.display = 'flex';
                }
            }
            
            hideRestartButton() {
                console.log('Hiding restart button');
                if (this.restartButton) {
                    this.restartButton.style.display = 'none';
                }
            }
            
            startTour() {
                console.log('Starting tour');
                this.currentStep = 0;
                this.tourActive = true;
                this.hideRestartButton();
                this.goToStep(0);
                localStorage.setItem('hasSeenTour', 'true');
            }
            
            endTour() {
                console.log('Ending tour');
                this.tourActive = false;
                
                if (this.overlay) {
                    this.overlay.classList.remove('active');
                }
                if (this.tooltip) {
                    this.tooltip.classList.remove('active');
                }
                
                // Clean up any temporary changes
                const currentStep = this.tourSteps[this.currentStep];
                if (currentStep && currentStep.cleanupFunction) {
                    currentStep.cleanupFunction();
                }
                
                this.showRestartButton();
            }
            
            nextStep() {
                console.log(`Moving from step ${this.currentStep} to next step`);
                // Clean up any temporary changes
                const currentStep = this.tourSteps[this.currentStep];
                if (currentStep && currentStep.cleanupFunction) {
                    currentStep.cleanupFunction();
                }
                
                if (this.currentStep < this.tourSteps.length - 1) {
                    this.goToStep(this.currentStep + 1);
                } else {
                    this.endTour();
                }
            }
            
            goToStep(stepIndex) {
                if (stepIndex < 0 || stepIndex >= this.tourSteps.length) return;
                
                console.log(`Going to step ${stepIndex}: ${this.tourSteps[stepIndex].title}`);
                this.currentStep = stepIndex;
                const step = this.tourSteps[stepIndex];
                
                // Update progress text
                if (this.progressText) {
                    this.progressText.textContent = `Step ${stepIndex + 1} of ${this.tourSteps.length}`;
                }
                
                // Update tooltip content
                if (this.tooltipTitle && this.tooltipContent) {
                    this.tooltipTitle.textContent = step.title;
                    this.tooltipContent.textContent = step.content;
                }
                
                // Change Next button text on last step
                if (this.nextButton) {
                    this.nextButton.textContent = step.isLast ? 'Finish' : 'Next';
                }
                
                // Run any setup function for this step
                if (step.setupFunction) {
                    step.setupFunction();
                }
                
                // Show the overlay
                if (this.overlay) {
                    this.overlay.classList.add('active');
                }
                
                // Short delay to ensure elements are ready
                setTimeout(() => {
                    this.positionElements();
                    if (this.tooltip) {
                        this.tooltip.classList.add('active');
                    }
                }, 300);
            }
            
            positionElements() {
                console.log('Positioning tour elements');
                const step = this.tourSteps[this.currentStep];
                if (!step) return;
                
                // For modal steps (center of screen)
                if (step.isModal) {
                    console.log('Positioning modal step');
                    // Center the tooltip
                    if (this.tooltip) {
                        this.tooltip.style.top = '50%';
                        this.tooltip.style.left = '50%';
                        this.tooltip.style.transform = 'translate(-50%, -50%)';
                        this.tooltip.className = 'tour-tooltip active';
                    }
                    
                    // No highlight for modals
                    if (this.highlight) {
                        this.highlight.style.display = 'none';
                    }
                    return;
                }
                
                // For regular steps that highlight elements
                if (this.highlight) {
                    this.highlight.style.display = 'block';
                }
                
                const elementToHighlight = document.querySelector(step.element);
                if (!elementToHighlight) {
                    console.error(`Element not found: ${step.element}`);
                    return;
                }
                
                // Get element position and dimensions
                const rect = elementToHighlight.getBoundingClientRect();
                console.log(`Element rect: ${JSON.stringify(rect)}`);
                
                // Add padding to the highlight
                const padding = step.padding || 0;
                
                // Position the highlight
                if (this.highlight) {
                    if (step.spotlight === 'circle') {
                        const diameter = Math.max(rect.width, rect.height) + padding * 2;
                        const radius = diameter / 2;
                        
                        this.highlight.style.width = `${diameter}px`;
                        this.highlight.style.height = `${diameter}px`;
                        this.highlight.style.borderRadius = '50%';
                        this.highlight.style.top = `${rect.top + rect.height/2 - radius}px`;
                        this.highlight.style.left = `${rect.left + rect.width/2 - radius}px`;
                    } else {
                        // Default rectangle highlight
                        this.highlight.style.width = `${rect.width + padding * 2}px`;
                        this.highlight.style.height = `${rect.height + padding * 2}px`;
                        this.highlight.style.borderRadius = '8px';
                        this.highlight.style.top = `${rect.top - padding}px`;
                        this.highlight.style.left = `${rect.left - padding}px`;
                    }
                }
                
                // Position the tooltip
                if (this.tooltip) {
                    const tooltipWidth = this.tooltip.offsetWidth || 300;
                    const tooltipHeight = this.tooltip.offsetHeight || 150;
                    
                    // Remove all position classes
                    this.tooltip.className = 'tour-tooltip active';
                    
                    // Position based on the specified direction
                    switch(step.position) {
                        case 'top':
                            this.tooltip.classList.add('bottom');
                            this.tooltip.style.top = `${rect.top - tooltipHeight - 15}px`;
                            this.tooltip.style.left = `${rect.left + rect.width/2 - tooltipWidth/2}px`;
                            break;
                            
                        case 'bottom':
                            this.tooltip.classList.add('top');
                            this.tooltip.style.top = `${rect.bottom + 15}px`;
                            this.tooltip.style.left = `${rect.left + rect.width/2 - tooltipWidth/2}px`;
                            break;
                            
                        case 'left':
                            this.tooltip.classList.add('right');
                            this.tooltip.style.top = `${rect.top + rect.height/2 - tooltipHeight/2}px`;
                            this.tooltip.style.left = `${rect.left - tooltipWidth - 15}px`;
                            break;
                            
                        case 'right':
                            this.tooltip.classList.add('left');
                            this.tooltip.style.top = `${rect.top + rect.height/2 - tooltipHeight/2}px`;
                            this.tooltip.style.left = `${rect.right + 15}px`;
                            break;
                            
                        default:
                            // Default centered
                            this.tooltip.style.top = '50%';
                            this.tooltip.style.left = '50%';
                            this.tooltip.style.transform = 'translate(-50%, -50%)';
                    }
                    
                    // Ensure tooltip stays within viewport
                    const tooltipRect = this.tooltip.getBoundingClientRect();
                    const viewportWidth = window.innerWidth;
                    const viewportHeight = window.innerHeight;
                    
                    // Adjust horizontal position if needed
                    if (tooltipRect.right > viewportWidth - 10) {
                        this.tooltip.style.left = `${viewportWidth - tooltipWidth - 10}px`;
                    } else if (tooltipRect.left < 10) {
                        this.tooltip.style.left = '10px';
                    }
                    
                    // Adjust vertical position if needed
                    if (tooltipRect.bottom > viewportHeight - 10) {
                        this.tooltip.style.top = `${viewportHeight - tooltipHeight - 10}px`;
                    } else if (tooltipRect.top < 10) {
                        this.tooltip.style.top = '10px';
                    }
                }
            }
        }
        
        // Initialize the tour with a proper delay
        document.addEventListener('DOMContentLoaded', () => {
            console.log('DOM loaded, initializing guided tour after delay');
            // Initialize tour after a longer delay to ensure all app components are fully loaded
            setTimeout(() => {
                console.log('Creating new GuidedTour instance');
                window.guidedTour = new GuidedTour();
                
                // Check if it's first visit to show welcome modal
                setTimeout(() => {
                    if (window.guidedTour && !window.guidedTour.hasSeenTour) {
                        console.log('First visit detected, showing welcome modal');
                        window.guidedTour.showWelcomeModal();
                    } else if (window.guidedTour) {
                        console.log('Returning visitor, showing restart button');
                        window.guidedTour.showRestartButton();
                    }
                }, 1000);
            }, 3000); // Increased delay to 3 seconds
        });
    </script>
    <!-- Tour overlay container -->
    <div id="tourOverlay" class="tour-overlay">
        <!-- Highlight element that will be positioned over targeted elements -->
        <div id="tourHighlight" class="tour-highlight"></div>
        
        <!-- Tooltip that will show explanatory text -->
        <div id="tourTooltip" class="tour-tooltip">
            <div id="tourTooltipTitle" class="tour-tooltip-title"></div>
            <div id="tourTooltipContent" class="tour-tooltip-content"></div>
            <div class="tour-tooltip-nav">
                <div id="tourProgress" class="tour-tooltip-progress">Step 1 of 7</div>
                <div>
                    <button id="tourSkip" class="tour-button skip">Skip Tour</button>
                    <button id="tourNext" class="tour-button">Next</button>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Welcome modal for first-time visitors -->
    <div id="tourWelcomeModal" class="tour-welcome-modal">
        <div class="tour-welcome-content">
            <div class="tour-welcome-icon">
                <i class="fas fa-gem"></i>
            </div>
            <div class="tour-welcome-title">Welcome to Virtual Try-On!</div>
            <p>Experience jewelry like never before with our virtual try-on tool. Would you like a quick tour of the features?</p>
            <div class="tour-welcome-buttons">
                <button id="tourStart" class="tour-button">Start Tour</button>
                <button id="tourDismiss" class="tour-button skip">Skip</button>
            </div>
        </div>
    </div>
    
    <!-- A floating button to restart the tour (hidden by default) -->
    <button id="restartTour" class="tour-restart-button" style="position: fixed; bottom: 250px; right: 20px; z-index: 100; background: var(--color-primary); color: white; border: none; border-radius: 50%; width: 50px; height: 50px; display: flex; align-items: center; justify-content: center; box-shadow: 0 2px 10px rgba(0,0,0,0.2); cursor: pointer; display: none;">
        <i class="fas fa-question"></i>
    </button>

    <div id="modalBlocker" class="fixed inset-0 pointer-events-none" style="z-index: 2999; display: none;"></div>
</body>
</html>
