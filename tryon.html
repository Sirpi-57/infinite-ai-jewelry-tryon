<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Infinite AI - Virtual Try-On Experience</title>
    
    <!-- Load MediaPipe dependencies -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh@0.4.1633559619/face_mesh.js" defer></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1646424915/hands.js" defer></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils@0.3.1620248257/drawing_utils.js" defer></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils@0.3.1620248257/camera_utils.js" defer></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/pose@0.5.1675469404/pose.js" defer></script>
    <script src="https://html2canvas.hertzen.com/dist/html2canvas.min.js"></script>
    
    <!-- Stylesheets -->
    <link href="https://cdnjs.cloudflare.com/ajax/libs/tailwindcss/2.2.19/tailwind.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    
    <!-- Our custom CSS -->
    <style>
        :root {
            --color-primary: #3B82F6;      /* Vibrant blue - represents innovation and technology */
            --color-secondary: #10B981;    /* Emerald green - suggests growth and intelligence */
            --color-accent: #6366F1;       /* Indigo - adds depth and sophistication */
            --color-dark: #1F2937;         /* Deep charcoal - professional and strong */
            --color-light: rgba(59, 130, 246, 0.05); /* Soft blue with low opacity */
            --color-background: #F9FAFB;   /* Very light gray - clean, modern background */
            --color-surface: #FFFFFF;      /* Pure white for surface elements */
            --color-border: rgba(59, 130, 246, 0.2); /* Soft blue border */
            --color-text: #374151;         /* Dark gray for text - slightly softer than pure black */
            
            /* Mobile-specific dimensions */
            --nav-height: 56px;
            --preview-bar-height: 150px;
            --preview-bar-collapsed-height: 10px;
            --capture-btn-offset: 140px; /* New variable for capture button positioning */
            --controls-width: 300px;
            
            /* Transitions */
            --transition-speed: 0.3s;
            --transition-timing: cubic-bezier(0.4, 0, 0.2, 1);
        }
        
        /* Base Styles */
        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background-color: var(--color-background);
            margin: 0;
            padding: 0;
            color: var(--color-text);
            height: 100vh;
            width: 100vw;
            overscroll-behavior: none; /* Prevent pull-to-refresh */
            overflow: hidden;
            position: fixed; /* Prevent body scrolling */
        }
        
        /* Disable long-press menu on mobile */
        * {
            -webkit-touch-callout: none;
            -webkit-tap-highlight-color: transparent;
        }
        
        /* Main Container */
        .app-container {
            position: relative;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        
        /* Loading Screen */
        .loading-screen {
            position: fixed;
            inset: 0;
            background: var(--color-surface);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
            z-index: 1000;
            opacity: 1;
            visibility: visible;
            transition: opacity 0.3s ease-in-out, visibility 0.3s ease-in-out;
        }
        
        .loading-screen.hidden {
            opacity: 0;
            visibility: hidden;
            pointer-events: none;
        }
        
        .loading-error {
            color: #dc2626;
            margin-top: 1rem;
            text-align: center;
            max-width: 80%;
        }
        
        /* Infinity Loader */
        .loading-spinner {
            width: 80px;
            height: 40px;
            position: relative;
            margin-bottom: 2rem;
        }
        
        .loading-spinner svg {
            width: 100%;
            height: 100%;
        }
        
        .infinity-path {
            fill: none;
            stroke: rgba(131, 39, 41, 0.2);
            stroke-width: 4;
            stroke-linecap: round;
        }
        
        .infinity-highlight {
            fill: none;
            stroke: var(--color-primary);
            stroke-width: 4;
            stroke-linecap: round;
            stroke-linejoin: round;
            stroke-dasharray: 50 150;
            stroke-dashoffset: 0;
            animation: moveHighlight 2s linear infinite;
        }
        
        @keyframes moveHighlight {
            from { stroke-dashoffset: 0; }
            to { stroke-dashoffset: -200; }
        }
        
        /* Loading Brand */
        .loading-brand {
            position: absolute;
            bottom: 2rem;
            left: 50%;
            transform: translateX(-50%);
            font-size: 1.2rem;
            opacity: 0.9;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            color: var(--color-primary);
        }
        
        .brand-text {
            font-weight: 700;
            background: linear-gradient(45deg, var(--color-primary), var(--color-secondary));
            background-clip: text;
            -webkit-background-clip: text;
            color: transparent;
            -webkit-text-fill-color: transparent;
            letter-spacing: 0.5px;
        }
        
        /* Top Navigation */
        .top-nav {
            height: var(--nav-height);
            background-color: var(--color-primary);
            color: white;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 1rem;
            position: relative;
            z-index: 10;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        
        .nav-brand {
            font-weight: 600;
            font-size: 1.2rem;
        }
        
        .nav-controls {
            display: flex;
            gap: 1rem;
        }
        
        /* Pill category buttons */
        .category-pills {
            position: absolute;
            top: var(--nav-height);
            left: 0;
            width: 100%;
            padding: 10px 0;
            background: linear-gradient(to bottom, rgba(0,0,0,0.3), transparent);
            z-index: 10;
        }
        
        .pills-scroll {
            display: flex;
            overflow-x: auto;
            padding: 0 10px;
            scrollbar-width: none;
            -ms-overflow-style: none;
        }
        
        .pills-scroll::-webkit-scrollbar {
            display: none;
        }
        
        .pill-btn {
            display: flex;
            align-items: center;
            gap: 5px;
            background: rgba(255, 255, 255, 0.2);
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            border: none;
            color: white;
            padding: 8px 16px;
            border-radius: 50px;
            margin-right: 8px;
            font-size: 0.9rem;
            white-space: nowrap;
            transition: all 0.2s ease;
        }
        
        .pill-btn.active {
            background: var(--color-primary);
            box-shadow: 0 2px 8px rgba(131, 39, 41, 0.4);
        }
        
        .pill-btn i {
            font-size: 1rem;
        }
        
        /* Camera Container */
        .camera-container {
            flex: 1;
            position: relative;
            background: #000;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        
        .camera-feed-wrapper {
            position: relative;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
        }
        
        #cameraFeed {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: contain;
            transform: scaleX(-1); /* Mirror the camera */
        }
        
        #jewelryCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: contain;
            transform: scaleX(-1); /* Mirror to match video */
            pointer-events: none;
            z-index: 5;
        }
        
        /* Camera Error */
        .camera-error {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: var(--color-surface);
            padding: 2rem;
            border-radius: 1rem;
            text-align: center;
            width: 85%;
            max-width: 400px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
            z-index: 5;
        }
        
        .camera-error.hidden {
            display: none;
        }
        
        /* Preview bar (swipeable jewelry selector) */
        .preview-bar {
            position: absolute;
            bottom: 50px;
            left: 0;
            width: 100%;
            height: var(--preview-bar-height);
            background: rgba(0, 0, 0, 0.2);
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            transition: transform 0.3s cubic-bezier(0.2, 0.8, 0.2, 1);
            z-index: 20;
        }
        
        .preview-bar.collapsed {
            transform: translateY(calc(var(--preview-bar-height) - var(--preview-bar-collapsed-height)));
        }
        
        .preview-handle {
            height: var(--preview-bar-collapsed-height);
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: grab;
            touch-action: none;
        }
        
        .handle-indicator {
            width: 40px;
            height: 4px;
            background: rgba(255, 255, 255, 0.5);
            border-radius: 4px;
        }
        
        .carousel-container {
            display: flex;
            overflow-x: auto;
            scroll-snap-type: x mandatory;
            padding: 0 10px;
            scrollbar-width: none;
            -ms-overflow-style: none;
            height: calc(var(--preview-bar-height) - var(--preview-bar-collapsed-height));
        }
        
        .carousel-container::-webkit-scrollbar {
            display: none;
        }
        
        .carousel-item {
            flex: 0 0 80px;
            height: 80px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            margin-right: 10px;
            overflow: hidden;
            scroll-snap-align: start;
            position: relative;
            transition: all 0.2s ease;
        }
        
        .carousel-item.active {
            border: 2px solid var(--color-primary);
            background: rgba(255, 255, 255, 0.3);
        }
        
        .carousel-img {
            width: 100%;
            height: 100%;
            object-fit: contain;
            padding: 5px;
        }
        
        /* Floating controls */
        .floating-controls {
            position: absolute;
            z-index: 25;
            transition: opacity 0.3s ease, transform 0.3s ease;
        }
        
        .floating-controls.hidden {
            opacity: 0;
            pointer-events: none;
            transform: translateY(10px);
        }
        
        .controls-wrapper {
            background: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border-radius: 16px;
            padding: 15px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            max-width: var(--controls-width);
            width: 100%;
        }
        
        .control-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }
        
        .control-title {
            font-size: 1rem;
            font-weight: 600;
            color: var(--color-dark);
            margin: 0;
        }
        
        .close-control-btn {
            background: none;
            border: none;
            color: var(--color-dark);
            font-size: 1rem;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0.7;
        }
        
        .control-group {
            margin-bottom: 20px;
        }
        
        .control-label {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.9rem;
            margin-bottom: 8px;
        }
        
        .control-value {
            font-size: 0.8rem;
            font-weight: 600;
            color: var(--color-primary);
        }
        
        /* Enhanced sliders */
        input[type="range"] {
            -webkit-appearance: none;
            appearance: none;
            width: 100%;
            height: 4px;
            background: rgba(131, 39, 41, 0.2);
            border-radius: 2px;
            outline: none;
            margin: 10px 0;
        }
        
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 18px;
            height: 18px;
            background: var(--color-primary);
            border: 2px solid white;
            border-radius: 50%;
            cursor: pointer;
            transition: transform 0.1s ease, box-shadow 0.1s ease;
            box-shadow: 0 1px 6px rgba(0, 0, 0, 0.1);
        }
        
        input[type="range"]:active::-webkit-slider-thumb {
            transform: scale(1.2);
            box-shadow: 0 1px 10px rgba(131, 39, 41, 0.3);
        }
        
        input[type="range"]::-moz-range-thumb {
            width: 18px;
            height: 18px;
            background: var(--color-primary);
            border: 2px solid white;
            border-radius: 50%;
            cursor: pointer;
            transition: transform 0.1s ease, box-shadow 0.1s ease;
            box-shadow: 0 1px 6px rgba(0, 0, 0, 0.1);
        }
        
        input[type="range"]:active::-moz-range-thumb {
            transform: scale(1.2);
            box-shadow: 0 1px 10px rgba(131, 39, 41, 0.3);
        }
        
        /* Control buttons */
        .control-buttons {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
        }
        
        .control-btn {
            background: rgba(131, 39, 41, 0.1);
            border: none;
            border-radius: 8px;
            height: 36px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--color-primary);
            font-size: 1rem;
            transition: all 0.2s ease;
        }
        
        .control-btn:active {
            background: rgba(131, 39, 41, 0.2);
            transform: scale(0.95);
        }
        
        /* Capture Button */
        .capture-btn {
            position: absolute;
            bottom: calc(var(--preview-bar-height) + 40px);
            right: 20px;
            width: 60px;
            height: 60px;
            background: var(--color-primary);
            color: white;
            border: none;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
            z-index: 15;
            transition: transform 0.2s ease, background-color 0.2s ease;
        }
        
        .capture-btn:active {
            transform: scale(0.95);
            background-color: var(--color-secondary);
        }
        
        /* Toast Notification */
        .toast {
            position: fixed;
            top: calc(var(--nav-height) + 20px);
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 0.75rem 1.5rem;
            border-radius: 20px;
            font-size: 0.9rem;
            z-index: 1000;
            opacity: 0;
            transition: opacity 0.3s ease, transform 0.3s ease;
            pointer-events: none;
        }
        
        .toast.visible {
            opacity: 1;
            transform: translateX(-50%) translateY(0);
        }
        
        /* Remove button */
        .remove-btn {
            background: rgba(220, 38, 38, 0.1);
            color: #dc2626;
            border: none;
            border-radius: 8px;
            padding: 10px;
            font-size: 0.9rem;
            font-weight: 500;
            width: 100%;
            transition: all 0.2s ease;
        }
        
        .remove-btn:active {
            background: rgba(220, 38, 38, 0.2);
            transform: scale(0.98);
        }
        
        /* Empty category message */
        .empty-category {
            width: 100%;
            text-align: center;
            color: rgba(255, 255, 255, 0.7);
            padding: 20px 0;
            font-size: 0.9rem;
        }
        
        /* Auto-hide animation */
        @keyframes fadeOut {
            from { opacity: 1; transform: translateY(0); }
            to { opacity: 0; transform: translateY(10px); pointer-events: none; }
        }
        
        .auto-hide {
            animation: fadeOut 0.5s forwards;
            animation-delay: 3s;
        }
        
        .auto-hide:hover,
        .auto-hide:active {
            animation: none;
            opacity: 1;
            transform: translateY(0);
        }
        
        /* Utility Classes */
        .hidden {
            display: none !important;
        }
        
        .w-full {
            width: 100%;
        }
        
        .primary-button {
            background: var(--color-primary);
            color: white;
            border: none;
            border-radius: 0.5rem;
            padding: 0.75rem 1rem;
            font-weight: 600;
            cursor: pointer;
        }
        
        .primary-button:active {
            transform: scale(0.98);
        }
        
        /* Responsive adjustments */
        @media (min-width: 768px) {
            :root {
                --preview-bar-height: 120px;
            }
            
            .carousel-item {
                flex: 0 0 100px;
                height: 100px;
            }
            
            .capture-btn {
                width: 70px;
                height: 70px;
                font-size: 1.8rem;
                right: 30px;
            }
            
            .controls-wrapper {
                box-shadow: 0 12px 48px rgba(0, 0, 0, 0.15);
            }
        }
        
        @media (min-width: 1024px) {
            .controls-wrapper {
                max-width: 350px;
            }
        }
        
        /* Handle orientation changes */
        @media (orientation: landscape) and (max-height: 500px) {
            :root {
                --preview-bar-height: 80px;
                --nav-height: 40px;
            }
            
            .category-pills {
                right: 0;
                width: auto;
                height: 100%;
                top: var(--nav-height);
                background: linear-gradient(to left, rgba(0,0,0,0.3), transparent);
                padding: 0 10px;
            }
            
            .pills-scroll {
                flex-direction: column;
                padding: 10px 0;
                height: 100%;
            }
            
            .pill-btn {
                margin-right: 0;
                margin-bottom: 8px;
            }
            
            .capture-btn {
                bottom: 20px;
            }
        }
        
        /* Keyframes for subtle animations */
        @keyframes pulseEffect {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }
        
        .carousel-item.active:after {
            content: '';
            position: absolute;
            inset: 0;
            border-radius: 12px;
            box-shadow: 0 0 0 2px var(--color-primary);
            animation: pulseEffect 2s infinite;
        }
        
        /* Camera feed wrapper optimization */
        @media (orientation: portrait) {
            .camera-feed-wrapper {
                width: 100%;
                height: auto;
                aspect-ratio: 3/4; /* Common front camera aspect ratio */
            }
        }
        
        @media (orientation: landscape) {
            .camera-feed-wrapper {
                width: auto;
                height: 100%;
                aspect-ratio: 4/3; /* Common front camera aspect ratio */
            }
        }

        .action-buttons {
            margin-top: 20px;
        }
        
        .secondary-button {
            background: rgba(255, 255, 255, 0.8);
            color: var(--color-dark);
            border: 1px solid var(--color-border);
            border-radius: 8px;
            padding: 8px 12px;
            font-size: 0.9rem;
            font-weight: 500;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 5px;
            transition: all 0.2s ease;
        }
        
        .secondary-button:active {
            background: rgba(255, 255, 255, 0.6);
            transform: scale(0.98);
        }
        
        .remove-btn {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 5px;
        }
    </style>
</head>
<body>
    <!-- Loading Screen -->
    <div class="loading-screen" id="loadingScreen">
        <div class="loading-spinner">
            <svg viewBox="0 0 100 50" xmlns="http://www.w3.org/2000/svg">
                <path class="infinity-path" 
                      d="M10,25 C10,5 40,5 50,25 C60,45 90,45 90,25 C90,5 60,5 50,25 C40,45 10,45 10,25 Z" 
                      fill="none" stroke="black" stroke-width="2"/>
                <path class="infinity-highlight" 
                      d="M10,25 C10,5 40,5 50,25 C60,45 90,45 90,25 C90,5 60,5 50,25 C40,45 10,45 10,25 Z" 
                      fill="none" stroke="gray" stroke-width="2"/>
            </svg>
        </div>
        <p class="text-gray-600">Initializing Virtual Try-On Experience...</p>
        <p class="loading-error hidden"></p>
        
        <div class="loading-brand">
            <i class="fas fa-infinity"></i>
            <span class="brand-text">Powered by Infinite AI</span>
        </div>
    </div>

    <!-- Main App Container -->
    <div class="app-container">
        <!-- Top Navigation Bar -->
        <nav class="top-nav">
            <div class="nav-brand">
                <span>Virtual Try-On</span>
            </div>
            <div class="nav-controls">
                <button id="menuButton" class="text-white text-xl p-2">
                    <i class="fas fa-sliders-h"></i>
                </button>
            </div>
        </nav>

        <!-- Category Pills -->
        <div class="category-pills">
            <div class="pills-scroll">
                <button class="pill-btn active" data-category="face">
                    <i class="fas fa-mask"></i>
                    <span>Face</span>
                </button>
                <button class="pill-btn" data-category="ear">
                    <i class="fas fa-gem"></i>
                    <span>Ear</span>
                </button>
                <button class="pill-btn" data-category="neck">
                    <i class="fas fa-gem"></i>
                    <span>Neck</span>
                </button>
                <button class="pill-btn" data-category="hand">
                    <i class="fas fa-ring"></i>
                    <span>Hand</span>
                </button>
                <button class="pill-btn" data-category="active">
                    <i class="fas fa-th-list"></i>
                    <span>Active</span>
                </button>
            </div>
        </div>

        <!-- Camera Container -->
        <div class="camera-container">
            <div class="camera-feed-wrapper">
                <video id="cameraFeed" autoplay playsinline></video>
                <canvas id="jewelryCanvas"></canvas>
            </div>
            
            <!-- Camera Error Message -->
            <div class="camera-error hidden" id="cameraError">
                <i class="fas fa-video-slash text-3xl text-red-500 mb-4"></i>
                <h3 class="text-xl font-bold text-gray-800 mb-2">Camera Access Required</h3>
                <p class="text-gray-600 mb-4">Please allow camera access to use the virtual try-on experience.</p>
                <button onclick="requestCameraAccess()" class="primary-button">
                    Enable Camera
                </button>
            </div>
        </div>

        <!-- Preview Bar (swipeable jewelry selector) -->
        <div class="preview-bar" id="previewBar">
            <div class="preview-handle" id="previewHandle">
                <div class="handle-indicator"></div>
            </div>
            <div class="carousel-container" id="jewelryCarousel">
                <!-- Jewelry items will be inserted here dynamically -->
            </div>
        </div>

        <!-- Floating Controls -->
        <div class="floating-controls hidden" id="floatingControls">
            <div class="controls-wrapper">
                <div class="control-header">
                    <h4 class="control-title" id="controlTitle">Adjust Jewelry</h4>
                    <button class="close-control-btn" id="closeControlBtn">
                        <i class="fas fa-times"></i>
                    </button>
                </div>
                <div id="controlContent">
                    <!-- Controls will be populated dynamically -->
                </div>
            </div>
        </div>

        <!-- Capture Button -->
        <button class="capture-btn" id="captureBtn">
            <i class="fas fa-camera"></i>
        </button>

        <!-- Toast Notification -->
        <div class="toast" id="toast"></div>
    </div>
    
    <script>
        const JEWELRY = {
            // Face jewelry (tikka)
            tikka1: {
                name: "Tikka Design 1",
                type: 'single',
                image: 'tikka1.png',
                thumbnail: 'thumbnails/tikka1-thumb.png',
                landmark: 151,
                offset: { x: 0, y: 0 },
                defaultScale: 1.3,
                group: 'face',
                category: 'Face Jewelry'
            },
            tikka2: {
                name: "Tikka Design 2",
                type: 'single',
                image: 'tikka2.png',
                thumbnail: 'thumbnails/tikka2-thumb.png',
                landmark: 151,
                offset: { x: 0, y: 0 },
                defaultScale: 1,
                group: 'face',
                category: 'Face Jewelry'
            },
            tikka3: {
                name: "Tikka Design 3",
                type: 'single',
                image: 'tikka3.png',
                thumbnail: 'thumbnails/tikka3-thumb.png',
                landmark: 151,
                offset: { x: 0, y: 0 },
                defaultScale: 1,
                group: 'face',
                category: 'Face Jewelry'
            },
            tikka4: {
                name: "Tikka Design 4",
                type: 'single',
                image: 'tikka4.png',
                thumbnail: 'thumbnails/tikka4-thumb.png',
                landmark: 151,
                offset: { x: 0, y: 0 },
                defaultScale: 0.8,
                group: 'face',
                category: 'Face Jewelry'
            },
            
            // Ear jewelry (jhumka/earrings)
            jhumka1: {
                name: "Earring Design 1",
                type: 'earrings',
                left: 'earing1left.png',
                right: 'earing1right.png',
                thumbnail: 'thumbnails/earring1-thumb.png',
                landmarks: [177, 401],
                offset: { x: -5, y: 0 },
                defaultScale: 0.75,
                gap: 0,
                group: 'ear',
                category: 'Ear Jewelry'
            },
            jhumka2: {
                name: "Earring Design 2",
                type: 'earrings',
                left: 'earing2left.png',
                right: 'earing2right.png',
                thumbnail: 'thumbnails/earring2-thumb.png',
                landmarks: [177, 401],
                offset: { x: -5, y: 0 },
                defaultScale: 1.5,
                gap: 0,
                group: 'ear',
                category: 'Ear Jewelry'
            },
            jhumka3: {
                name: "Earring Design 3",
                type: 'earrings',
                left: 'earing3left.png',
                right: 'earing3right.png',
                thumbnail: 'thumbnails/earring3-thumb.png',
                landmarks: [177, 401],
                offset: { x: -5, y: 0 },
                defaultScale: 1.5,
                gap: 0,
                group: 'ear',
                category: 'Ear Jewelry'
            },
            jhumka4: {
                name: "Earring Design 4",
                type: 'earrings',
                left: 'earing4left.png',
                right: 'earing4right.png',
                thumbnail: 'thumbnails/earring4-thumb.png',
                landmarks: [177, 401],
                offset: { x: -5, y: 0 },
                defaultScale: 1.5,
                gap: 0,
                group: 'ear',
                category: 'Ear Jewelry'
            },
            
            // Neck jewelry (necklaces)
            necklace1: {
                name: "Necklace Design 1",
                type: 'necklace',
                image: 'necklace1.png',
                thumbnail: 'thumbnails/necklace1-thumb.png',
                offset: { x: 0, y: 0 },
                defaultScale: 0.55,
                group: 'neck',
                category: 'Neck Jewelry'
            },
            necklace2: {
                name: "Necklace Design 2",
                type: 'necklace',
                image: 'necklace2.png',
                thumbnail: 'thumbnails/necklace2-thumb.png',
                offset: { x: 0, y: 0 },
                defaultScale: 0.55,
                group: 'neck',
                category: 'Neck Jewelry'
            },
            necklace3: {
                name: "Necklace Design 3",
                type: 'necklace',
                image: 'necklace3.png',
                thumbnail: 'thumbnails/necklace3-thumb.png',
                offset: { x: 0, y: 0 },
                defaultScale: 0.55,
                group: 'neck',
                category: 'Neck Jewelry'
            },
            necklace4: {
                name: "Necklace Design 4",
                type: 'necklace',
                image: 'necklace4.png',
                thumbnail: 'thumbnails/necklace4-thumb.png',
                offset: { x: 0, y: 0 },
                defaultScale: 0.4,
                group: 'neck',
                category: 'Neck Jewelry'
            },
            necklace5: {
                name: "Necklace Design 5",
                type: 'necklace',
                image: 'necklace5.png',
                thumbnail: 'thumbnails/necklace5-thumb.png',
                offset: { x: 0, y: 0 },
                defaultScale: 0.4,
                group: 'neck',
                category: 'Neck Jewelry'
            },
            necklace6: {
                name: "Necklace Design 6",
                type: 'necklace',
                image: 'necklace6.png',
                thumbnail: 'thumbnails/necklace6-thumb.png',
                offset: { x: 0, y: 0 },
                defaultScale: 0.4,
                group: 'neck',
                category: 'Neck Jewelry'
            },
            necklace7: {
                name: "Necklace Design 7",
                type: 'necklace',
                image: 'necklace7.png',
                thumbnail: 'thumbnails/necklace7-thumb.png',
                offset: { x: 0, y: 0 },
                defaultScale: 0.4,
                group: 'neck',
                category: 'Neck Jewelry'
            },
            
            // Hand jewelry (rings, bangles)
            ring1: {
                name: "Ring Design",
                type: 'hand',
                image: 'ring1.png',
                thumbnail: 'thumbnails/ring1-thumb.png',
                landmark: 'custom',
                fingerIndex: 8,
                handIndex: 0,
                offset: { x: 0, y: 0 },
                defaultScale: 0.2,
                group: 'hand',
                category: 'Hand Jewelry'
            },
            bangle1: {
                name: "Bangle Design 1",
                type: 'hand',
                image: 'bangle1.png',
                thumbnail: 'thumbnails/bangle1-thumb.png',
                landmark: 'custom',
                wristIndex: 0,
                handIndex: 0,
                offset: { x: 0, y: 0 },
                defaultScale: 0.35,
                group: 'hand',
                category: 'Hand Jewelry'
            },
            bangle2: {
                name: "Bangle Design 2",
                type: 'hand',
                image: 'bangle2.png',
                thumbnail: 'thumbnails/bangle2-thumb.png',
                landmark: 'custom',
                wristIndex: 0,
                handIndex: 0,
                offset: { x: 0, y: 0 },
                defaultScale: 0.35,
                group: 'hand',
                category: 'Hand Jewelry'
            },
            bangle3: {
                name: "Bangle Design 3",
                type: 'hand',
                image: 'bangle3.png',
                thumbnail: 'thumbnails/bangle3-thumb.png',
                landmark: 'custom',
                wristIndex: 0,
                handIndex: 0,
                offset: { x: 0, y: 0 },
                defaultScale: 0.35,
                group: 'hand',
                category: 'Hand Jewelry'
            }
        };

        const LANDMARKS = {
            tikka: {
                center: 151,
                top: 10,
                reference: 9
            },
            earrings: {
                leftLobe: 58,
                rightLobe: 288,
                leftRef: 234,
                rightRef: 454
            }
        };

        // App State
        let appState = {
            activeJewelry: new Map(),
            currentCategory: 'face',  // Change default to face
            selectedJewelryId: null,
            mirrorCamera: true,       // New property for camera mirroring
            performanceMode: 'medium', // New property for performance mode
            faceLandmarks: null,
            handLandmarks: null,
            poseLandmarks: null,
            isCameraReady: false,
            isResourcesLoaded: false,
            isInitialized: false
        };
        
        // DOM Elements
        let elements = {
            video: null,
            canvas: null,
            ctx: null,
            loadingScreen: null,
            bottomPanel: null,
            controlsPanel: null,
            captureBtn: null,
            tabButtons: null,
            itemGrid: null,
            controlsContent: null,
            productCard: null,
            toast: null
        };
        
        // MediaPipe Models
        let faceMesh, hands, pose;
        
        // Initialization
        document.addEventListener('DOMContentLoaded', init);
        
        async function init() {
            try {
                console.log("Starting initialization...");
                updateLoadingStatus("Initializing...");
                
                // Get DOM elements
                initializeElements();
                
                // Setup event listeners
                setupEventListeners();
                
                // Initialize camera
                await initializeCamera();
                
                // Initialize MediaPipe models
                await initializeAIModels();
                
                // Preload jewelry images
                await preloadJewelryImages();
                
                // Initialize UI
                initializeUI();
                
                // Initialize gesture support
                setupGestureHandlers();
                
                // Start detection loop
                appState.isInitialized = true;
                requestAnimationFrame(detectAll);
                
                // Hide loading screen
                hideLoadingScreen();
                
                console.log("Initialization complete!");
            } catch (error) {
                console.error("Initialization error:", error);
                showError(error.message || "Error initializing app. Please refresh the page.");
            }
        }
        
        function initializeElements() {
            elements.video = document.getElementById('cameraFeed');
            elements.canvas = document.getElementById('jewelryCanvas');
            elements.ctx = elements.canvas.getContext('2d');
            elements.loadingScreen = document.getElementById('loadingScreen');
            
            // Replace bottom panel with preview bar
            elements.previewBar = document.getElementById('previewBar');
            elements.previewHandle = document.getElementById('previewHandle');
            elements.jewelryCarousel = document.getElementById('jewelryCarousel');
            
            // Replace controls panel with floating controls
            elements.floatingControls = document.getElementById('floatingControls');
            elements.controlTitle = document.getElementById('controlTitle');
            elements.controlContent = document.getElementById('controlContent');
            elements.closeControlBtn = document.getElementById('closeControlBtn');
            
            // Replace tab buttons with pill buttons
            elements.categoryPills = document.querySelectorAll('.pill-btn');
            
            elements.captureBtn = document.getElementById('captureBtn');
            elements.menuButton = document.getElementById('menuButton');
            
            // Create toast if it doesn't exist
            elements.toast = document.getElementById('toast') || document.createElement('div');
            if (!elements.toast.id) {
                elements.toast.className = 'toast';
                elements.toast.id = 'toast';
                document.body.appendChild(elements.toast);
            }
            
            if (!elements.video || !elements.canvas || !elements.ctx) {
                throw new Error("Required elements not found");
            }
        }

        function setupEventListeners() {
            // Category pill buttons
            elements.categoryPills.forEach(btn => {
                btn.addEventListener('click', () => {
                    const category = btn.dataset.category;
                    switchCategory(category);
                });
            });
            
            // Preview bar handle for collapsing
            elements.previewHandle.addEventListener('click', togglePreviewBar);
            
            // Touch gestures for preview bar
            let startY = 0;
            elements.previewHandle.addEventListener('touchstart', (e) => {
                startY = e.touches[0].clientY;
            });
            
            elements.previewHandle.addEventListener('touchmove', (e) => {
                const deltaY = e.touches[0].clientY - startY;
                // If swiping up, expand preview bar
                if (deltaY < -10) {
                    elements.previewBar.classList.remove('collapsed');
                }
                // If swiping down, collapse preview bar
                else if (deltaY > 10) {
                    elements.previewBar.classList.add('collapsed');
                }
                e.preventDefault();
            });
            
            // Capture button
            elements.captureBtn.addEventListener('click', captureScreenshot);
            
            // Menu button
            elements.menuButton.addEventListener('click', showAppSettings);
            
            // Close controls button
            elements.closeControlBtn.addEventListener('click', hideFloatingControls);
            
            // Add canvas click to hide controls if clicked outside
            elements.canvas.addEventListener('click', (e) => {
                // Check if click was outside floating controls
                const controlsRect = elements.floatingControls.getBoundingClientRect();
                if (e.clientX < controlsRect.left || e.clientX > controlsRect.right ||
                    e.clientY < controlsRect.top || e.clientY > controlsRect.bottom) {
                    hideFloatingControls();
                }
            });
            
            // Initialize pinch-to-zoom and drag gestures
            setupGestureHandlers();
        }

        function togglePreviewBar() {
            elements.previewBar.classList.toggle('collapsed');
            // Adjust capture button position based on preview bar state
            const bottomOffset = elements.previewBar.classList.contains('collapsed') 
                ? 'var(--preview-bar-collapsed-height)' 
                : 'var(--preview-bar-height)';
            elements.captureBtn.style.bottom = `calc(${bottomOffset} + 20px)`;
        }
        
        async function initializeCamera() {
            try {
                updateLoadingStatus("Accessing camera...");
                
                const constraints = {
                    video: {
                        facingMode: 'user',
                        width: { ideal: 1280 },
                        height: { ideal: 720 }
                    }
                };
                
                const stream = await navigator.mediaDevices.getUserMedia(constraints);
                elements.video.srcObject = stream;
                
                await new Promise((resolve) => {
                    elements.video.onloadedmetadata = () => {
                        elements.canvas.width = elements.video.videoWidth;
                        elements.canvas.height = elements.video.videoHeight;
                        console.log("Video dimensions:", elements.video.videoWidth, elements.video.videoHeight);
                        appState.isCameraReady = true;
                        resolve();
                    };
                });
                
                await elements.video.play();
                console.log("Camera initialized successfully");
                
                document.getElementById('cameraError').classList.add('hidden');
            } catch (error) {
                console.error("Camera access error:", error);
                document.getElementById('cameraError').classList.remove('hidden');
                throw new Error("Camera access denied. Please enable camera permissions.");
            }
        }
        
        async function initializeAIModels() {
            try {
                updateLoadingStatus("Loading AI models...");
                
                // Initialize FaceMesh
                faceMesh = new FaceMesh({
                    locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh@0.4.1633559619/${file}`
                });
                
                // Initialize Hands
                hands = new Hands({
                    locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1646424915/${file}`
                });
                
                // Initialize Pose
                pose = new Pose({
                    locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/pose@0.5.1675469404/${file}`
                });
                
                // Configure models
                faceMesh.setOptions({
                    maxNumFaces: 1,
                    refineLandmarks: true,
                    minDetectionConfidence: 0.5,
                    minTrackingConfidence: 0.5
                });
                
                hands.setOptions({
                    maxNumHands: 2,
                    modelComplexity: 0,
                    minDetectionConfidence: 0.5,
                    minTrackingConfidence: 0.5
                });
                
                pose.setOptions({
                    modelComplexity: 0,
                    smoothLandmarks: true,
                    minDetectionConfidence: 0.5,
                    minTrackingConfidence: 0.5
                });
                
                // Set up callbacks
                faceMesh.onResults(onFaceMeshResults);
                hands.onResults(onHandResults);
                pose.onResults(onPoseResults);
                
                // Initialize models
                updateLoadingStatus("Loading face detection...");
                await faceMesh.initialize();
                
                updateLoadingStatus("Loading hand detection...");
                await hands.initialize();
                
                updateLoadingStatus("Loading pose detection...");
                await pose.initialize();
                
                console.log("AI models initialized successfully");
                return true;
            } catch (error) {
                console.error("Model initialization error:", error);
                throw new Error("Failed to initialize AI models. Please try refreshing the page.");
            }
        }
        
        async function preloadJewelryImages() {
            updateLoadingStatus("Loading jewelry assets...");
            const preloadPromises = [];
            
            for (const [id, jewelry] of Object.entries(JEWELRY)) {
                try {
                    if (jewelry.type === 'earrings') {
                        const leftImg = new Image();
                        const rightImg = new Image();
                        
                        leftImg.src = jewelry.left;
                        rightImg.src = jewelry.right;
                        
                        const leftPromise = new Promise((resolve, reject) => {
                            leftImg.onload = resolve;
                            leftImg.onerror = () => reject(new Error(`Failed to load ${jewelry.left}`));
                        });
                        
                        const rightPromise = new Promise((resolve, reject) => {
                            rightImg.onload = resolve;
                            rightImg.onerror = () => reject(new Error(`Failed to load ${jewelry.right}`));
                        });
                        
                        preloadPromises.push(Promise.all([leftPromise, rightPromise])
                            .then(() => {
                                jewelry.leftImage = leftImg;
                                jewelry.rightImage = rightImg;
                            }));
                    } else {
                        const img = new Image();
                        img.src = jewelry.image;
                        
                        const imgPromise = new Promise((resolve, reject) => {
                            img.onload = resolve;
                            img.onerror = () => reject(new Error(`Failed to load ${jewelry.image}`));
                        });
                        
                        preloadPromises.push(imgPromise.then(() => {
                            jewelry.loadedImage = img;
                        }));
                    }
                    
                    // Preload thumbnail if available
                    if (jewelry.thumbnail) {
                        const thumbImg = new Image();
                        thumbImg.src = jewelry.thumbnail;
                        
                        const thumbPromise = new Promise((resolve) => {
                            thumbImg.onload = resolve;
                            thumbImg.onerror = resolve; // Continue even if thumbnail fails
                        });
                        
                        preloadPromises.push(thumbPromise.then(() => {
                            jewelry.thumbnailImage = thumbImg;
                        }));
                    }
                } catch (error) {
                    console.warn(`Error setting up preload for ${id}:`, error);
                }
            }
            
            // Wait for all preload promises
            try {
                await Promise.all(preloadPromises);
                console.log("All jewelry images preloaded successfully");
            } catch (error) {
                console.warn("Some images failed to preload:", error);
            }
            
            appState.isResourcesLoaded = true;
        }
        
        function initializeUI() {
            // Show first category
            switchCategory('face');
            
            // Set up controls activity monitoring
            elements.floatingControls.addEventListener('mousemove', resetControlsTimer);
            elements.floatingControls.addEventListener('touchstart', resetControlsTimer);
            elements.floatingControls.addEventListener('click', resetControlsTimer);
            
            // Ensure camera is mirrored initially
            elements.video.style.transform = 'scaleX(-1)';
            elements.canvas.style.transform = 'scaleX(-1)';
        }
        
        function switchCategory(category) {
            // Update active pill
            elements.categoryPills.forEach(btn => {
                if (btn.dataset.category === category) {
                    btn.classList.add('active');
                } else {
                    btn.classList.remove('active');
                }
            });
            
            appState.currentCategory = category;
            
            // Hide floating controls when switching categories
            hideFloatingControls();
            
            // Make sure preview bar is expanded
            elements.previewBar.classList.remove('collapsed');
            
            // Render appropriate items
            if (category === 'active') {
                renderActiveItems();
            } else {
                renderCategoryItems(category);
            }
        }
        
        function renderCategoryItems(category) {
            const carousel = elements.jewelryCarousel;
            carousel.innerHTML = '';
            
            // Filter items by category
            const categoryItems = Object.entries(JEWELRY)
                .filter(([_, item]) => item.group === category);
            
            if (categoryItems.length === 0) {
                carousel.innerHTML = '<div class="empty-category">No items available</div>';
                return;
            }
            
            // Create carousel items
            categoryItems.forEach(([id, item]) => {
                const isActive = appState.activeJewelry.has(id);
                
                const card = document.createElement('div');
                card.className = `carousel-item ${isActive ? 'active' : ''}`;
                card.dataset.jewelryId = id;
                
                // Use thumbnail if available, otherwise use main image
                const imageSrc = item.thumbnail || 
                    (item.type === 'earrings' ? item.left : item.image);
                
                card.innerHTML = `<img src="${imageSrc}" alt="${item.name}" class="carousel-img">`;
                
                card.addEventListener('click', () => handleItemClick(id));
                carousel.appendChild(card);
            });
        }
        
        function renderActiveItems() {
            const carousel = elements.jewelryCarousel;
            carousel.innerHTML = '';
            
            if (appState.activeJewelry.size === 0) {
                carousel.innerHTML = '<div class="empty-category">No active jewelry</div>';
                return;
            }
            
            // Create carousel items for active jewelry
            appState.activeJewelry.forEach((item, id) => {
                const originalItem = JEWELRY[id];
                if (!originalItem) return;
                
                const card = document.createElement('div');
                card.className = 'carousel-item active';
                card.dataset.jewelryId = id;
                
                // Use thumbnail if available
                const imageSrc = originalItem.thumbnail || 
                    (originalItem.type === 'earrings' ? originalItem.left : originalItem.image);
                
                card.innerHTML = `<img src="${imageSrc}" alt="${originalItem.name}" class="carousel-img">`;
                
                card.addEventListener('click', () => {
                    // Show floating controls for this jewelry
                    renderFloatingControls(id);
                    showFloatingControls(id);
                });
                
                carousel.appendChild(card);
            });
        }
        
        function handleItemClick(id) {
            const item = JEWELRY[id];
            
            // If item is already active, remove it instead of showing controls
            if (appState.activeJewelry.has(id)) {
                removeJewelry(id);
                showToast(`${item.name} removed`);
                return;
            }
            
            // Add new jewelry item
            addJewelry(id);
            
            // Show toast notification
            showToast(`Added: ${item.name}`);
            
            // Update carousel UI
            const carouselItems = elements.jewelryCarousel.querySelectorAll('.carousel-item');
            carouselItems.forEach(card => {
                if (card.dataset.jewelryId === id) {
                    card.classList.add('active');
                }
            });
        }
        
        // Product Details Function
        function showProductDetails(id) {
            const item = JEWELRY[id];
            if (!item) return;
            
            // Just show a toast notification instead of a product card
            showToast(`Added: ${item.name}`);
            
            // Mark item as active in carousel
            const carouselItems = elements.jewelryCarousel.querySelectorAll('.carousel-item');
            carouselItems.forEach(card => {
                if (card.dataset.jewelryId === id) {
                    card.classList.add('active');
                }
            });
        }
        
        // 2. Controls Panel Toggle - Replaced with Floating Controls
        function toggleControlsPanel(show, jewelryId = null) {
            if (show && jewelryId) {
                renderFloatingControls(jewelryId);
                showFloatingControls(jewelryId);
            } else {
                hideFloatingControls();
            }
        }
        
        function renderFloatingControls(id) {
            if (!id || !appState.activeJewelry.has(id)) return;
            
            const jewelry = appState.activeJewelry.get(id);
            const originalJewelry = JEWELRY[id];
            
            // Update control title
            elements.controlTitle.textContent = originalJewelry.name;
            
            // Clear previous controls
            elements.controlContent.innerHTML = '';
            
            // Size control
            const sizeHTML = `
                <div class="control-group">
                    <div class="control-label">
                        <span>Size</span>
                        <span class="control-value" id="sizeValue">${Math.round(jewelry.scale * 100)}%</span>
                    </div>
                    <input type="range" min="0.5" max="2.0" step="0.05" value="${jewelry.scale}" 
                        oninput="updateJewelrySize('${id}', this.value)">
                </div>
            `;
            
            // Position control buttons
            const positionHTML = `
                <div class="control-group">
                    <div class="control-label">
                        <span>Position</span>
                    </div>
                    <div class="control-buttons">
                        <button class="control-btn" onclick="moveJewelry('${id}', 'up-left')">↖</button>
                        <button class="control-btn" onclick="moveJewelry('${id}', 'up')">↑</button>
                        <button class="control-btn" onclick="moveJewelry('${id}', 'up-right')">↗</button>
                        <button class="control-btn" onclick="moveJewelry('${id}', 'left')">←</button>
                        <button class="control-btn" onclick="moveJewelry('${id}', 'center')">•</button>
                        <button class="control-btn" onclick="moveJewelry('${id}', 'right')">→</button>
                        <button class="control-btn" onclick="moveJewelry('${id}', 'down-left')">↙</button>
                        <button class="control-btn" onclick="moveJewelry('${id}', 'down')">↓</button>
                        <button class="control-btn" onclick="moveJewelry('${id}', 'down-right')">↘</button>
                    </div>
                </div>
            `;
            
            // Opacity control
            const opacityHTML = `
                <div class="control-group">
                    <div class="control-label">
                        <span>Opacity</span>
                        <span class="control-value" id="opacityValue">${Math.round((jewelry.opacity || 1.0) * 100)}%</span>
                    </div>
                    <input type="range" min="0.2" max="1.0" step="0.05" value="${jewelry.opacity || 1.0}" 
                        oninput="updateJewelryOpacity('${id}', this.value)">
                </div>
            `;
            
            // Action buttons - combined Close and Remove into one row
            const actionButtonsHTML = `
                <div class="control-group">
                    <div class="flex gap-2">
                        <button class="secondary-button w-full" onclick="hideFloatingControls()">
                            <i class="fas fa-times"></i> Close
                        </button>
                        <button class="remove-btn w-full" onclick="removeJewelry('${id}')">
                            <i class="fas fa-trash"></i> Remove
                        </button>
                    </div>
                </div>
            `;
            
            // Combine all controls
            elements.controlContent.innerHTML = sizeHTML + positionHTML + opacityHTML + actionButtonsHTML;
        }

        function showFloatingControls(id) {
            // Calculate position near the jewelry
            const position = getJewelryPosition(id);
            
            // Position controls at calculated position, ensuring they stay in viewport
            elements.floatingControls.style.top = `${position.y}px`;
            elements.floatingControls.style.left = `${position.x}px`;
            
            // Make controls visible
            elements.floatingControls.classList.remove('hidden');
            
            // Add auto-hide functionality
            elements.floatingControls.classList.add('auto-hide');
            
            // Reset auto-hide on interaction
            elements.floatingControls.addEventListener('click', function clearAutoHide() {
                elements.floatingControls.classList.remove('auto-hide');
                elements.floatingControls.removeEventListener('click', clearAutoHide);
            }, { once: true });
            
            // Start activity monitoring
            resetControlsTimer();
        }
        
        function hideFloatingControls() {
            elements.floatingControls.classList.add('hidden');
            clearTimeout(controlsActivityTimer);
        }
        
        // Auto-hide controls after period of inactivity
        let controlsActivityTimer;
        
        function resetControlsTimer() {
            clearTimeout(controlsActivityTimer);
            
            if (!elements.floatingControls.classList.contains('hidden')) {
                controlsActivityTimer = setTimeout(() => {
                    hideFloatingControls();
                }, 5000); // Hide after 5 seconds of inactivity
            }
        }
        
        // Calculate position for floating controls near jewelry
        function getJewelryPosition(jewelryId) {
            const jewelry = appState.activeJewelry.get(jewelryId);
            if (!jewelry) return { x: 20, y: 100 };
            
            let x = 20, y = 100; // Default fallback position
            
            if (jewelry.type === 'earrings' && appState.faceLandmarks) {
                const leftEar = appState.faceLandmarks[234];
                const rightEar = appState.faceLandmarks[454];
                
                if (leftEar && rightEar) {
                    // Position near the ears but to the side
                    x = ((leftEar.x + rightEar.x) / 2) * elements.canvas.width - 150;
                    y = ((leftEar.y + rightEar.y) / 2) * elements.canvas.height - 50;
                }
            } else if (jewelry.type === 'necklace' && appState.poseLandmarks) {
                const leftShoulder = appState.poseLandmarks[11];
                const rightShoulder = appState.poseLandmarks[12];
                
                if (leftShoulder && rightShoulder) {
                    // Position to the side of the neck
                    x = ((leftShoulder.x + rightShoulder.x) / 2) * elements.canvas.width + 100;
                    y = ((leftShoulder.y + rightShoulder.y) / 2) * elements.canvas.height - 120;
                }
            } else if (jewelry.type === 'single' && appState.faceLandmarks) {
                const forehead = appState.faceLandmarks[151];
                
                if (forehead) {
                    // Position near the forehead but to the side
                    x = forehead.x * elements.canvas.width + 120;
                    y = forehead.y * elements.canvas.height - 100;
                }
            } else if (jewelry.type === 'hand' && appState.handLandmarks && appState.handLandmarks.length > 0) {
                const handIndex = jewelry.handIndex || 0;
                const handLandmarks = appState.handLandmarks[handIndex];
                
                if (handLandmarks) {
                    // Position near the wrist
                    const wrist = handLandmarks[0];
                    x = wrist.x * elements.canvas.width - 150;
                    y = wrist.y * elements.canvas.height - 80;
                }
            }
            
            // Ensure controls stay within viewport bounds
            const controlsWidth = 300; // Approximate width of controls
            const controlsHeight = 350; // Approximate height of controls
            
            x = Math.max(10, Math.min(x, window.innerWidth - controlsWidth - 10));
            y = Math.max(80, Math.min(y, window.innerHeight - controlsHeight - 10));
            
            return { x, y };
        }
        
        // 3. Global Settings
        function renderGlobalSettings() {
            showAppSettings();
        }


       function showAppSettings() {
            // Clear control content
            elements.controlTitle.textContent = "App Settings";
            elements.controlContent.innerHTML = '';
            
            // Create settings HTML
            const settingsHTML = `
                <div class="control-group">
                    <div class="control-label">
                        <span>Camera Mirror</span>
                    </div>
                    <label class="toggle-switch">
                        <input type="checkbox" id="mirrorToggle" ${appState.mirrorCamera ? 'checked' : ''}>
                        <span class="toggle-slider"></span>
                    </label>
                    <p class="text-sm text-gray-500 mt-1">Mirror camera horizontally</p>
                </div>
                
                <div class="control-group">
                    <div class="control-label">
                        <span>Performance Mode</span>
                    </div>
                    <div class="flex gap-2 mt-2">
                        <button class="control-btn ${appState.performanceMode === 'low' ? 'bg-primary text-white' : ''}" 
                            onclick="setPerformanceMode('low')">Low</button>
                        <button class="control-btn ${appState.performanceMode === 'medium' ? 'bg-primary text-white' : ''}" 
                            onclick="setPerformanceMode('medium')">Medium</button>
                        <button class="control-btn ${appState.performanceMode === 'high' ? 'bg-primary text-white' : ''}" 
                            onclick="setPerformanceMode('high')">High</button>
                    </div>
                    <p class="text-sm text-gray-500 mt-1">Higher performance uses more battery</p>
                </div>
                
                <div class="control-group">
                    <button class="primary-button w-full" onclick="hideFloatingControls()">
                        Close Settings
                    </button>
                </div>
            `;
            
            elements.controlContent.innerHTML = settingsHTML;
            
            // Position controls in center of screen
            elements.floatingControls.style.top = '50%';
            elements.floatingControls.style.left = '50%';
            elements.floatingControls.style.transform = 'translate(-50%, -50%)';
            
            // Show controls
            elements.floatingControls.classList.remove('hidden');
            elements.floatingControls.classList.remove('auto-hide');
            
            // Add event listener for mirror toggle
            document.getElementById('mirrorToggle').addEventListener('change', (e) => {
                appState.mirrorCamera = e.target.checked;
                elements.video.style.transform = appState.mirrorCamera ? 'scaleX(-1)' : 'none';
                elements.canvas.style.transform = appState.mirrorCamera ? 'scaleX(-1)' : 'none';
            });
        } 
        
        /// Update jewelry size with visual feedback
        function updateJewelrySize(id, value) {
            if (!appState.activeJewelry.has(id)) return;
            
            const scale = parseFloat(value);
            const jewelry = appState.activeJewelry.get(id);
            jewelry.scale = scale;
            
            // Update size display with animation
            const sizeValue = document.getElementById('sizeValue');
            if (sizeValue) {
                // Add pulse animation
                sizeValue.classList.add('pulse-animation');
                sizeValue.textContent = `${Math.round(scale * 100)}%`;
                
                // Remove animation after it completes
                setTimeout(() => {
                    sizeValue.classList.remove('pulse-animation');
                }, 300);
            }
            
            // Reset auto-hide timer on interaction
            resetControlsTimer();
        }
        
        // Update jewelry opacity
        function updateJewelryOpacity(id, value) {
            if (!appState.activeJewelry.has(id)) return;
            
            const opacity = parseFloat(value);
            const jewelry = appState.activeJewelry.get(id);
            jewelry.opacity = opacity;
            
            // Update opacity display
            const opacityValue = document.getElementById('opacityValue');
            if (opacityValue) {
                opacityValue.textContent = `${Math.round(opacity * 100)}%`;
            }
            
            // Reset auto-hide timer on interaction
            resetControlsTimer();
        }
        
        // 4. Move Jewelry Function
        function moveJewelry(id, direction) {
            if (!appState.activeJewelry.has(id)) return;
            
            const jewelry = appState.activeJewelry.get(id);
            const step = 5; // Movement step in pixels
            
            // Reverse left/right directions if camera is mirrored
            if (appState.mirrorCamera) {
                if (direction === 'left') direction = 'right';
                else if (direction === 'right') direction = 'left';
                else if (direction === 'up-left') direction = 'up-right';
                else if (direction === 'up-right') direction = 'up-left';
                else if (direction === 'down-left') direction = 'down-right';
                else if (direction === 'down-right') direction = 'down-left';
            }
            
            switch (direction) {
                case 'up':
                    jewelry.offset.y -= step;
                    break;
                case 'down':
                    jewelry.offset.y += step;
                    break;
                case 'left':
                    jewelry.offset.x -= step;
                    break;
                case 'right':
                    jewelry.offset.x += step;
                    break;
                case 'up-left':
                    jewelry.offset.x -= step;
                    jewelry.offset.y -= step;
                    break;
                case 'up-right':
                    jewelry.offset.x += step;
                    jewelry.offset.y -= step;
                    break;
                case 'down-left':
                    jewelry.offset.x -= step;
                    jewelry.offset.y += step;
                    break;
                case 'down-right':
                    jewelry.offset.x += step;
                    jewelry.offset.y += step;
                    break;
                case 'center':
                    jewelry.offset = { x: 0, y: 0 };
                    break;
            }
            
            // Reset auto-hide timer on interaction
            resetControlsTimer();
        }
        // 5. Add Jewelry Function
        function addJewelry(id) {
            const originalJewelry = JEWELRY[id];
            if (!originalJewelry) return;
            
            // Create a deep copy of the jewelry item with loaded images
            const jewelryCopy = JSON.parse(JSON.stringify(originalJewelry));
            
            // Add loaded images (which can't be JSON stringified)
            if (originalJewelry.type === 'earrings') {
                jewelryCopy.leftImage = originalJewelry.leftImage;
                jewelryCopy.rightImage = originalJewelry.rightImage;
            } else {
                jewelryCopy.loadedImage = originalJewelry.loadedImage;
            }
            
            // Initialize with default values
            jewelryCopy.scale = originalJewelry.defaultScale;
            jewelryCopy.offset = { x: 0, y: 0 };
            jewelryCopy.visible = true;
            jewelryCopy.opacity = 1.0;
            
            // For hand jewelry, set default hand and finger
            if (originalJewelry.type === 'hand') {
                jewelryCopy.handIndex = 0; // Default to first detected hand
            }
            
            // Add to active jewelry
            appState.activeJewelry.set(id, jewelryCopy);
            
            // Show toast
            showToast(`${originalJewelry.name} added`);
            
            // Update carousel if that's the current view
            if (appState.currentCategory === 'active') {
                renderActiveItems();
            } else {
                // Update the particular carousel item to show as active
                const carouselItems = elements.jewelryCarousel.querySelectorAll('.carousel-item');
                carouselItems.forEach(card => {
                    if (card.dataset.jewelryId === id) {
                        card.classList.add('active');
                    }
                });
            }
        }
        
        // 6. Remove Jewelry Function
        function removeJewelry(id) {
            const jewelry = JEWELRY[id];
            if (!jewelry) return;
            
            // Remove from active jewelry
            appState.activeJewelry.delete(id);
            
            // Hide floating controls if they were for this jewelry
            if (appState.selectedJewelryId === id) {
                hideFloatingControls();
            }
            
            // Show toast
            showToast(`${jewelry.name} removed`);
            
            // Re-render carousel if needed
            if (appState.currentCategory === 'active') {
                renderActiveItems();
            } else {
                // Update just the particular carousel item to show as inactive
                const carouselItems = elements.jewelryCarousel.querySelectorAll('.carousel-item');
                carouselItems.forEach(card => {
                    if (card.dataset.jewelryId === id) {
                        card.classList.remove('active');
                    }
                });
            }
        }
        
        function showToast(message) {
            const toast = elements.toast;
            toast.textContent = message;
            toast.classList.add('visible');
            
            // Hide toast after 2 seconds
            setTimeout(() => {
                toast.classList.remove('visible');
            }, 2000);
        }
        
        // AI detection loop
        async function detectAll() {
            if (!appState.isInitialized || !appState.isCameraReady) {
                requestAnimationFrame(detectAll);
                return;
            }
        
            if (!elements.video.videoWidth) {
                console.log("Video not ready yet");
                requestAnimationFrame(detectAll);
                return;
            }
        
            try {
                await Promise.all([
                    faceMesh.send({image: elements.video}),
                    hands.send({image: elements.video}),
                    pose.send({image: elements.video})
                ]);
            } catch (error) {
                console.error("Detection error:", error);
            }
            
            requestAnimationFrame(detectAll);
        }
        
        // MediaPipe result handlers
        function onFaceMeshResults(results) {
            appState.faceLandmarks = results.multiFaceLandmarks && results.multiFaceLandmarks.length > 0 
                ? results.multiFaceLandmarks[0] 
                : null;
            
            renderJewelry();
        }
        
        function onHandResults(results) {
            appState.handLandmarks = results.multiHandLandmarks || [];
            renderJewelry();
        }
        
        function onPoseResults(results) {
            appState.poseLandmarks = results.poseLandmarks || null;
            renderJewelry();
        }
        
        // Main rendering function
        function renderJewelry() {
            if (!elements.canvas || !elements.ctx) return;
            
            // Make sure canvas dimensions match video
            if (elements.canvas.width !== elements.video.videoWidth || 
                elements.canvas.height !== elements.video.videoHeight) {
                elements.canvas.width = elements.video.videoWidth;
                elements.canvas.height = elements.video.videoHeight;
            }
            
            // Clear canvas
            elements.ctx.clearRect(0, 0, elements.canvas.width, elements.canvas.height);
            
            // Nothing to render if no jewelry or no landmarks
            if (appState.activeJewelry.size === 0) return;
            
            // Render each active jewelry item
            appState.activeJewelry.forEach((jewelry, id) => {
                if (!jewelry.visible) return;
                
                if (jewelry.type === 'necklace') {
                    if (appState.poseLandmarks) {
                        drawNecklace(jewelry, id);
                    }
                } else if (jewelry.type === 'earrings') {
                    if (appState.faceLandmarks) {
                        drawEarrings(jewelry, id);
                    }
                } else if (jewelry.type === 'single') { // tikka, etc.
                    if (appState.faceLandmarks) {
                        drawSinglePiece(jewelry, id);
                    }
                } else if (jewelry.type === 'hand') {
                    if (appState.handLandmarks && appState.handLandmarks.length > 0) {
                        if (id.startsWith('ring')) {
                            drawRing(jewelry, id);
                        } else if (id.startsWith('bangle')) {
                            drawBangle(jewelry, id);
                        }
                    }
                }
            });
        }
        
        // Drawing functions for each jewelry type
        function drawNecklace(jewelry, id) {
            if (!jewelry.loadedImage) return;
            
            const leftShoulder = appState.poseLandmarks[11];
            const rightShoulder = appState.poseLandmarks[12];
            
            if (!leftShoulder || !rightShoulder) return;
        
            // Calculate base positions from shoulders
            const shoulderWidth = Math.abs(rightShoulder.x - leftShoulder.x) * elements.canvas.width;
            const collarOffset = 0.15;
            const leftX = leftShoulder.x * elements.canvas.width + shoulderWidth * collarOffset;
            const rightX = rightShoulder.x * elements.canvas.width - shoulderWidth * collarOffset;
            const baseY = leftShoulder.y * elements.canvas.height;
        
            // Apply measurements with mobile-friendly adjustments
            const VERTICAL_OFFSET = -115;
            const DROP_HEIGHT = 45;
            
            const adjustedY = baseY + VERTICAL_OFFSET + jewelry.offset.y;
            const centerX = (leftX + rightX) / 2 + jewelry.offset.x;
            
            // Calculate necklace dimensions
            const necklaceWidth = shoulderWidth * jewelry.scale;
            const necklaceHeight = jewelry.loadedImage.height * (necklaceWidth / jewelry.loadedImage.width);
        
            // Calculate the actual drawing position in canvas coordinates
            const drawX = centerX - necklaceWidth/2;
            const drawY = adjustedY - DROP_HEIGHT/2;
        
            // Set opacity if defined
            if (jewelry.opacity !== undefined) {
                elements.ctx.globalAlpha = jewelry.opacity;
            }
        
            // Draw the necklace
            elements.ctx.save();
            elements.ctx.shadowColor = 'rgba(0,0,0,0.3)';
            elements.ctx.shadowBlur = 8;
            elements.ctx.shadowOffsetX = 2;
            elements.ctx.shadowOffsetY = 2;
        
            elements.ctx.drawImage(
                jewelry.loadedImage,
                drawX, drawY, necklaceWidth, necklaceHeight
            );
            
            elements.ctx.restore();
        }
        
        function drawEarrings(jewelry, id) {
            if (!jewelry.leftImage || !jewelry.rightImage) return;
            
            const landmarks = appState.faceLandmarks;
            if (!landmarks) return;
            
            const nose = landmarks[1];
            const leftEar = landmarks[234];
            const rightEar = landmarks[454];
            
            if (!nose || !leftEar || !rightEar) return;
            
            const faceRotation = (rightEar.z - leftEar.z);
            let gap = jewelry.gap || 0;
            
            // Adjust gap based on face rotation
            if (Math.abs(faceRotation) <= 0.1) {
                gap += 3;
            } else {
                gap += 24;
            }
            
            const leftLobe = landmarks[177];
            const rightLobe = landmarks[401];
            
            if (!leftLobe || !rightLobe) return;
            
            const faceWidth = Math.abs(rightEar.x - leftEar.x) * elements.canvas.width;
            const gapAdjustment = (gap / 100) * faceWidth;
            
            const earHeight = Math.abs(landmarks[234].y - leftLobe.y) * elements.canvas.height;
            const baseScale = (earHeight * 0.8) / jewelry.leftImage.height;
            const scale = baseScale * jewelry.scale; // Combine base scale with user adjustable scale
            
            // Set opacity if defined
            if (jewelry.opacity !== undefined) {
                elements.ctx.globalAlpha = jewelry.opacity;
            }
            
            elements.ctx.save();
            elements.ctx.shadowColor = 'rgba(0,0,0,0.3)';
            elements.ctx.shadowBlur = 5;
            elements.ctx.shadowOffsetX = 2;
            elements.ctx.shadowOffsetY = 2;
            
            // Draw left earring if face is not turned too far right
            if (faceRotation > -0.1) {
                const leftX = leftLobe.x * elements.canvas.width - gapAdjustment + jewelry.offset.x;
                const leftY = leftLobe.y * elements.canvas.height + jewelry.offset.y;
                
                const leftWidth = jewelry.leftImage.width * scale;
                const leftHeight = jewelry.leftImage.height * scale;
                elements.ctx.drawImage(
                    jewelry.leftImage,
                    leftX - leftWidth/2,
                    leftY - leftHeight/2,
                    leftWidth,
                    leftHeight
                );
            }
            
            // Draw right earring if face is not turned too far left
            if (faceRotation < 0.1) {
                const rightX = rightLobe.x * elements.canvas.width + gapAdjustment + jewelry.offset.x + 15 + 15;
                const rightY = rightLobe.y * elements.canvas.height + jewelry.offset.y;
                
                const rightWidth = jewelry.rightImage.width * scale;
                const rightHeight = jewelry.rightImage.height * scale;
                elements.ctx.drawImage(
                    jewelry.rightImage,
                    rightX - rightWidth/2,
                    rightY - rightHeight/2,
                    rightWidth,
                    rightHeight
                );
            }
            
            elements.ctx.restore();
        }
        
        function drawSinglePiece(jewelry, id) {
            if (!jewelry.loadedImage) return;
            
            const landmarks = appState.faceLandmarks;
            if (!landmarks) return;
            
            let x, y, baseScale, scale;
            
            // For tikka
            if (jewelry.landmark === 151) {
                const centerPoint = landmarks[151]; // Center of forehead
                const topPoint = landmarks[10];     // Top of forehead
                const refPoint = landmarks[9];      // Reference point
                
                if (!centerPoint || !topPoint || !refPoint) return;
                
                // Calculate position on the forehead
                x = ((centerPoint.x + refPoint.x) / 2) * elements.canvas.width + jewelry.offset.x;
                y = ((centerPoint.y + topPoint.y) / 2) * elements.canvas.height - 20 + jewelry.offset.y;
                
                // Scale based on forehead width
                const foreheadWidth = Math.abs(landmarks[71].x - landmarks[301].x) * elements.canvas.width;
                baseScale = (foreheadWidth * 0.4) / jewelry.loadedImage.width;
                scale = baseScale * jewelry.scale;
            } else {
                // Default to center of face if landmark isn't recognized
                const nose = landmarks[1];
                if (!nose) return;
                
                x = nose.x * elements.canvas.width + jewelry.offset.x;
                y = nose.y * elements.canvas.height + jewelry.offset.y;
                scale = jewelry.scale;
            }
            
            // Set opacity if defined
            if (jewelry.opacity !== undefined) {
                elements.ctx.globalAlpha = jewelry.opacity;
            }
            
            // Draw the jewelry
            elements.ctx.save();
            elements.ctx.shadowColor = 'rgba(0,0,0,0.3)';
            elements.ctx.shadowBlur = 8;
            elements.ctx.shadowOffsetX = 2;
            elements.ctx.shadowOffsetY = 2;
            
            const width = jewelry.loadedImage.width * scale;
            const height = jewelry.loadedImage.height * scale;
            
            elements.ctx.drawImage(
                jewelry.loadedImage,
                x - width/2,
                y - height/2,
                width,
                height
            );
            
            elements.ctx.restore();
        }

        function drawRing(jewelry, id) {
            if (!jewelry.loadedImage) return;
            
            // Check if we have hand landmarks and the right hand index
            const handIndex = jewelry.handIndex || 0;
            if (!appState.handLandmarks || !appState.handLandmarks[handIndex]) return;
            
            const handLandmarks = appState.handLandmarks[handIndex];
            const fingerTip = handLandmarks[jewelry.fingerIndex];
            const fingerBase = handLandmarks[jewelry.fingerIndex - 3];
            
            if (!fingerTip || !fingerBase) return;
            
            // Calculate position along the finger (closer to base)
            const positionRatio = 0.3; // 30% from base to tip
            const x = (fingerBase.x + (fingerTip.x - fingerBase.x) * positionRatio) * elements.canvas.width + jewelry.offset.x;
            const y = (fingerBase.y + (fingerTip.y - fingerBase.y) * positionRatio) * elements.canvas.height + jewelry.offset.y;
            
            // Calculate rotation angle
            const angle = Math.atan2(
                fingerTip.y - fingerBase.y,
                fingerTip.x - fingerBase.x
            );
            
            // Set opacity if defined
            if (jewelry.opacity !== undefined) {
                elements.ctx.globalAlpha = jewelry.opacity;
            }
            
            // Draw rotated ring
            elements.ctx.save();
            elements.ctx.translate(x, y);
            elements.ctx.rotate(angle - Math.PI/2);
            
            const width = jewelry.loadedImage.width * jewelry.scale;
            const height = jewelry.loadedImage.height * jewelry.scale;
            
            elements.ctx.drawImage(
                jewelry.loadedImage,
                -width/2,
                -height/2,
                width,
                height
            );
            
            elements.ctx.restore();
        }
        
        function drawBangle(jewelry, id) {
            if (!jewelry.loadedImage) return;
            
            // Check if we have hand landmarks and the right hand index
            const handIndex = jewelry.handIndex || 0;
            if (!appState.handLandmarks || !appState.handLandmarks[handIndex]) return;
            
            const handLandmarks = appState.handLandmarks[handIndex];
            const wrist = handLandmarks[0];
            const palmBase = handLandmarks[9];
            
            if (!wrist || !palmBase) return;
            
            // Add offsets to position bangle
            const verticalOffset = 30;
            const horizontalOffset = -20;
            
            const x = wrist.x * elements.canvas.width + horizontalOffset + jewelry.offset.x;
            const y = wrist.y * elements.canvas.height + verticalOffset + jewelry.offset.y;
            
            // Calculate rotation angle
            const angle = Math.atan2(
                palmBase.y - wrist.y,
                palmBase.x - wrist.x
            );
            
            // Calculate size based on wrist width
            const wristLeft = handLandmarks[17];
            const wristRight = handLandmarks[5];
            
            if (!wristLeft || !wristRight) return;
            
            const wristWidth = Math.abs(wristRight.x - wristLeft.x) * elements.canvas.width;
            const baseScale = 3.2;
            
            // Set opacity if defined
            if (jewelry.opacity !== undefined) {
                elements.ctx.globalAlpha = jewelry.opacity;
            }
            
            // Draw rotated bangle
            elements.ctx.save();
            elements.ctx.translate(x, y);
            elements.ctx.rotate(angle - Math.PI/2);
            
            const width = wristWidth * baseScale * jewelry.scale;
            const height = jewelry.loadedImage.height * (width / jewelry.loadedImage.width);
            
            elements.ctx.drawImage(
                jewelry.loadedImage,
                -width/2,
                -height/2,
                width,
                height
            );
            
            elements.ctx.restore();
        }
        
        // Camera access request
        async function requestCameraAccess() {
            try {
                document.getElementById('cameraError').classList.add('hidden');
                await initializeCamera();
                if (!appState.isInitialized) {
                    // If we haven't fully initialized yet, continue initialization
                    await initializeAIModels();
                    await preloadJewelryImages();
                    initializeUI();
                    appState.isInitialized = true;
                    requestAnimationFrame(detectAll);
                }
            } catch (error) {
                console.error("Camera request error:", error);
                document.getElementById('cameraError').classList.remove('hidden');
            }
        }
        
        function captureScreenshot() {
            // Pause the video stream
            elements.video.pause();
            
            // Create a new full-size canvas matching video dimensions
            const captureCanvas = document.createElement('canvas');
            captureCanvas.width = elements.video.videoWidth;
            captureCanvas.height = elements.video.videoHeight;
            const ctx = captureCanvas.getContext('2d');
            
            // Draw the video frame with mirroring if enabled
            ctx.save();
            if (appState.mirrorCamera) {
                ctx.scale(-1, 1);
                ctx.drawImage(
                    elements.video, 
                    -captureCanvas.width, 0, 
                    captureCanvas.width, 
                    captureCanvas.height
                );
            } else {
                ctx.drawImage(
                    elements.video,
                    0, 0,
                    captureCanvas.width,
                    captureCanvas.height
                );
            }
            ctx.restore();
            
            // Draw jewelry canvas with the same mirroring if enabled
            ctx.save();
            if (appState.mirrorCamera) {
                ctx.scale(-1, 1);
                ctx.drawImage(
                    elements.canvas, 
                    -captureCanvas.width, 0, 
                    captureCanvas.width, 
                    captureCanvas.height
                );
            } else {
                ctx.drawImage(
                    elements.canvas,
                    0, 0,
                    captureCanvas.width,
                    captureCanvas.height
                );
            }
            ctx.restore();
            
            // Create modal for preview and save
            const modal = document.createElement('div');
            modal.style.position = 'fixed';
            modal.style.top = '0';
            modal.style.left = '0';
            modal.style.width = '100%';
            modal.style.height = '100%';
            modal.style.backgroundColor = 'rgba(0,0,0,0.8)';
            modal.style.zIndex = '1000';
            modal.style.display = 'flex';
            modal.style.flexDirection = 'column';
            modal.style.alignItems = 'center';
            modal.style.justifyContent = 'center';
            
            const previewImg = document.createElement('img');
            previewImg.src = captureCanvas.toDataURL('image/png');
            previewImg.style.maxWidth = '90%';
            previewImg.style.maxHeight = '80%';
            previewImg.style.objectFit = 'contain';
            
            const buttonContainer = document.createElement('div');
            buttonContainer.style.marginTop = '20px';
            
            const saveButton = document.createElement('button');
            saveButton.textContent = 'Save';
            saveButton.style.margin = '0 10px';
            saveButton.style.padding = '10px 20px';
            saveButton.onclick = () => {
                const link = document.createElement('a');
                link.download = 'jewelry-tryon-' + new Date().toISOString().slice(0, 10) + '.png';
                link.href = captureCanvas.toDataURL('image/png');
                link.click();
                document.body.removeChild(modal);
                elements.video.play();
            };
            
            const cancelButton = document.createElement('button');
            cancelButton.textContent = 'Cancel';
            cancelButton.style.margin = '0 10px';
            cancelButton.style.padding = '10px 20px';
            cancelButton.onclick = () => {
                document.body.removeChild(modal);
                elements.video.play();
            };
            
            buttonContainer.appendChild(saveButton);
            buttonContainer.appendChild(cancelButton);
            
            modal.appendChild(previewImg);
            modal.appendChild(buttonContainer);
            
            document.body.appendChild(modal);
        }
        
        // 15. Setup Gesture Handlers
        function setupGestureHandlers() {
            initializeDragGesture();
            initializePinchGesture();
            initializeTapGesture();
            
            // Add preview bar gestures
            const previewHandle = elements.previewHandle;
            if (previewHandle) {
                let startY = 0;
                
                previewHandle.addEventListener('click', togglePreviewBar);
                
                previewHandle.addEventListener('touchstart', (e) => {
                    startY = e.touches[0].clientY;
                    e.preventDefault();
                });
                
                previewHandle.addEventListener('touchmove', (e) => {
                    const deltaY = e.touches[0].clientY - startY;
                    
                    // If swiping up more than 10px, expand preview bar
                    if (deltaY < -10) {
                        elements.previewBar.classList.remove('collapsed');
                    }
                    // If swiping down more than 10px, collapse preview bar
                    else if (deltaY > 10) {
                        elements.previewBar.classList.add('collapsed');
                    }
                    
                    e.preventDefault();
                });
            }
        }
        
        // 14. Initialize Drag Gesture
        function initializeDragGesture() {
            const canvas = elements.canvas;
            let isDragging = false;
            let dragJewelryId = null;
            let dragStartPosition = { x: 0, y: 0 };
            let jewelryStartOffset = { x: 0, y: 0 };
            
            // For canvas jewelry dragging
            canvas.addEventListener('touchstart', (e) => {
                if (e.touches.length !== 1 || appState.activeJewelry.size === 0) return;
                
                const touch = e.touches[0];
                const position = { x: touch.clientX, y: touch.clientY };
                
                // Find jewelry at touch point
                const jewelryId = findJewelryAtPoint(position.x, position.y);
                if (jewelryId) {
                    isDragging = true;
                    dragJewelryId = jewelryId;
                    dragStartPosition = position;
                    
                    // Store starting offset
                    const jewelry = appState.activeJewelry.get(jewelryId);
                    jewelryStartOffset = { ...jewelry.offset };
                    
                    // Prevent scrolling while dragging jewelry
                    e.preventDefault();
                }
            });
            
            canvas.addEventListener('touchmove', (e) => {
                if (!isDragging || !dragJewelryId) return;
                
                const touch = e.touches[0];
                const position = { x: touch.clientX, y: touch.clientY };
                
                // Calculate movement delta
                const deltaX = position.x - dragStartPosition.x;
                const deltaY = position.y - dragStartPosition.y;
                
                // Update jewelry position
                const jewelry = appState.activeJewelry.get(dragJewelryId);
                if (jewelry) {
                    jewelry.offset.x = jewelryStartOffset.x + deltaX;
                    jewelry.offset.y = jewelryStartOffset.y + deltaY;
                }
                
                // Reset auto-hide timer when dragging
                resetControlsTimer();
                
                // Prevent scrolling
                e.preventDefault();
            });
            
            canvas.addEventListener('touchend', (e) => {
                isDragging = false;
                dragJewelryId = null;
            });
            
            canvas.addEventListener('touchcancel', (e) => {
                isDragging = false;
                dragJewelryId = null;
            });
            
            // For dragging the floating controls panel
            const controlHeader = elements.floatingControls.querySelector('.control-header');
            let isDraggingControls = false;
            let controlsStartX = 0;
            let controlsStartY = 0;
            
            if (controlHeader) {
                controlHeader.addEventListener('mousedown', (e) => {
                    isDraggingControls = true;
                    controlsStartX = e.clientX - elements.floatingControls.getBoundingClientRect().left;
                    controlsStartY = e.clientY - elements.floatingControls.getBoundingClientRect().top;
                    controlHeader.style.cursor = 'grabbing';
                    e.preventDefault();
                });
                
                controlHeader.addEventListener('touchstart', (e) => {
                    isDraggingControls = true;
                    controlsStartX = e.touches[0].clientX - elements.floatingControls.getBoundingClientRect().left;
                    controlsStartY = e.touches[0].clientY - elements.floatingControls.getBoundingClientRect().top;
                    e.preventDefault();
                });
            }
            
            window.addEventListener('mousemove', (e) => {
                if (!isDraggingControls) return;
                
                const x = e.clientX - controlsStartX;
                const y = e.clientY - controlsStartY;
                
                // Constrain to viewport
                const maxX = window.innerWidth - elements.floatingControls.offsetWidth;
                const maxY = window.innerHeight - elements.floatingControls.offsetHeight;
                
                elements.floatingControls.style.left = `${Math.max(0, Math.min(maxX, x))}px`;
                elements.floatingControls.style.top = `${Math.max(0, Math.min(maxY, y))}px`;
                
                // Remove any transform that might be applied
                elements.floatingControls.style.transform = 'none';
                
                // Reset auto-hide timer when dragging controls
                resetControlsTimer();
            });
            
            window.addEventListener('touchmove', (e) => {
                if (!isDraggingControls) return;
                
                const x = e.touches[0].clientX - controlsStartX;
                const y = e.touches[0].clientY - controlsStartY;
                
                // Constrain to viewport
                const maxX = window.innerWidth - elements.floatingControls.offsetWidth;
                const maxY = window.innerHeight - elements.floatingControls.offsetHeight;
                
                elements.floatingControls.style.left = `${Math.max(0, Math.min(maxX, x))}px`;
                elements.floatingControls.style.top = `${Math.max(0, Math.min(maxY, y))}px`;
                
                // Remove any transform that might be applied
                elements.floatingControls.style.transform = 'none';
                
                // Reset auto-hide timer when dragging controls
                resetControlsTimer();
                
                e.preventDefault();
            });
            
            window.addEventListener('mouseup', () => {
                if (isDraggingControls && controlHeader) {
                    controlHeader.style.cursor = 'grab';
                }
                isDraggingControls = false;
            });
            
            window.addEventListener('touchend', () => {
                isDraggingControls = false;
            });
        }
        
        // 13. Initialize Pinch Gesture
        function initializePinchGesture() {
            const canvas = elements.canvas;
            let initialDistance = 0;
            let selectedJewelryId = null;
            
            canvas.addEventListener('touchstart', (e) => {
                if (e.touches.length !== 2 || appState.activeJewelry.size === 0) return;
                
                // Calculate initial distance between touch points
                const touch1 = e.touches[0];
                const touch2 = e.touches[1];
                initialDistance = Math.hypot(
                    touch2.clientX - touch1.clientX,
                    touch2.clientY - touch1.clientY
                );
                
                // Find jewelry at midpoint of touch
                const midX = (touch1.clientX + touch2.clientX) / 2;
                const midY = (touch1.clientY + touch2.clientY) / 2;
                selectedJewelryId = findJewelryAtPoint(midX, midY);
                
                if (selectedJewelryId) {
                    e.preventDefault(); // Prevent default zoom behavior
                }
            });
            
            canvas.addEventListener('touchmove', (e) => {
                if (e.touches.length !== 2 || !selectedJewelryId) return;
                
                // Calculate new distance between touch points
                const touch1 = e.touches[0];
                const touch2 = e.touches[1];
                const currentDistance = Math.hypot(
                    touch2.clientX - touch1.clientX,
                    touch2.clientY - touch1.clientY
                );
                
                // Calculate scale factor
                const scaleFactor = currentDistance / initialDistance;
                
                // Get jewelry and update scale
                const jewelry = appState.activeJewelry.get(selectedJewelryId);
                if (jewelry) {
                    // Apply a dampening factor to make the scale change smoother
                    const dampening = 0.03;
                    const newScale = jewelry.scale * (1 + (scaleFactor - 1) * dampening);
                    
                    // Limit scale to reasonable bounds
                    jewelry.scale = Math.max(0.2, Math.min(3.0, newScale));
                    
                    // Update size value in control panel if visible
                    const sizeValue = document.getElementById('sizeValue');
                    if (sizeValue) {
                        sizeValue.textContent = `${Math.round(jewelry.scale * 100)}%`;
                    }
                }
                
                // Reset auto-hide timer on interaction
                resetControlsTimer();
                
                e.preventDefault(); // Prevent default zoom behavior
            });
            
            canvas.addEventListener('touchend', (e) => {
                if (e.touches.length === 0) {
                    selectedJewelryId = null;
                }
            });
        }
        
        // 12. Initialize Tap Gesture
        function initializeTapGesture() {
            const canvas = elements.canvas;
            let lastTapTime = 0;
            let lastTapPosition = { x: 0, y: 0 };
            
            canvas.addEventListener('touchend', (e) => {
                if (e.touches.length > 0 || appState.activeJewelry.size === 0) return;
                
                const touch = e.changedTouches[0];
                const currentTime = new Date().getTime();
                const tapPosition = { x: touch.clientX, y: touch.clientY };
                
                // Detect if this is a genuine tap
                const moveDistance = Math.sqrt(
                    Math.pow(tapPosition.x - lastTapPosition.x, 2) + 
                    Math.pow(tapPosition.y - lastTapPosition.y, 2)
                );
                
                if (moveDistance < 10) {
                    // Find jewelry at tap position
                    const jewelryId = findJewelryAtPoint(tapPosition.x, tapPosition.y);
                    if (jewelryId) {
                        // If double tap, toggle controls
                        if (currentTime - lastTapTime < 300) {
                            if (elements.floatingControls.classList.contains('hidden')) {
                                appState.selectedJewelryId = jewelryId;
                                renderFloatingControls(jewelryId);
                                showFloatingControls(jewelryId);
                            } else {
                                hideFloatingControls();
                            }
                        }
                        
                        lastTapTime = currentTime;
                    } else {
                        // If tap on empty space, hide controls
                        hideFloatingControls();
                    }
                }
                
                lastTapPosition = tapPosition;
            });
            
            // Single click for desktop support
            canvas.addEventListener('click', (e) => {
                if (appState.activeJewelry.size === 0) return;
                
                // Find jewelry at click position
                const jewelryId = findJewelryAtPoint(e.clientX, e.clientY);
                if (jewelryId) {
                    // Toggle controls
                    if (elements.floatingControls.classList.contains('hidden') || 
                        appState.selectedJewelryId !== jewelryId) {
                        appState.selectedJewelryId = jewelryId;
                        renderFloatingControls(jewelryId);
                        showFloatingControls(jewelryId);
                    } else {
                        hideFloatingControls();
                    }
                } else {
                    // If click on empty space, hide controls
                    hideFloatingControls();
                }
            });
        }
        
        // 11. Find Jewelry at Point
        function findJewelryAtPoint(clientX, clientY) {
            // Convert client coordinates to canvas coordinates
            const rect = elements.canvas.getBoundingClientRect();
            const canvasX = (clientX - rect.left) * (elements.canvas.width / rect.width);
            const canvasY = (clientY - rect.top) * (elements.canvas.height / rect.height);
            
            // Check each active jewelry
            for (const [id, jewelry] of appState.activeJewelry.entries()) {
                if (!jewelry.visible) continue;
                
                // Simplified hit testing based on jewelry type
                let hit = false;
                
                if (jewelry.type === 'earrings' && appState.faceLandmarks) {
                    // Test both earrings
                    const leftLobe = appState.faceLandmarks[177];
                    const rightLobe = appState.faceLandmarks[401];
                    
                    if (leftLobe && rightLobe) {
                        const leftX = leftLobe.x * elements.canvas.width + jewelry.offset.x;
                        const leftY = leftLobe.y * elements.canvas.height + jewelry.offset.y;
                        const rightX = rightLobe.x * elements.canvas.width + jewelry.offset.x;
                        const rightY = rightLobe.y * elements.canvas.height + jewelry.offset.y;
                        
                        // Hit radius based on scale
                        const radius = 50 * jewelry.scale;
                        
                        // Check if touch is inside either earring's hit area
                        const leftDist = Math.sqrt(Math.pow(canvasX - leftX, 2) + Math.pow(canvasY - leftY, 2));
                        const rightDist = Math.sqrt(Math.pow(canvasX - rightX, 2) + Math.pow(canvasY - rightY, 2));
                        
                        if (leftDist < radius || rightDist < radius) {
                            hit = true;
                        }
                    }
                } else if (jewelry.type === 'necklace' && appState.poseLandmarks) {
                    const leftShoulder = appState.poseLandmarks[11];
                    const rightShoulder = appState.poseLandmarks[12];
                    
                    if (leftShoulder && rightShoulder) {
                        const centerX = (leftShoulder.x + rightShoulder.x) / 2 * elements.canvas.width + jewelry.offset.x;
                        const centerY = leftShoulder.y * elements.canvas.height - 100 + jewelry.offset.y;
                        
                        // Hit area based on necklace size
                        const hitRadius = 100 * jewelry.scale;
                        
                        const dist = Math.sqrt(Math.pow(canvasX - centerX, 2) + Math.pow(canvasY - centerY, 2));
                        if (dist < hitRadius) {
                            hit = true;
                        }
                    }
                } else if (jewelry.type === 'single' && appState.faceLandmarks) {
                    const centerPoint = appState.faceLandmarks[151];
                    
                    if (centerPoint) {
                        const x = centerPoint.x * elements.canvas.width + jewelry.offset.x;
                        const y = centerPoint.y * elements.canvas.height - 20 + jewelry.offset.y;
                        
                        // Hit radius based on scale
                        const radius = 50 * jewelry.scale;
                        
                        const dist = Math.sqrt(Math.pow(canvasX - x, 2) + Math.pow(canvasY - y, 2));
                        if (dist < radius) {
                            hit = true;
                        }
                    }
                } else if (jewelry.type === 'hand' && appState.handLandmarks && appState.handLandmarks.length > 0) {
                    const handIndex = jewelry.handIndex || 0;
                    
                    if (appState.handLandmarks[handIndex]) {
                        // For ring
                        if (id.startsWith('ring')) {
                            const handLandmarks = appState.handLandmarks[handIndex];
                            const fingerTip = handLandmarks[jewelry.fingerIndex];
                            const fingerBase = handLandmarks[jewelry.fingerIndex - 3];
                            
                            if (fingerTip && fingerBase) {
                                // Position ring between tip and base
                                const positionRatio = 0.3;
                                const x = (fingerBase.x + (fingerTip.x - fingerBase.x) * positionRatio) * elements.canvas.width + jewelry.offset.x;
                                const y = (fingerBase.y + (fingerTip.y - fingerBase.y) * positionRatio) * elements.canvas.height + jewelry.offset.y;
                                
                                // Hit radius based on ring size
                                const radius = 30 * jewelry.scale;
                                
                                const dist = Math.sqrt(Math.pow(canvasX - x, 2) + Math.pow(canvasY - y, 2));
                                if (dist < radius) {
                                    hit = true;
                                }
                            }
                        } else if (id.startsWith('bangle')) {
                            const handLandmarks = appState.handLandmarks[handIndex];
                            const wrist = handLandmarks[0];
                            
                            if (wrist) {
                                const x = wrist.x * elements.canvas.width + jewelry.offset.x;
                                const y = wrist.y * elements.canvas.height + jewelry.offset.y;
                                
                                // Hit radius based on bangle size
                                const radius = 40 * jewelry.scale;
                                
                                const dist = Math.sqrt(Math.pow(canvasX - x, 2) + Math.pow(canvasY - y, 2));
                                if (dist < radius) {
                                    hit = true;
                                }
                            }
                        }
                    }
                }
                
                if (hit) {
                    return id;
                }
            }
            
            return null; // No jewelry found at touch point
        }
        
        // 10. Add to Cart Function
        function addToCart(id) {
            const item = JEWELRY[id];
            if (!item) return;
            
            // Just show toast notification
            showToast(`${item.name} added to cart`);
        }
        
        // Helper function for loading status updates
        function updateLoadingStatus(message) {
            const loadingScreen = document.getElementById('loadingScreen');
            const statusText = loadingScreen.querySelector('p:not(.loading-error)');
            if (statusText) {
                statusText.textContent = message;
            }
        }
        
        function showError(message) {
            const loadingScreen = document.getElementById('loadingScreen');
            const errorElement = loadingScreen.querySelector('.loading-error');
            if (errorElement) {
                errorElement.textContent = message;
                errorElement.classList.remove('hidden');
            }
        }
        
        function hideLoadingScreen() {
            document.getElementById('loadingScreen').classList.add('hidden');
        }
        
        function setPerformanceMode(mode) {
            appState.performanceMode = mode;
            
            // Update UI buttons
            const lowBtn = document.querySelector('button[onclick="setPerformanceMode(\'low\')"]');
            const mediumBtn = document.querySelector('button[onclick="setPerformanceMode(\'medium\')"]');
            const highBtn = document.querySelector('button[onclick="setPerformanceMode(\'high\')"]');
            
            if (lowBtn) lowBtn.classList.toggle('bg-primary', mode === 'low');
            if (lowBtn) lowBtn.classList.toggle('text-white', mode === 'low');
            if (mediumBtn) mediumBtn.classList.toggle('bg-primary', mode === 'medium');
            if (mediumBtn) mediumBtn.classList.toggle('text-white', mode === 'medium');
            if (highBtn) highBtn.classList.toggle('bg-primary', mode === 'high');
            if (highBtn) highBtn.classList.toggle('text-white', mode === 'high');
            
            // Apply performance settings to AI models
            switch(mode) {
                case 'low':
                    if (faceMesh) faceMesh.setOptions({ 
                        maxNumFaces: 1,
                        refineLandmarks: false, 
                        minDetectionConfidence: 0.7, 
                        minTrackingConfidence: 0.7 
                    });
                    if (hands) hands.setOptions({ 
                        maxNumHands: 1, 
                        modelComplexity: 0, 
                        minDetectionConfidence: 0.7, 
                        minTrackingConfidence: 0.7 
                    });
                    if (pose) pose.setOptions({ 
                        modelComplexity: 0, 
                        smoothLandmarks: true,
                        minDetectionConfidence: 0.7, 
                        minTrackingConfidence: 0.7 
                    });
                    showToast('Low performance mode active');
                    break;
                    
                case 'medium':
                    if (faceMesh) faceMesh.setOptions({ 
                        maxNumFaces: 1,
                        refineLandmarks: true, 
                        minDetectionConfidence: 0.5, 
                        minTrackingConfidence: 0.5 
                    });
                    if (hands) hands.setOptions({ 
                        maxNumHands: 2, 
                        modelComplexity: 0, 
                        minDetectionConfidence: 0.5, 
                        minTrackingConfidence: 0.5 
                    });
                    if (pose) pose.setOptions({ 
                        modelComplexity: 0, 
                        smoothLandmarks: true,
                        minDetectionConfidence: 0.5, 
                        minTrackingConfidence: 0.5 
                    });
                    showToast('Medium performance mode active');
                    break;
                    
                case 'high':
                    if (faceMesh) faceMesh.setOptions({ 
                        maxNumFaces: 1,
                        refineLandmarks: true, 
                        minDetectionConfidence: 0.5, 
                        minTrackingConfidence: 0.5 
                    });
                    if (hands) hands.setOptions({ 
                        maxNumHands: 2, 
                        modelComplexity: 1, 
                        minDetectionConfidence: 0.5, 
                        minTrackingConfidence: 0.5 
                    });
                    if (pose) pose.setOptions({ 
                        modelComplexity: 1, 
                        smoothLandmarks: true,
                        minDetectionConfidence: 0.5, 
                        minTrackingConfidence: 0.5 
                    });
                    showToast('High performance mode active');
                    break;
            }
        }
        
        // Window resize handler
        window.addEventListener('resize', () => {
            // Update canvas dimensions to match video
            if (elements.video && elements.canvas) {
                elements.canvas.width = elements.video.videoWidth;
                elements.canvas.height = elements.video.videoHeight;
            }
            
            // Hide floating controls to prevent them being in wrong position
            hideFloatingControls();
            
            // Re-render active jewelry after resize
            renderJewelry();
        });
        
        // Handle orientation change
        window.addEventListener('orientationchange', () => {
            // Short delay to allow UI to stabilize after rotation
            setTimeout(() => {
                // Update canvas dimensions
                if (elements.video && elements.canvas) {
                    elements.canvas.width = elements.video.videoWidth;
                    elements.canvas.height = elements.video.videoHeight;
                }
                
                // Hide floating controls
                hideFloatingControls();
                
                // Re-render active jewelry
                renderJewelry();
            }, 300);
        });
        
        // Initialize the app when the document is loaded
        document.addEventListener('DOMContentLoaded', init);     
    </script>
</body>
</html>
