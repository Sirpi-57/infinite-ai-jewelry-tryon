<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Infinite AI - Virtual Try-On Experience</title>
    
    <!-- Load MediaPipe dependencies -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh@0.4.1633559619/face_mesh.js" defer></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1646424915/hands.js" defer></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils@0.3.1620248257/drawing_utils.js" defer></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils@0.3.1620248257/camera_utils.js" defer></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/pose@0.5.1675469404/pose.js" defer></script>

    <!-- Stylesheets -->
    <link href="https://cdnjs.cloudflare.com/ajax/libs/tailwindcss/2.2.19/tailwind.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    
    <!-- Our custom CSS will be added here -->
    <style>
        :root {
            --color-primary: #7B2CBF;
            --color-secondary: #9D4EDD;
            --color-accent: #C77DFF;
            --color-dark: #240046;
            --color-light: #E0AAFF;
            --color-background: #f8f9fa;
            --color-surface: #ffffff;
            --color-border: rgba(36, 0, 70, 0.1);
            --color-text: #2D3748;
            
            /* Mobile-specific dimensions */
            --bottom-sheet-height: 30vh;
            --bottom-sheet-height-expanded: 70vh;
            --bottom-sheet-handle-height: 24px;
            --tab-height: 60px;
            --nav-height: 56px;
            --controls-height: 40vh;
            --sheet-border-radius: 16px;
            
            /* Transitions */
            --transition-speed: 0.3s;
            --transition-timing: cubic-bezier(0.4, 0, 0.2, 1);
        }
        
        /* Base Styles */
        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background-color: var(--color-background);
            margin: 0;
            padding: 0;
            color: var(--color-text);
            height: 100vh;
            width: 100vw;
            overscroll-behavior: none; /* Prevent pull-to-refresh */
            overflow: hidden;
            position: fixed; /* Prevent body scrolling */
        }
        
        /* Disable long-press menu on mobile */
        * {
            -webkit-touch-callout: none;
            -webkit-tap-highlight-color: transparent;
        }
        
        /* Main Container */
        .app-container {
            position: relative;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        
        /* Loading Screen */
        .loading-screen {
            position: fixed;
            inset: 0;
            background: var(--color-surface);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
            z-index: 1000;
            opacity: 1;
            visibility: visible;
            transition: opacity 0.3s ease-in-out, visibility 0.3s ease-in-out;
        }
        
        .loading-screen.hidden {
            opacity: 0;
            visibility: hidden;
            pointer-events: none;
        }
        
        .loading-error {
            color: #dc2626;
            margin-top: 1rem;
            text-align: center;
            max-width: 80%;
        }
        
        /* Infinity Loader */
        .loading-spinner {
            width: 80px;
            height: 40px;
            position: relative;
            margin-bottom: 2rem;
        }
        
        .loading-spinner svg {
            width: 100%;
            height: 100%;
        }
        
        .infinity-path {
            fill: none;
            stroke: rgba(123, 44, 191, 0.2);
            stroke-width: 4;
            stroke-linecap: round;
        }
        
        .infinity-highlight {
            fill: none;
            stroke: var(--color-primary);
            stroke-width: 4;
            stroke-linecap: round;
            stroke-linejoin: round;
            stroke-dasharray: 50 150;
            stroke-dashoffset: 0;
            animation: moveHighlight 2s linear infinite;
        }
        
        @keyframes moveHighlight {
            from { stroke-dashoffset: 0; }
            to { stroke-dashoffset: -200; }
        }
        
        /* Loading Quote */
        .loading-quote {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 90%;
            max-width: 400px;
            text-align: center;
            color: var(--color-dark);
            font-style: italic;
            line-height: 1.4;
        }
        
        .quote-text {
            font-size: clamp(1.2rem, 5vw, 1.8rem);
            margin-bottom: 0.5rem;
            opacity: 0.9;
            font-weight: 500;
        }
        
        .quote-author {
            font-size: clamp(0.9rem, 3vw, 1.2rem);
            color: var(--color-secondary);
            font-weight: 500;
        }
        
        .loading-brand {
            position: absolute;
            bottom: 2rem;
            left: 50%;
            transform: translateX(-50%);
            font-size: 1.2rem;
            color: var(--color-primary);
            opacity: 0.9;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        .brand-text {
            font-weight: 700;
            background: linear-gradient(45deg, var(--color-primary), var(--color-secondary));
            background-clip: text;
            -webkit-background-clip: text;
            color: transparent;
            -webkit-text-fill-color: transparent;
            letter-spacing: 0.5px;
        }
        
        /* Top Navigation */
        .top-nav {
            height: var(--nav-height);
            background-color: var(--color-primary);
            color: white;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 1rem;
            position: relative;
            z-index: 10;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        
        .nav-brand {
            font-weight: 600;
            font-size: 1.2rem;
        }
        
        .nav-controls {
            display: flex;
            gap: 1rem;
        }
        
        .menu-toggle {
            background: none;
            border: none;
            color: white;
            font-size: 1.2rem;
            cursor: pointer;
            padding: 0.5rem;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        /* Category Tabs */
        .category-tabs {
            height: var(--tab-height);
            background-color: var(--color-surface);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
            z-index: 5;
            overflow-x: auto;
            -webkit-overflow-scrolling: touch;
            scrollbar-width: none; /* Firefox */
        }
        
        .category-tabs::-webkit-scrollbar {
            display: none; /* Chrome, Safari */
        }
        
        .tabs-container {
            display: flex;
            min-width: 100%;
            height: 100%;
        }
        
        .tab-btn {
            flex: 1;
            min-width: 80px;
            height: 100%;
            background: none;
            border: none;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: var(--color-text);
            font-size: 0.85rem;
            gap: 0.5rem;
            transition: color 0.2s ease;
            position: relative;
        }
        
        .tab-btn.active {
            color: var(--color-primary);
        }
        
        .tab-btn.active::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 20%;
            width: 60%;
            height: 3px;
            background-color: var(--color-primary);
            border-radius: 3px 3px 0 0;
        }
        
        .tab-btn i {
            font-size: 1.2rem;
        }
        
        /* Camera Container */
        .camera-container {
            flex: 1;
            position: relative;
            background: var(--color-dark);
            overflow: hidden;
        }
        
        #cameraFeed {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        
        #jewelryCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }
        
        /* Camera Error */
        .camera-error {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: var(--color-surface);
            padding: 2rem;
            border-radius: 1rem;
            text-align: center;
            width: 85%;
            max-width: 400px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
            z-index: 5;
        }
        
        .camera-error.hidden {
            display: none;
        }
        
        /* Bottom Sheet */
        .bottom-sheet {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: var(--bottom-sheet-height);
            background-color: var(--color-surface);
            border-radius: var(--sheet-border-radius) var(--sheet-border-radius) 0 0;
            box-shadow: 0 -4px 20px rgba(0, 0, 0, 0.1);
            transition: transform var(--transition-speed) var(--transition-timing);
            z-index: 20;
            overflow: hidden;
            touch-action: none;
        }
        
        .bottom-sheet.expanded {
            height: var(--bottom-sheet-height-expanded);
            transform: translateY(0) !important;
        }
        
        .bottom-sheet.hidden {
            transform: translateY(100%);
        }
        
        .sheet-handle {
            height: var(--bottom-sheet-handle-height);
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: grab;
            touch-action: none;
        }
        
        .handle-bar {
            width: 40px;
            height: 5px;
            background-color: #ddd;
            border-radius: 3px;
        }
        
        .sheet-content {
            height: calc(100% - var(--bottom-sheet-handle-height));
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
            padding: 0 1rem 2rem;
        }
        
        .sheet-title {
            font-size: 1.1rem;
            font-weight: 600;
            margin: 0 0 1rem;
            color: var(--color-dark);
        }
        
        /* Jewelry Grid */
        .jewelry-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 1rem;
            padding-bottom: 1rem;
        }
        
        @media (min-width: 480px) {
            .jewelry-grid {
                grid-template-columns: repeat(3, 1fr);
            }
        }
        
        .jewelry-item {
            background: white;
            border-radius: 12px;
            border: 1px solid var(--color-border);
            overflow: hidden;
            transition: transform 0.2s ease, border-color 0.2s ease;
        }
        
        .jewelry-item:active {
            transform: scale(0.97);
        }
        
        .jewelry-item.active {
            border-color: var(--color-primary);
            background: linear-gradient(to right, var(--color-light), var(--color-surface));
        }
        
        .jewelry-img {
            width: 100%;
            aspect-ratio: 1;
            object-fit: contain;
            padding: 0.5rem;
        }
        
        .jewelry-name {
            font-size: 0.8rem;
            text-align: center;
            padding: 0.5rem;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        
        /* Controls Panel */
        .controls-panel {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: var(--controls-height);
            background-color: var(--color-surface);
            border-radius: var(--sheet-border-radius) var(--sheet-border-radius) 0 0;
            box-shadow: 0 -4px 20px rgba(0, 0, 0, 0.1);
            transition: transform var(--transition-speed) var(--transition-timing);
            z-index: 25;
            overflow: hidden;
        }
        
        .controls-panel.hidden {
            transform: translateY(100%);
        }
        
        .panel-handle {
            height: var(--bottom-sheet-handle-height);
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
        }
        
        .close-btn {
            position: absolute;
            right: 1rem;
            top: 0;
            height: var(--bottom-sheet-handle-height);
            background: none;
            border: none;
            color: var(--color-text);
            font-size: 1rem;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .panel-content {
            height: calc(100% - var(--bottom-sheet-handle-height));
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
            padding: 0 1rem 2rem;
        }
        
        /* Control Styles */
        .control-group {
            margin-bottom: 1.5rem;
        }
        
        .control-label {
            font-size: 0.9rem;
            font-weight: 500;
            margin-bottom: 0.5rem;
            color: var(--color-dark);
        }
        
        .size-control, .position-control, .gap-control {
            padding: 0.5rem 0;
        }
        
        /* Sliders */
        input[type="range"] {
            -webkit-appearance: none;
            appearance: none;
            width: 100%;
            height: 6px;
            background: var(--color-light);
            border-radius: 3px;
            outline: none;
            margin: 1rem 0;
        }
        
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 22px;
            height: 22px;
            background: var(--color-primary);
            border-radius: 50%;
            cursor: pointer;
            transition: all 0.2s ease;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
        }
        
        input[type="range"]::-moz-range-thumb {
            width: 22px;
            height: 22px;
            background: var(--color-primary);
            border-radius: 50%;
            cursor: pointer;
            border: none;
            transition: all 0.2s ease;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
        }
        
        /* Position Controls */
        .position-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
        }
        
        .position-btn {
            background-color: #f1f1f1;
            border: 1px solid var(--color-border);
            border-radius: 8px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1rem;
            color: var(--color-text);
            transition: all 0.2s ease;
        }
        
        .position-btn:active {
            background-color: var(--color-light);
            color: var(--color-primary);
            transform: scale(0.95);
        }
        
        /* Capture Button */
        .capture-btn {
            position: absolute;
            bottom: calc(var(--bottom-sheet-height) + 20px);
            right: 20px;
            width: 60px;
            height: 60px;
            background: var(--color-primary);
            color: white;
            border: none;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
            z-index: 15;
            transition: transform 0.2s ease, background-color 0.2s ease;
        }
        
        .capture-btn:active {
            transform: scale(0.95);
            background-color: var(--color-secondary);
        }
        
        /* Toggle Switch */
        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 50px;
            height: 26px;
        }
        
        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }
        
        .toggle-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            border-radius: 34px;
            transition: .4s;
        }
        
        .toggle-slider:before {
            position: absolute;
            content: "";
            height: 20px;
            width: 20px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            border-radius: 50%;
            transition: .4s;
        }
        
        input:checked + .toggle-slider {
            background-color: var(--color-primary);
        }
        
        input:checked + .toggle-slider:before {
            transform: translateX(24px);
        }
        
        /* Responsive adjustments */
        @media (min-width: 768px) {
            :root {
                --bottom-sheet-height: 25vh;
                --controls-height: 35vh;
            }
            
            .jewelry-grid {
                grid-template-columns: repeat(4, 1fr);
            }
            
            .capture-btn {
                width: 70px;
                height: 70px;
                font-size: 1.8rem;
            }
        }
        
        @media (min-width: 1024px) {
            .bottom-sheet {
                max-width: 600px;
                left: 50%;
                transform: translateX(-50%);
                border-radius: var(--sheet-border-radius);
                height: 40vh;
            }
            
            .controls-panel {
                max-width: 600px;
                left: 50%;
                transform: translateX(-50%);
                border-radius: var(--sheet-border-radius);
            }
            
            .bottom-sheet.hidden {
                transform: translate(-50%, 100%);
            }
            
            .controls-panel.hidden {
                transform: translate(-50%, 100%);
            }
        }
        
        /* Utility Classes */
        .hidden {
            display: none;
        }
        
        .button-primary {
            background: var(--color-primary);
            color: white;
            border: none;
            font-weight: 500;
        }
        
        /* Touch highlight for iOS */
        .touchable {
            -webkit-tap-highlight-color: rgba(0, 0, 0, 0.1);
        }

        /* Add these styles to your existing CSS */

        /* Ensure video fits correctly in container */
        #cameraFeed {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: contain; /* Changed from cover to contain */
            transform: scaleX(-1); /* Mirror the camera */
        }
        
        /* Ensure canvas matches video exactly */
        #jewelryCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: contain; /* Match video element */
            transform: scaleX(-1); /* Mirror to match video */
            pointer-events: none;
        }
        
        /* Camera container with fixed aspect ratio */
        .camera-container {
            flex: 1;
            position: relative;
            background: var(--color-dark);
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        
        /* Create a wrapper around video/canvas with controlled aspect ratio */
        .camera-feed-wrapper {
            position: relative;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
        }
        
        @media (orientation: portrait) {
            .camera-feed-wrapper {
                /* In portrait, constrain width to maintain aspect ratio */
                width: 100%;
                height: auto;
                aspect-ratio: 3/4; /* Common front camera aspect ratio */
            }
        }
        
        @media (orientation: landscape) {
            .camera-feed-wrapper {
                /* In landscape, constrain height to maintain aspect ratio */
                width: auto;
                height: 100%;
                aspect-ratio: 4/3; /* Common front camera aspect ratio */
            }
        }
    </style>
</head>
<body class="bg-gray-100 font-sans overflow-hidden">
    <!-- Loading Screen -->
    <div class="loading-screen" id="loadingScreen">
        <div class="loading-spinner">
            <svg viewBox="0 0 100 50" xmlns="http://www.w3.org/2000/svg">
                <path class="infinity-path" 
                      d="M10,25 C10,5 40,5 50,25 C60,45 90,45 90,25 C90,5 60,5 50,25 C40,45 10,45 10,25 Z" 
                      fill="none" stroke="black" stroke-width="2"/>
                <path class="infinity-highlight" 
                      d="M10,25 C10,5 40,5 50,25 C60,45 90,45 90,25 C90,5 60,5 50,25 C40,45 10,45 10,25 Z" 
                      fill="none" stroke="gray" stroke-width="2"/>
            </svg>
        </div>
        <p class="text-gray-600">Initializing Virtual Try-On Experience...</p>
        <p class="loading-error hidden"></p>
        
        <div class="loading-quote">
            <p class="quote-text">"Style is a way to say who you are without having to speak"</p>
            <p class="quote-author">â€” Rachel Zoe</p>
        </div>
        
        <div class="loading-brand">
            <i class="fas fa-infinity"></i>
            <span class="brand-text">Powered by InfiniteAI</span>
        </div>
    </div>

    <!-- Main App Container -->
    <div class="app-container">
        <!-- Top Navigation Bar -->
        <nav class="top-nav">
            <div class="nav-brand">
                <span>Virtual Try-On</span>
            </div>
            <div class="nav-controls">
                <button id="menuToggleBtn" class="menu-toggle">
                    <i class="fas fa-sliders-h"></i>
                </button>
            </div>
        </nav>

        <!-- Jewelry Category Tabs -->
        <div class="category-tabs">
            <div class="tabs-container">
                <button class="tab-btn active" data-category="face">
                    <i class="fas fa-mask"></i>
                    <span>Face</span>
                </button>
                <button class="tab-btn" data-category="ear">
                    <i class="fas fa-ear"></i>
                    <span>Ear</span>
                </button>
                <button class="tab-btn" data-category="neck">
                    <i class="fas fa-gem"></i>
                    <span>Neck</span>
                </button>
                <button class="tab-btn" data-category="hand">
                    <i class="fas fa-hand-sparkles"></i>
                    <span>Hand</span>
                </button>
                <button class="tab-btn" data-category="active">
                    <i class="fas fa-th-list"></i>
                    <span>Active</span>
                </button>
            </div>
        </div>

        <div class="camera-container">
            <div class="camera-feed-wrapper">
                <video id="cameraFeed" autoplay playsinline></video>
                <canvas id="jewelryCanvas"></canvas>
            </div>
            
            <!-- Camera Error Message -->
            <div class="camera-error hidden" id="cameraError">
                <i class="fas fa-video-slash text-3xl text-red-500 mb-4"></i>
                <h3 class="text-xl font-bold text-gray-800 mb-2">Camera Access Required</h3>
                <p class="text-gray-600 mb-4">Please allow camera access to use the virtual try-on experience.</p>
                <button onclick="requestCameraAccess()" class="button-primary px-6 py-2 rounded-lg text-white">
                    Enable Camera
                </button>
            </div>
        </div>

        <!-- Bottom Sheet for Jewelry Selection -->
        <div class="bottom-sheet" id="jewelrySheet">
            <div class="sheet-handle">
                <div class="handle-bar"></div>
            </div>
            <div class="sheet-content">
                <h3 class="sheet-title" id="sheetTitle">Select Jewelry</h3>
                
                <!-- Container for jewelry items (populated by JS) -->
                <div class="jewelry-grid" id="jewelryGrid"></div>
            </div>
        </div>

        <!-- Bottom Controls for Selected Jewelry -->
        <div class="controls-panel hidden" id="controlsPanel">
            <div class="panel-handle">
                <div class="handle-bar"></div>
                <button id="closeControlsBtn" class="close-btn">
                    <i class="fas fa-times"></i>
                </button>
            </div>
            <div class="panel-content" id="controlsContent">
                <!-- Controls will be populated dynamically -->
            </div>
        </div>

        <!-- Capture Button -->
        <button class="capture-btn" id="captureBtn">
            <i class="fas fa-camera"></i>
        </button>
    </div>

    <script>
        const JEWELRY = {
            // Face jewelry (tikka)
            tikka1: {
                name: "Tikka Design 1",
                type: 'single',
                image: 'tikka1.png',
                thumbnail: 'thumbnails/tikka1-thumb.png',
                landmark: 151,
                offset: { x: 0, y: 0 },
                defaultScale: 1.3,
                group: 'face',
                category: 'Face Jewelry'
            },
            tikka2: {
                name: "Tikka Design 2",
                type: 'single',
                image: 'tikka2.png',
                thumbnail: 'thumbnails/tikka2-thumb.png',
                landmark: 151,
                offset: { x: 0, y: 0 },
                defaultScale: 1,
                group: 'face',
                category: 'Face Jewelry'
            },
            tikka3: {
                name: "Tikka Design 3",
                type: 'single',
                image: 'tikka3.png',
                thumbnail: 'thumbnails/tikka3-thumb.png',
                landmark: 151,
                offset: { x: 0, y: 0 },
                defaultScale: 1,
                group: 'face',
                category: 'Face Jewelry'
            },
            tikka4: {
                name: "Tikka Design 4",
                type: 'single',
                image: 'tikka4.png',
                thumbnail: 'thumbnails/tikka4-thumb.png',
                landmark: 151,
                offset: { x: 0, y: 0 },
                defaultScale: 0.8,
                group: 'face',
                category: 'Face Jewelry'
            },
            
            // Ear jewelry (jhumka/earrings)
            jhumka1: {
                name: "Earring Design 1",
                type: 'earrings',
                left: 'earing1left.png',
                right: 'earing1right.png',
                thumbnail: 'thumbnails/earring1-thumb.png',
                landmarks: [177, 401],
                offset: { x: 0, y: 0 },
                defaultScale: 0.75,
                gap: 0,
                group: 'ear',
                category: 'Ear Jewelry'
            },
            jhumka2: {
                name: "Earring Design 2",
                type: 'earrings',
                left: 'earing2left.png',
                right: 'earing2right.png',
                thumbnail: 'thumbnails/earring2-thumb.png',
                landmarks: [177, 401],
                offset: { x: 0, y: 0 },
                defaultScale: 1.5,
                gap: 0,
                group: 'ear',
                category: 'Ear Jewelry'
            },
            jhumka3: {
                name: "Earring Design 3",
                type: 'earrings',
                left: 'earing3left.png',
                right: 'earing3right.png',
                thumbnail: 'thumbnails/earring3-thumb.png',
                landmarks: [177, 401],
                offset: { x: 0, y: 0 },
                defaultScale: 1.5,
                gap: 0,
                group: 'ear',
                category: 'Ear Jewelry'
            },
            jhumka4: {
                name: "Earring Design 4",
                type: 'earrings',
                left: 'earing4left.png',
                right: 'earing4right.png',
                thumbnail: 'thumbnails/earring4-thumb.png',
                landmarks: [177, 401],
                offset: { x: 0, y: 0 },
                defaultScale: 1.5,
                gap: 0,
                group: 'ear',
                category: 'Ear Jewelry'
            },
            
            // Neck jewelry (necklaces)
            necklace1: {
                name: "Necklace Design 1",
                type: 'necklace',
                image: 'necklace1.png',
                thumbnail: 'thumbnails/necklace1-thumb.png',
                offset: { x: 0, y: 0 },
                defaultScale: 0.55,
                group: 'neck',
                category: 'Neck Jewelry'
            },
            necklace2: {
                name: "Necklace Design 2",
                type: 'necklace',
                image: 'necklace2.png',
                thumbnail: 'thumbnails/necklace2-thumb.png',
                offset: { x: 0, y: 0 },
                defaultScale: 0.55,
                group: 'neck',
                category: 'Neck Jewelry'
            },
            necklace3: {
                name: "Necklace Design 3",
                type: 'necklace',
                image: 'necklace3.png',
                thumbnail: 'thumbnails/necklace3-thumb.png',
                offset: { x: 0, y: 0 },
                defaultScale: 0.55,
                group: 'neck',
                category: 'Neck Jewelry'
            },
            necklace4: {
                name: "Necklace Design 4",
                type: 'necklace',
                image: 'necklace4.png',
                thumbnail: 'thumbnails/necklace4-thumb.png',
                offset: { x: 0, y: 0 },
                defaultScale: 0.4,
                group: 'neck',
                category: 'Neck Jewelry'
            },
            necklace5: {
                name: "Necklace Design 5",
                type: 'necklace',
                image: 'necklace5.png',
                thumbnail: 'thumbnails/necklace5-thumb.png',
                offset: { x: 0, y: 0 },
                defaultScale: 0.4,
                group: 'neck',
                category: 'Neck Jewelry'
            },
            necklace6: {
                name: "Necklace Design 6",
                type: 'necklace',
                image: 'necklace6.png',
                thumbnail: 'thumbnails/necklace6-thumb.png',
                offset: { x: 0, y: 0 },
                defaultScale: 0.4,
                group: 'neck',
                category: 'Neck Jewelry'
            },
            necklace7: {
                name: "Necklace Design 7",
                type: 'necklace',
                image: 'necklace7.png',
                thumbnail: 'thumbnails/necklace7-thumb.png',
                offset: { x: 0, y: 0 },
                defaultScale: 0.4,
                group: 'neck',
                category: 'Neck Jewelry'
            },
            
            // Hand jewelry (rings, bangles)
            ring1: {
                name: "Ring Design",
                type: 'hand',
                image: 'ring1.png',
                thumbnail: 'thumbnails/ring1-thumb.png',
                landmark: 'custom',
                fingerIndex: 8,
                handIndex: 0,
                offset: { x: 0, y: 0 },
                defaultScale: 0.2,
                group: 'hand',
                category: 'Hand Jewelry'
            },
            bangle1: {
                name: "Bangle Design 1",
                type: 'hand',
                image: 'bangle1.png',
                thumbnail: 'thumbnails/bangle1-thumb.png',
                landmark: 'custom',
                wristIndex: 0,
                handIndex: 0,
                offset: { x: 0, y: 0 },
                defaultScale: 0.35,
                group: 'hand',
                category: 'Hand Jewelry'
            },
            bangle2: {
                name: "Bangle Design 2",
                type: 'hand',
                image: 'bangle2.png',
                thumbnail: 'thumbnails/bangle2-thumb.png',
                landmark: 'custom',
                wristIndex: 0,
                handIndex: 0,
                offset: { x: 0, y: 0 },
                defaultScale: 0.35,
                group: 'hand',
                category: 'Hand Jewelry'
            },
            bangle3: {
                name: "Bangle Design 3",
                type: 'hand',
                image: 'bangle3.png',
                thumbnail: 'thumbnails/bangle3-thumb.png',
                landmark: 'custom',
                wristIndex: 0,
                handIndex: 0,
                offset: { x: 0, y: 0 },
                defaultScale: 0.35,
                group: 'hand',
                category: 'Hand Jewelry'
            }
        };

        const LANDMARKS = {
            tikka: {
                center: 151,
                top: 10,
                reference: 9
            },
            earrings: {
                leftLobe: 58,
                rightLobe: 288,
                leftRef: 234,
                rightRef: 454
            }
        };

        // App State
        let appState = {
            activeJewelry: new Map(),
            currentCategory: 'face',
            selectedJewelryId: null,
            isControlsPanelOpen: false,
            isBottomSheetExpanded: false,
            sheetStartY: 0,
            sheetCurrentY: 0,
            isDragging: false,
            faceLandmarks: null,
            handLandmarks: null,
            poseLandmarks: null,
            isCameraReady: false,
            isResourcesLoaded: false,
            isInitialized: false
        };

        // DOM Elements
        let elements = {
            video: null,
            canvas: null,
            ctx: null,
            loadingScreen: null,
            jewelrySheet: null,
            controlsPanel: null,
            captureBtn: null,
            categoryBtns: null,
            jewelryGrid: null,
            controlsContent: null
        };

        // MediaPipe Models
        let faceMesh, hands, pose;

        // Camera constants
        const MAX_CAMERA_HEIGHT = 1280;
        const MAX_CAMERA_WIDTH = 720;
        const ASPECT_RATIO = MAX_CAMERA_WIDTH / MAX_CAMERA_HEIGHT;

        // Initialization
        document.addEventListener('DOMContentLoaded', init);

        async function init() {
            try {
                console.log("Starting initialization...");
                updateLoadingStatus("Initializing...");
                
                // Get DOM elements
                initializeElements();
                
                // Setup gesture handlers
                setupEventListeners();
                
                // Initialize camera
                await initializeCamera();
                
                // Initialize MediaPipe models
                await initializeAIModels();
                
                // Preload jewelry images
                await preloadJewelryImages();
                
                // Initialize UI
                initializeUI();
                
                // Start detection loop
                appState.isInitialized = true;
                requestAnimationFrame(detectAll);
                
                // Hide loading screen
                hideLoadingScreen();
                
                console.log("Initialization complete!");
            } catch (error) {
                console.error("Initialization error:", error);
                showError(error.message || "Error initializing app. Please refresh the page.");
            }
        }

        // Helper for loading status updates
        function updateLoadingStatus(message) {
            const loadingScreen = document.getElementById('loadingScreen');
            const statusText = loadingScreen.querySelector('p:not(.loading-error)');
            if (statusText) {
                statusText.textContent = message;
            }
        }

        function showError(message) {
            const loadingScreen = document.getElementById('loadingScreen');
            const errorElement = loadingScreen.querySelector('.loading-error');
            if (errorElement) {
                errorElement.textContent = message;
                errorElement.classList.remove('hidden');
            }
        }

        function hideLoadingScreen() {
            document.getElementById('loadingScreen').classList.add('hidden');
        }

        // Initialize DOM elements
        function initializeElements() {
            elements.video = document.getElementById('cameraFeed');
            elements.canvas = document.getElementById('jewelryCanvas');
            elements.ctx = elements.canvas.getContext('2d');
            elements.loadingScreen = document.getElementById('loadingScreen');
            elements.jewelrySheet = document.getElementById('jewelrySheet');
            elements.controlsPanel = document.getElementById('controlsPanel');
            elements.captureBtn = document.getElementById('captureBtn');
            elements.categoryBtns = document.querySelectorAll('.tab-btn');
            elements.jewelryGrid = document.getElementById('jewelryGrid');
            elements.controlsContent = document.getElementById('controlsContent');
            elements.sheetTitle = document.getElementById('sheetTitle');
            
            if (!elements.video || !elements.canvas || !elements.ctx) {
                throw new Error("Required elements not found");
            }
        }

        // Setup event listeners for UI
        function setupEventListeners() {
            // Category tab buttons
            elements.categoryBtns.forEach(btn => {
                btn.addEventListener('click', () => {
                    const category = btn.dataset.category;
                    switchCategory(category);
                });
            });
            
            // Capture button
            elements.captureBtn.addEventListener('click', captureImage);
            
            // Bottom sheet handle
            setupBottomSheetDrag();
            
            // Controls panel close button
            document.getElementById('closeControlsBtn').addEventListener('click', () => {
                toggleControlsPanel(false);
            });
        }

        // Initialize camera
        async function initializeCamera() {
            try {
                updateLoadingStatus("Accessing camera...");
                
                // Check if this is a mobile device
                const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
                
                // Default constraints - no zoom
                const constraints = {
                    video: {
                        facingMode: 'user',
                        width: { ideal: isMobile ? window.innerWidth : MAX_CAMERA_WIDTH },
                        height: { ideal: isMobile ? window.innerHeight : MAX_CAMERA_HEIGHT },
                        // Explicitly set zoom to 1 (no zoom)
                        advanced: [
                            { zoom: 1.0 }
                        ]
                    }
                };
                
                // For iOS devices, we need to be more specific with constraints
                if (/iPhone|iPad|iPod/.test(navigator.userAgent)) {
                    constraints.video.width = { min: 640, ideal: 1280, max: 1920 };
                    constraints.video.height = { min: 480, ideal: 720, max: 1080 };
                    // iOS specific constraint
                    if ("frameRate" in MediaTrackConstraints.prototype) {
                        constraints.video.frameRate = { max: 30 };
                    }
                }
                
                const stream = await navigator.mediaDevices.getUserMedia(constraints);
                elements.video.srcObject = stream;
                
                // After getting the stream, try to set zoom to 1x if available on the track
                const videoTrack = stream.getVideoTracks()[0];
                if (videoTrack) {
                    try {
                        const capabilities = videoTrack.getCapabilities();
                        // Only attempt to set zoom if the camera supports it
                        if (capabilities && capabilities.zoom) {
                            const settings = {
                                zoom: 1.0  // 1.0 means no zoom
                            };
                            await videoTrack.applyConstraints({ advanced: [settings] });
                            console.log("Applied 1x zoom constraint");
                        }
                    } catch (zoomError) {
                        console.warn("Could not set zoom level:", zoomError);
                        // Continue anyway - this is not critical
                    }
                }
                
                await new Promise((resolve) => {
                    elements.video.onloadedmetadata = () => {
                        elements.canvas.width = elements.video.videoWidth;
                        elements.canvas.height = elements.video.videoHeight;
                        console.log("Video dimensions:", elements.video.videoWidth, elements.video.videoHeight);
                        appState.isCameraReady = true;
                        resolve();
                    };
                });
                
                await elements.video.play();
                console.log("Camera initialized successfully");
                
            } catch (error) {
                console.error("Camera access error:", error);
                document.getElementById('cameraError').classList.remove('hidden');
                throw new Error("Camera access denied. Please enable camera permissions.");
            }
        }

        // Initialize AI models
        async function initializeAIModels() {
            try {
                updateLoadingStatus("Loading AI models...");
                
                // Initialize FaceMesh
                faceMesh = new FaceMesh({
                    locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh@0.4.1633559619/${file}`
                });
                
                // Initialize Hands
                hands = new Hands({
                    locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1646424915/${file}`
                });
                
                // Initialize Pose
                pose = new Pose({
                    locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/pose@0.5.1675469404/${file}`
                });
                
                // Configure models - use lighter settings for mobile
                faceMesh.setOptions({
                    maxNumFaces: 1,
                    refineLandmarks: true,
                    minDetectionConfidence: 0.5,
                    minTrackingConfidence: 0.5
                });
                
                hands.setOptions({
                    maxNumHands: 2,
                    modelComplexity: 0, // Use lighter model for mobile
                    minDetectionConfidence: 0.5,
                    minTrackingConfidence: 0.5
                });
                
                pose.setOptions({
                    modelComplexity: 0, // Use lighter model for mobile
                    smoothLandmarks: true,
                    minDetectionConfidence: 0.5,
                    minTrackingConfidence: 0.5
                });
                
                // Set up callbacks
                faceMesh.onResults(onFaceMeshResults);
                hands.onResults(onHandResults);
                pose.onResults(onPoseResults);
                
                // Initialize models
                updateLoadingStatus("Loading face detection...");
                await faceMesh.initialize();
                
                updateLoadingStatus("Loading hand detection...");
                await hands.initialize();
                
                updateLoadingStatus("Loading pose detection...");
                await pose.initialize();
                
                console.log("AI models initialized successfully");
                return true;
            } catch (error) {
                console.error("Model initialization error:", error);
                throw new Error("Failed to initialize AI models. Please try refreshing the page.");
            }
        }

        // Preload jewelry images
        async function preloadJewelryImages() {
            updateLoadingStatus("Loading jewelry assets...");
            const preloadPromises = [];
            
            for (const [id, jewelry] of Object.entries(JEWELRY)) {
                try {
                    if (jewelry.type === 'earrings') {
                        const leftImg = new Image();
                        const rightImg = new Image();
                        
                        leftImg.src = jewelry.left;
                        rightImg.src = jewelry.right;
                        
                        const leftPromise = new Promise((resolve, reject) => {
                            leftImg.onload = resolve;
                            leftImg.onerror = () => reject(new Error(`Failed to load ${jewelry.left}`));
                        });
                        
                        const rightPromise = new Promise((resolve, reject) => {
                            rightImg.onload = resolve;
                            rightImg.onerror = () => reject(new Error(`Failed to load ${jewelry.right}`));
                        });
                        
                        preloadPromises.push(Promise.all([leftPromise, rightPromise])
                            .then(() => {
                                jewelry.leftImage = leftImg;
                                jewelry.rightImage = rightImg;
                            }));
                    } else {
                        const img = new Image();
                        img.src = jewelry.image;
                        
                        const imgPromise = new Promise((resolve, reject) => {
                            img.onload = resolve;
                            img.onerror = () => reject(new Error(`Failed to load ${jewelry.image}`));
                        });
                        
                        preloadPromises.push(imgPromise.then(() => {
                            jewelry.loadedImage = img;
                        }));
                    }
                    
                    // Also preload thumbnail
                    if (jewelry.thumbnail) {
                        const thumbImg = new Image();
                        thumbImg.src = jewelry.thumbnail;
                        
                        const thumbPromise = new Promise((resolve) => {
                            thumbImg.onload = resolve;
                            thumbImg.onerror = resolve; // Continue even if thumbnail fails
                        });
                        
                        preloadPromises.push(thumbPromise.then(() => {
                            jewelry.thumbnailImage = thumbImg;
                        }));
                    }
                } catch (error) {
                    console.warn(`Error setting up preload for ${id}:`, error);
                }
            }
            
            // Wait for all preload promises with a timeout for mobile
            try {
                await Promise.all(preloadPromises);
                console.log("All jewelry images preloaded successfully");
            } catch (error) {
                console.warn("Some images failed to preload:", error);
                // Continue anyway - we'll handle missing images gracefully
            }
            
            appState.isResourcesLoaded = true;
        }

        // Initialize UI
        function initializeUI() {
            // Show the first category by default
            switchCategory('face');
            
            // Set up bottom sheet initial state
            const bottomSheetHeight = parseInt(getComputedStyle(document.documentElement)
                .getPropertyValue('--bottom-sheet-height'));
            elements.jewelrySheet.style.transform = `translateY(0)`;
            
            // Update capture button position based on bottom sheet
            updateCaptureButtonPosition();
        }

        // Bottom sheet drag functionality
        function setupBottomSheetDrag() {
            const sheetHandle = elements.jewelrySheet.querySelector('.sheet-handle');
            const controlsHandle = elements.controlsPanel.querySelector('.panel-handle');
            
            // For bottom sheet
            sheetHandle.addEventListener('touchstart', handleDragStart);
            sheetHandle.addEventListener('touchmove', handleDragMove);
            sheetHandle.addEventListener('touchend', handleDragEnd);
            
            // For controls panel
            controlsHandle.addEventListener('touchstart', handleControlsDragStart);
            controlsHandle.addEventListener('touchmove', handleControlsDragMove);
            controlsHandle.addEventListener('touchend', handleControlsDragEnd);
        }

        function handleDragStart(e) {
            appState.isDragging = true;
            appState.sheetStartY = e.touches[0].clientY;
            appState.sheetCurrentY = 0;
            elements.jewelrySheet.style.transition = 'none';
        }

        function handleDragMove(e) {
            if (!appState.isDragging) return;
            
            const currentY = e.touches[0].clientY;
            const deltaY = currentY - appState.sheetStartY;
            
            // Only allow dragging down from normal position or up from expanded position
            if ((!appState.isBottomSheetExpanded && deltaY < 0) || 
                (appState.isBottomSheetExpanded && deltaY > 0)) {
                appState.sheetCurrentY = deltaY;
                const newTransform = `translateY(${deltaY}px)`;
                elements.jewelrySheet.style.transform = newTransform;
            }
        }

        function handleDragEnd() {
            if (!appState.isDragging) return;
            appState.isDragging = false;
            elements.jewelrySheet.style.transition = 'transform 0.3s cubic-bezier(0.4, 0, 0.2, 1)';
            
            // Determine whether to expand or collapse
            const threshold = 50; // Pixels to trigger action
            
            if (!appState.isBottomSheetExpanded && appState.sheetCurrentY < -threshold) {
                // Expand sheet
                expandBottomSheet(true);
            } else if (appState.isBottomSheetExpanded && appState.sheetCurrentY > threshold) {
                // Collapse sheet
                expandBottomSheet(false);
            } else {
                // Return to original position
                elements.jewelrySheet.style.transform = appState.isBottomSheetExpanded ? 
                    'translateY(0)' : 'translateY(0)';
            }
        }

        // Controls panel drag handlers
        function handleControlsDragStart(e) {
            appState.isDragging = true;
            appState.sheetStartY = e.touches[0].clientY;
            appState.sheetCurrentY = 0;
            elements.controlsPanel.style.transition = 'none';
        }

        function handleControlsDragMove(e) {
            if (!appState.isDragging) return;
            
            const currentY = e.touches[0].clientY;
            const deltaY = currentY - appState.sheetStartY;
            
            // Only allow dragging down (to dismiss)
            if (deltaY > 0) {
                appState.sheetCurrentY = deltaY;
                const newTransform = `translateY(${deltaY}px)`;
                elements.controlsPanel.style.transform = newTransform;
            }
        }

        function handleControlsDragEnd() {
            if (!appState.isDragging) return;
            appState.isDragging = false;
            elements.controlsPanel.style.transition = 'transform 0.3s cubic-bezier(0.4, 0, 0.2, 1)';
            
            // Determine whether to close
            const threshold = 80; // Pixels to trigger close
            
            if (appState.sheetCurrentY > threshold) {
                // Close controls panel
                toggleControlsPanel(false);
            } else {
                // Return to original position
                elements.controlsPanel.style.transform = 'translateY(0)';
            }
        }

        // Expand/collapse bottom sheet
        function expandBottomSheet(expand) {
            appState.isBottomSheetExpanded = expand;
            if (expand) {
                elements.jewelrySheet.classList.add('expanded');
                elements.jewelrySheet.style.transform = 'translateY(0)';
            } else {
                elements.jewelrySheet.classList.remove('expanded');
                elements.jewelrySheet.style.transform = 'translateY(0)';
            }
            updateCaptureButtonPosition();
        }

        // Update capture button position based on bottom sheet state
        function updateCaptureButtonPosition() {
            const sheet = elements.jewelrySheet;
            const sheetHeight = parseInt(getComputedStyle(document.documentElement)
                .getPropertyValue(appState.isBottomSheetExpanded ? 
                    '--bottom-sheet-height-expanded' : '--bottom-sheet-height'));
            
            elements.captureBtn.style.bottom = `calc(${sheetHeight}px + 20px)`;
        }

        // Toggle controls panel
        function toggleControlsPanel(show, jewelryId = null) {
            if (show) {
                appState.isControlsPanelOpen = true;
                appState.selectedJewelryId = jewelryId;
                elements.controlsPanel.style.transform = 'translateY(0)';
                elements.controlsPanel.classList.remove('hidden');
                renderControlsForJewelry(jewelryId);
            } else {
                appState.isControlsPanelOpen = false;
                elements.controlsPanel.style.transform = 'translateY(100%)';
                // Use a timeout to add the hidden class after the animation
                setTimeout(() => {
                    if (!appState.isControlsPanelOpen) {
                        elements.controlsPanel.classList.add('hidden');
                    }
                }, 300);
            }
        }

        // Switch category tab
        function switchCategory(category) {
            appState.currentCategory = category;
            
            // Update tab buttons
            elements.categoryBtns.forEach(btn => {
                if (btn.dataset.category === category) {
                    btn.classList.add('active');
                } else {
                    btn.classList.remove('active');
                }
            });
            
            // Update title and contents based on category
            if (category === 'active') {
                renderActiveJewelry();
                elements.sheetTitle.textContent = 'Active Jewelry';
            } else {
                renderJewelryByCategory(category);
                elements.sheetTitle.textContent = `${category.charAt(0).toUpperCase() + category.slice(1)} Jewelry`;
            }
        }

        // Render jewelry grid by category
        function renderJewelryByCategory(category) {
            const grid = elements.jewelryGrid;
            grid.innerHTML = '';
            
            // Filter jewelry by category
            const categoryJewelry = Object.entries(JEWELRY)
                .filter(([_, item]) => item.group === category);
            
            if (categoryJewelry.length === 0) {
                grid.innerHTML = '<p class="text-center py-4 text-gray-500">No items available in this category</p>';
                return;
            }
            
            // Create jewelry items
            categoryJewelry.forEach(([id, jewelry]) => {
                const isActive = appState.activeJewelry.has(id);
                const item = document.createElement('div');
                item.className = `jewelry-item ${isActive ? 'active' : ''}`;
                
                // Thumbnail image path
                const thumbSrc = jewelry.thumbnail || 
                    (jewelry.type === 'earrings' ? 
                        jewelry.left.replace('.png', '-thumb.png') : 
                        jewelry.image.replace('.png', '-thumb.png'));
                
                item.innerHTML = `
                    <img src="${thumbSrc}" alt="${jewelry.name}" class="jewelry-img">
                    <div class="jewelry-name">${jewelry.name}</div>
                `;
                
                item.addEventListener('click', () => handleJewelryItemClick(id));
                grid.appendChild(item);
            });
        }

        // Render active jewelry items
        function renderActiveJewelry() {
            const grid = elements.jewelryGrid;
            grid.innerHTML = '';
            
            if (appState.activeJewelry.size === 0) {
                grid.innerHTML = '<p class="text-center py-4 text-gray-500">No active jewelry items. Select items from the category tabs.</p>';
                return;
            }
            
            // Create active jewelry items
            appState.activeJewelry.forEach((jewelry, id) => {
                const originalJewelry = JEWELRY[id];
                const item = document.createElement('div');
                item.className = 'jewelry-item active';
                
                // Use the correct thumbnail
                const thumbSrc = originalJewelry.thumbnail || 
                    (originalJewelry.type === 'earrings' ? 
                        originalJewelry.left.replace('.png', '-thumb.png') : 
                        originalJewelry.image.replace('.png', '-thumb.png'));
                
                item.innerHTML = `
                    <img src="${thumbSrc}" alt="${originalJewelry.name}" class="jewelry-img">
                    <div class="jewelry-name">${originalJewelry.name}</div>
                    <div class="mx-auto mt-2 flex justify-center">
                        <button class="adjust-btn bg-purple-100 text-purple-700 px-3 py-1 rounded-l-lg">
                            <i class="fas fa-sliders-h"></i>
                        </button>
                        <button class="remove-btn bg-red-100 text-red-700 px-3 py-1 rounded-r-lg">
                            <i class="fas fa-trash"></i>
                        </button>
                    </div>
                `;
                
                // Add event listeners
                item.querySelector('.adjust-btn').addEventListener('click', (e) => {
                    e.stopPropagation();
                    toggleControlsPanel(true, id);
                });
                
                item.querySelector('.remove-btn').addEventListener('click', (e) => {
                    e.stopPropagation();
                    removeJewelry(id);
                    renderActiveJewelry(); // Refresh the active items list
                });
                
                grid.appendChild(item);
            });
        }

        // Handle jewelry item click
        function handleJewelryItemClick(id) {
            const originalJewelry = JEWELRY[id];
            
            // Check if this jewelry is already active
            if (appState.activeJewelry.has(id)) {
                // Open controls for this jewelry
                toggleControlsPanel(true, id);
            } else {
                // Add new jewelry
                addJewelry(id);
                
                // Update the UI
                const categoryItems = document.querySelectorAll('.jewelry-item');
                categoryItems.forEach(item => {
                    const itemName = item.querySelector('.jewelry-name').textContent;
                    if (itemName === originalJewelry.name) {
                        item.classList.add('active');
                    }
                });
                
                // Show controls panel for the newly added jewelry
                toggleControlsPanel(true, id);
            }
        }

        // AI detection loop
        async function detectAll() {
            if (!appState.isInitialized || !appState.isCameraReady) {
                requestAnimationFrame(detectAll);
                return;
            }
        
            if (!elements.video.videoWidth) {
                console.log("Video not ready yet");
                requestAnimationFrame(detectAll);
                return;
            }
        
            try {
                await Promise.all([
                    faceMesh.send({image: elements.video}),
                    hands.send({image: elements.video}),
                    pose.send({image: elements.video})
                ]);
            } catch (error) {
                console.error("Detection error:", error);
            }
            
            requestAnimationFrame(detectAll);
        }
        
        // MediaPipe result handlers
        function onFaceMeshResults(results) {
            appState.faceLandmarks = results.multiFaceLandmarks && results.multiFaceLandmarks.length > 0 
                ? results.multiFaceLandmarks[0] 
                : null;
            
            renderJewelry();
        }
        
        function onHandResults(results) {
            appState.handLandmarks = results.multiHandLandmarks || [];
            renderJewelry();
        }
        
        function onPoseResults(results) {
            appState.poseLandmarks = results.poseLandmarks || null;
            renderJewelry();
        }
        
        // Main rendering function
        function renderJewelry() {
            if (!elements.canvas || !elements.ctx) return;
            
            // Make sure canvas dimensions match video
            if (elements.canvas.width !== elements.video.videoWidth || 
                elements.canvas.height !== elements.video.videoHeight) {
                elements.canvas.width = elements.video.videoWidth;
                elements.canvas.height = elements.video.videoHeight;
            }
            
            // Clear canvas
            elements.ctx.clearRect(0, 0, elements.canvas.width, elements.canvas.height);
            
            // Nothing to render if no jewelry or no landmarks
            if (appState.activeJewelry.size === 0) return;
            
            // Render each active jewelry item
            appState.activeJewelry.forEach((jewelry, id) => {
                if (jewelry.type === 'necklace') {
                    if (appState.poseLandmarks) {
                        drawNecklace(jewelry, id);
                    }
                } else if (jewelry.type === 'earrings') {
                    if (appState.faceLandmarks) {
                        drawEarrings(jewelry, id);
                    }
                } else if (jewelry.type === 'single') { // tikka, etc.
                    if (appState.faceLandmarks) {
                        drawSinglePiece(jewelry, id);
                    }
                } else if (jewelry.type === 'hand') {
                    if (appState.handLandmarks && appState.handLandmarks.length > 0) {
                        if (id.startsWith('ring')) {
                            drawRing(jewelry, id);
                        } else if (id.startsWith('bangle')) {
                            drawBangle(jewelry, id);
                        }
                    }
                }
            });
        }
        
        // Add/remove/update jewelry items
        function addJewelry(id) {
            const originalJewelry = JEWELRY[id];
            if (!originalJewelry) return;
            
            // Create a deep copy of the jewelry item with loaded images
            const jewelryCopy = JSON.parse(JSON.stringify(originalJewelry));
            
            // Add loaded images (which can't be JSON stringified)
            if (originalJewelry.type === 'earrings') {
                jewelryCopy.leftImage = originalJewelry.leftImage;
                jewelryCopy.rightImage = originalJewelry.rightImage;
            } else {
                jewelryCopy.loadedImage = originalJewelry.loadedImage;
            }
            
            // Initialize with default values
            jewelryCopy.scale = originalJewelry.defaultScale;
            jewelryCopy.offset = { x: 0, y: 0 };
            jewelryCopy.visible = true;
            
            // For hand jewelry, set default hand and finger
            if (originalJewelry.type === 'hand') {
                jewelryCopy.handIndex = 0; // Default to first detected hand
            }
            
            // Add to active jewelry
            appState.activeJewelry.set(id, jewelryCopy);
            
            // Re-render category if it's the current one
            if (originalJewelry.group === appState.currentCategory) {
                renderJewelryByCategory(appState.currentCategory);
            }
        }
        
        function removeJewelry(id) {
            // Remove from active jewelry
            appState.activeJewelry.delete(id);
            
            // If controls panel is open for this jewelry, close it
            if (appState.selectedJewelryId === id && appState.isControlsPanelOpen) {
                toggleControlsPanel(false);
            }
            
            // Re-render active category or current category
            if (appState.currentCategory === 'active') {
                renderActiveJewelry();
            } else {
                const jewelry = JEWELRY[id];
                if (jewelry && jewelry.group === appState.currentCategory) {
                    renderJewelryByCategory(appState.currentCategory);
                }
            }
        }
        
        function updateJewelryProperty(id, property, value) {
            if (!appState.activeJewelry.has(id)) return;
            
            const jewelry = appState.activeJewelry.get(id);
            
            // Handle nested properties like offset.x
            if (property.includes('.')) {
                const [parent, child] = property.split('.');
                jewelry[parent][child] = value;
            } else {
                jewelry[property] = value;
            }
        }
        
        // Controls panel rendering
        function renderControlsForJewelry(id) {
            if (!id || !appState.activeJewelry.has(id)) return;
            
            const jewelry = appState.activeJewelry.get(id);
            const originalJewelry = JEWELRY[id];
            const controlsContent = elements.controlsContent;
            
            // Clear previous controls
            controlsContent.innerHTML = '';
            
            // Add jewelry name and thumbnail
            const thumbSrc = originalJewelry.thumbnail || 
                (originalJewelry.type === 'earrings' ? originalJewelry.left.replace('.png', '-thumb.png') : 
                    originalJewelry.image.replace('.png', '-thumb.png'));
            
            const headerHTML = `
                <div class="flex items-center mb-4">
                    <img src="${thumbSrc}" alt="${originalJewelry.name}" class="w-12 h-12 object-contain mr-3">
                    <h3 class="text-lg font-semibold">${originalJewelry.name}</h3>
                </div>
            `;
            
            // Visibility toggle
            const visibilityHTML = `
                <div class="control-group">
                    <div class="flex justify-between items-center">
                        <label class="control-label">Visibility</label>
                        <label class="toggle-switch">
                            <input type="checkbox" ${jewelry.visible !== false ? 'checked' : ''} 
                                onchange="updateJewelryProperty('${id}', 'visible', this.checked)">
                            <span class="toggle-slider"></span>
                        </label>
                    </div>
                </div>
            `;
            
            // Size control
            const sizeHTML = `
                <div class="control-group">
                    <label class="control-label">Size</label>
                    <div class="size-control">
                        <input type="range" min="0.1" max="2.0" step="0.05" value="${jewelry.scale}" 
                            oninput="updateJewelryProperty('${id}', 'scale', parseFloat(this.value))">
                    </div>
                </div>
            `;
            
            // Position adjustment
            const positionHTML = `
                <div class="control-group">
                    <label class="control-label">Position Adjustment</label>
                    <div class="position-control">
                        <div class="position-grid">
                            <button class="position-btn" onclick="moveJewelry('${id}', 'up-left')">â†–</button>
                            <button class="position-btn" onclick="moveJewelry('${id}', 'up')">â†‘</button>
                            <button class="position-btn" onclick="moveJewelry('${id}', 'up-right')">â†—</button>
                            <button class="position-btn" onclick="moveJewelry('${id}', 'left')">â†</button>
                            <button class="position-btn" onclick="moveJewelry('${id}', 'center')">â€¢</button>
                            <button class="position-btn" onclick="moveJewelry('${id}', 'right')">â†’</button>
                            <button class="position-btn" onclick="moveJewelry('${id}', 'down-left')">â†™</button>
                            <button class="position-btn" onclick="moveJewelry('${id}', 'down')">â†“</button>
                            <button class="position-btn" onclick="moveJewelry('${id}', 'down-right')">â†˜</button>
                        </div>
                    </div>
                </div>
            `;
            
            // Build specialized controls for different jewelry types
            let specializedControls = '';
            
            if (jewelry.type === 'earrings') {
                specializedControls = `
                    <div class="control-group">
                        <label class="control-label">Width Adjustment</label>
                        <div class="gap-control">
                            <input type="range" min="-50" max="50" step="1" value="${jewelry.gap || 0}" 
                                oninput="updateJewelryProperty('${id}', 'gap', parseInt(this.value))">
                        </div>
                    </div>
                `;
            } else if (jewelry.type === 'hand' && id.startsWith('ring')) {
                // Finger selection for rings
                specializedControls = `
                    <div class="control-group">
                        <label class="control-label">Finger Selection</label>
                        <select class="w-full p-2 border rounded-lg my-2" 
                            onchange="updateJewelryProperty('${id}', 'fingerIndex', parseInt(this.value))">
                            <option value="8" ${jewelry.fingerIndex === 8 ? 'selected' : ''}>Index Finger</option>
                            <option value="12" ${jewelry.fingerIndex === 12 ? 'selected' : ''}>Middle Finger</option>
                            <option value="16" ${jewelry.fingerIndex === 16 ? 'selected' : ''}>Ring Finger</option>
                            <option value="20" ${jewelry.fingerIndex === 20 ? 'selected' : ''}>Pinky Finger</option>
                            <option value="4" ${jewelry.fingerIndex === 4 ? 'selected' : ''}>Thumb</option>
                        </select>
                    </div>
                `;
            } else if (jewelry.type === 'hand') {
                // Hand selection for other hand jewelry
                specializedControls = `
                    <div class="control-group">
                        <label class="control-label">Hand Selection</label>
                        <select class="w-full p-2 border rounded-lg my-2" 
                            onchange="updateJewelryProperty('${id}', 'handIndex', parseInt(this.value))">
                            <option value="0" ${jewelry.handIndex === 0 ? 'selected' : ''}>Right Hand</option>
                            <option value="1" ${jewelry.handIndex === 1 ? 'selected' : ''}>Left Hand</option>
                        </select>
                    </div>
                `;
            }
            
            // Remove button
            const removeHTML = `
                <div class="mt-6">
                    <button class="w-full bg-red-500 text-white py-3 rounded-lg flex justify-center items-center" 
                        onclick="removeJewelry('${id}'); toggleControlsPanel(false);">
                        <i class="fas fa-trash mr-2"></i> Remove Item
                    </button>
                </div>
            `;
            
            // Combine all controls
            controlsContent.innerHTML = headerHTML + visibilityHTML + sizeHTML + specializedControls + positionHTML + removeHTML;
        }
        
        // Position adjustment
        function moveJewelry(id, direction) {
            if (!appState.activeJewelry.has(id)) return;
            
            const jewelry = appState.activeJewelry.get(id);
            const step = 5; // Pixel adjustment step
            
            switch (direction) {
                case 'up':
                    jewelry.offset.y -= step;
                    break;
                case 'down':
                    jewelry.offset.y += step;
                    break;
                case 'left':
                    jewelry.offset.x -= step;
                    break;
                case 'right':
                    jewelry.offset.x += step;
                    break;
                case 'up-left':
                    jewelry.offset.x -= step;
                    jewelry.offset.y -= step;
                    break;
                case 'up-right':
                    jewelry.offset.x += step;
                    jewelry.offset.y -= step;
                    break;
                case 'down-left':
                    jewelry.offset.x -= step;
                    jewelry.offset.y += step;
                    break;
                case 'down-right':
                    jewelry.offset.x += step;
                    jewelry.offset.y += step;
                    break;
                case 'center':
                    jewelry.offset = { x: 0, y: 0 };
                    break;
            }
        }
        
        // Drawing functions for each jewelry type
        function drawNecklace(jewelry, id) {
            if (!jewelry.loadedImage || !jewelry.visible) return;
            
            const leftShoulder = appState.poseLandmarks[11];
            const rightShoulder = appState.poseLandmarks[12];
            
            if (!leftShoulder || !rightShoulder) return;
        
            // Calculate base positions from shoulders
            const shoulderWidth = Math.abs(rightShoulder.x - leftShoulder.x) * elements.canvas.width;
            const collarOffset = 0.15;
            const leftX = leftShoulder.x * elements.canvas.width + shoulderWidth * collarOffset;
            const rightX = rightShoulder.x * elements.canvas.width - shoulderWidth * collarOffset;
            const baseY = leftShoulder.y * elements.canvas.height;
        
            // Apply measurements with mobile-friendly adjustments
            // Use constants optimized for the original PC version
            const VERTICAL_OFFSET = -115;
            const DROP_HEIGHT = 45;
            
            const adjustedY = baseY + VERTICAL_OFFSET + jewelry.offset.y;
            const centerX = (leftX + rightX) / 2 + jewelry.offset.x;
            
            // Calculate necklace dimensions
            const necklaceWidth = shoulderWidth * jewelry.scale;
            const necklaceHeight = jewelry.loadedImage.height * (necklaceWidth / jewelry.loadedImage.width);
        
            // Calculate the actual drawing position in canvas coordinates
            const drawX = centerX - necklaceWidth/2;
            const drawY = adjustedY - DROP_HEIGHT/2;
        
            // For mobile, use simplified drawing approach without sub-image calculations
            elements.ctx.save();
            elements.ctx.shadowColor = 'rgba(0,0,0,0.3)';
            elements.ctx.shadowBlur = 8;
            elements.ctx.shadowOffsetX = 2;
            elements.ctx.shadowOffsetY = 2;
        
            elements.ctx.drawImage(
                jewelry.loadedImage,
                drawX, drawY, necklaceWidth, necklaceHeight
            );
            
            elements.ctx.restore();
        }
        
        function drawEarrings(jewelry, id) {
            if (!jewelry.leftImage || !jewelry.rightImage || !jewelry.visible) return;
            
            const landmarks = appState.faceLandmarks;
            if (!landmarks) return;
            
            const nose = landmarks[1];
            const leftEar = landmarks[234];
            const rightEar = landmarks[454];
            
            if (!nose || !leftEar || !rightEar) return;
            
            const faceRotation = (rightEar.z - leftEar.z);
            let gap = jewelry.gap || 0;
            
            // Adjust gap based on face rotation
            if (Math.abs(faceRotation) <= 0.1) {
                gap += 3;
            } else {
                gap += 24;
            }
            
            const leftLobe = landmarks[177];
            const rightLobe = landmarks[401];
            
            if (!leftLobe || !rightLobe) return;
            
            const faceWidth = Math.abs(rightEar.x - leftEar.x) * elements.canvas.width;
            const gapAdjustment = (gap / 100) * faceWidth;
            
            const earHeight = Math.abs(landmarks[234].y - leftLobe.y) * elements.canvas.height;
            const baseScale = (earHeight * 0.8) / jewelry.leftImage.height;
            const scale = baseScale * jewelry.scale; // Combine base scale with user adjustable scale
            
            elements.ctx.save();
            elements.ctx.shadowColor = 'rgba(0,0,0,0.3)';
            elements.ctx.shadowBlur = 5;
            elements.ctx.shadowOffsetX = 2;
            elements.ctx.shadowOffsetY = 2;
            
            // Draw left earring if face is not turned too far right
            if (faceRotation > -0.1) {
                const leftX = leftLobe.x * elements.canvas.width - gapAdjustment + jewelry.offset.x;
                const leftY = leftLobe.y * elements.canvas.height + jewelry.offset.y;
                
                const leftWidth = jewelry.leftImage.width * scale;
                const leftHeight = jewelry.leftImage.height * scale;
                elements.ctx.drawImage(
                    jewelry.leftImage,
                    leftX - leftWidth/2,
                    leftY - leftHeight/2,
                    leftWidth,
                    leftHeight
                );
            }
            
            // Draw right earring if face is not turned too far left
            if (faceRotation < 0.1) {
                const rightX = rightLobe.x * elements.canvas.width + gapAdjustment + jewelry.offset.x + 15;
                const rightY = rightLobe.y * elements.canvas.height + jewelry.offset.y;
                
                const rightWidth = jewelry.rightImage.width * scale;
                const rightHeight = jewelry.rightImage.height * scale;
                elements.ctx.drawImage(
                    jewelry.rightImage,
                    rightX - rightWidth/2,
                    rightY - rightHeight/2,
                    rightWidth,
                    rightHeight
                );
            }
            
            elements.ctx.restore();
        }
        
        function drawSinglePiece(jewelry, id) {
            if (!jewelry.loadedImage || !jewelry.visible) return;
            
            const landmarks = appState.faceLandmarks;
            if (!landmarks) return;
            
            let x, y, baseScale, scale;
            
            // For tikka
            if (jewelry.landmark === 151) {
                const centerPoint = landmarks[151]; // Center of forehead
                const topPoint = landmarks[10];     // Top of forehead
                const refPoint = landmarks[9];      // Reference point
                
                if (!centerPoint || !topPoint || !refPoint) return;
                
                // Calculate position on the forehead
                x = ((centerPoint.x + refPoint.x) / 2) * elements.canvas.width + jewelry.offset.x;
                y = ((centerPoint.y + topPoint.y) / 2) * elements.canvas.height - 20 + jewelry.offset.y;
                
                // Scale based on forehead width
                const foreheadWidth = Math.abs(landmarks[71].x - landmarks[301].x) * elements.canvas.width;
                baseScale = (foreheadWidth * 0.4) / jewelry.loadedImage.width;
                scale = baseScale * jewelry.scale;
            } else {
                // Default to center of face if landmark isn't recognized
                const nose = landmarks[1];
                if (!nose) return;
                
                x = nose.x * elements.canvas.width + jewelry.offset.x;
                y = nose.y * elements.canvas.height + jewelry.offset.y;
                scale = jewelry.scale;
            }
            
            // Draw the jewelry
            elements.ctx.save();
            elements.ctx.shadowColor = 'rgba(0,0,0,0.3)';
            elements.ctx.shadowBlur = 8;
            elements.ctx.shadowOffsetX = 2;
            elements.ctx.shadowOffsetY = 2;
            
            const width = jewelry.loadedImage.width * scale;
            const height = jewelry.loadedImage.height * scale;
            
            elements.ctx.drawImage(
                jewelry.loadedImage,
                x - width/2,
                y - height/2,
                width,
                height
            );
            
            elements.ctx.restore();
        }
        
        function drawRing(jewelry, id) {
            if (!jewelry.loadedImage || !jewelry.visible) return;
            
            // Check if we have hand landmarks and the right hand index
            const handIndex = jewelry.handIndex || 0;
            if (!appState.handLandmarks || !appState.handLandmarks[handIndex]) return;
            
            const handLandmarks = appState.handLandmarks[handIndex];
            const fingerTip = handLandmarks[jewelry.fingerIndex];
            const fingerBase = handLandmarks[jewelry.fingerIndex - 3];
            
            if (!fingerTip || !fingerBase) return;
            
            // Calculate position along the finger (closer to base)
            const positionRatio = 0.3; // 30% from base to tip
            const x = (fingerBase.x + (fingerTip.x - fingerBase.x) * positionRatio) * elements.canvas.width + jewelry.offset.x;
            const y = (fingerBase.y + (fingerTip.y - fingerBase.y) * positionRatio) * elements.canvas.height + jewelry.offset.y;
            
            // Calculate rotation angle
            const angle = Math.atan2(
                fingerTip.y - fingerBase.y,
                fingerTip.x - fingerBase.x
            );
            
            // Draw rotated ring
            elements.ctx.save();
            elements.ctx.translate(x, y);
            elements.ctx.rotate(angle - Math.PI/2);
            
            const width = jewelry.loadedImage.width * jewelry.scale;
            const height = jewelry.loadedImage.height * jewelry.scale;
            
            elements.ctx.drawImage(
                jewelry.loadedImage,
                -width/2,
                -height/2,
                width,
                height
            );
            
            elements.ctx.restore();
        }
        
        function drawBangle(jewelry, id) {
            if (!jewelry.loadedImage || !jewelry.visible) return;
            
            // Check if we have hand landmarks and the right hand index
            const handIndex = jewelry.handIndex || 0;
            if (!appState.handLandmarks || !appState.handLandmarks[handIndex]) return;
            
            const handLandmarks = appState.handLandmarks[handIndex];
            const wrist = handLandmarks[0];
            const palmBase = handLandmarks[9];
            
            if (!wrist || !palmBase) return;
            
            // Add offsets to position bangle
            const verticalOffset = 30;
            const horizontalOffset = -20;
            
            const x = wrist.x * elements.canvas.width + horizontalOffset + jewelry.offset.x;
            const y = wrist.y * elements.canvas.height + verticalOffset + jewelry.offset.y;
            
            // Calculate rotation angle
            const angle = Math.atan2(
                palmBase.y - wrist.y,
                palmBase.x - wrist.x
            );
            
            // Calculate size based on wrist width
            const wristLeft = handLandmarks[17];
            const wristRight = handLandmarks[5];
            
            if (!wristLeft || !wristRight) return;
            
            const wristWidth = Math.abs(wristRight.x - wristLeft.x) * elements.canvas.width;
            const baseScale = 3.2;
            
            // Draw rotated bangle
            elements.ctx.save();
            elements.ctx.translate(x, y);
            elements.ctx.rotate(angle - Math.PI/2);
            
            const width = wristWidth * baseScale * jewelry.scale;
            const height = jewelry.loadedImage.height * (width / jewelry.loadedImage.width);
            
            elements.ctx.drawImage(
                jewelry.loadedImage,
                -width/2,
                -height/2,
                width,
                height
            );
            
            elements.ctx.restore();
        }
        
        // Camera access request
        async function requestCameraAccess() {
            try {
                document.getElementById('cameraError').classList.add('hidden');
                await initializeCamera();
                if (!appState.isInitialized) {
                    // If we haven't fully initialized yet, continue initialization
                    await initializeAIModels();
                    await preloadJewelryImages();
                    initializeUI();
                    appState.isInitialized = true;
                    requestAnimationFrame(detectAll);
                }
            } catch (error) {
                console.error("Camera request error:", error);
                document.getElementById('cameraError').classList.remove('hidden');
            }
        }
        
        // Image capture
        function captureImage() {
            // Create a new canvas to combine video and jewelry
            const captureCanvas = document.createElement('canvas');
            captureCanvas.width = elements.video.videoWidth;
            captureCanvas.height = elements.video.videoHeight;
            const ctx = captureCanvas.getContext('2d');
            
            // Draw video frame
            ctx.drawImage(elements.video, 0, 0, captureCanvas.width, captureCanvas.height);
            
            // Draw jewelry canvas on top
            ctx.drawImage(elements.canvas, 0, 0, captureCanvas.width, captureCanvas.height);
            
            // Add a small branding
            ctx.font = '16px Arial';
            ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
            ctx.fillText('Infinite AI Virtual Try-On', 10, captureCanvas.height - 20);
            
            // Create download link
            const link = document.createElement('a');
            link.download = 'jewelry-tryon-' + new Date().toISOString().slice(0, 10) + '.png';
            
            try {
                // Create image URL
                link.href = captureCanvas.toDataURL('image/png');
                link.click();
                
                // Show success toast
                showToast('Image saved successfully!');
            } catch (e) {
                console.error('Error capturing image:', e);
                showToast('Error saving image. Check permissions.');
            }
        }
        
        // Show toast message
        function showToast(message) {
            // Check if a toast already exists
            let toast = document.querySelector('.toast-message');
            if (!toast) {
                toast = document.createElement('div');
                toast.className = 'toast-message';
                toast.style.cssText = `
                    position: fixed;
                    bottom: 100px;
                    left: 50%;
                    transform: translateX(-50%);
                    background-color: rgba(0, 0, 0, 0.7);
                    color: white;
                    padding: 10px 20px;
                    border-radius: 20px;
                    z-index: 1000;
                    font-size: 14px;
                `;
                document.body.appendChild(toast);
            }
            
            toast.textContent = message;
            toast.style.opacity = '1';
            
            // Hide after 2 seconds
            setTimeout(() => {
                toast.style.opacity = '0';
                setTimeout(() => {
                    if (toast.parentNode) {
                        toast.parentNode.removeChild(toast);
                    }
                }, 300);
            }, 2000);
        }
        
        // Gesture support for direct manipulation
        function setupGestureHandlers() {
            const canvas = elements.canvas;
            let startTouches = [];
            let startDistance = 0;
            let startScale = 1;
            let startOffset = { x: 0, y: 0 };
            let isDragging = false;
            let activeItemId = null;
            let activePinchId = null;
            
            // Touch start
            canvas.addEventListener('touchstart', (e) => {
                // Only activate if we have jewelry and landmarks
                if (appState.activeJewelry.size === 0 || appState.isControlsPanelOpen) return;
                
                if (e.touches.length === 1) {
                    // Single touch - check if we're touching jewelry for drag
                    const touch = e.touches[0];
                    activeItemId = findJewelryAtPoint(touch.clientX, touch.clientY);
                    
                    if (activeItemId) {
                        isDragging = true;
                        const jewelry = appState.activeJewelry.get(activeItemId);
                        startOffset = { ...jewelry.offset };
                        startTouches = [{ x: touch.clientX, y: touch.clientY }];
                        e.preventDefault(); // Prevent scrolling
                    }
                } else if (e.touches.length === 2) {
                    // Two touches - check for pinch to resize
                    const touch1 = e.touches[0];
                    const touch2 = e.touches[1];
                    
                    // Find midpoint between touches
                    const midX = (touch1.clientX + touch2.clientX) / 2;
                    const midY = (touch1.clientY + touch2.clientY) / 2;
                    
                    // Check if midpoint is on jewelry
                    activePinchId = findJewelryAtPoint(midX, midY);
                    
                    if (activePinchId) {
                        const jewelry = appState.activeJewelry.get(activePinchId);
                        startScale = jewelry.scale;
                        startDistance = Math.hypot(
                            touch1.clientX - touch2.clientX,
                            touch1.clientY - touch2.clientY
                        );
                        e.preventDefault(); // Prevent zooming the page
                    }
                }
            });
            
            // Touch move
            canvas.addEventListener('touchmove', (e) => {
                if (isDragging && activeItemId && e.touches.length === 1) {
                    // Handle drag
                    const touch = e.touches[0];
                    const deltaX = touch.clientX - startTouches[0].x;
                    const deltaY = touch.clientY - startTouches[0].y;
                    
                    // Get the pixel ratio for accurate movement
                    const pixelRatio = window.devicePixelRatio || 1;
                    
                    // Update jewelry position
                    const jewelry = appState.activeJewelry.get(activeItemId);
                    jewelry.offset.x = startOffset.x + (deltaX / pixelRatio);
                    jewelry.offset.y = startOffset.y + (deltaY / pixelRatio);
                    
                    e.preventDefault(); // Prevent scrolling
                } else if (activePinchId && e.touches.length === 2) {
                    // Handle pinch to resize
                    const touch1 = e.touches[0];
                    const touch2 = e.touches[1];
                    
                    // Calculate new distance
                    const newDistance = Math.hypot(
                        touch1.clientX - touch2.clientX,
                        touch1.clientY - touch2.clientY
                    );
                    
                    // Calculate scale factor
                    const scaleFactor = newDistance / startDistance;
                    
                    // Apply new scale with limits
                    const jewelry = appState.activeJewelry.get(activePinchId);
                    jewelry.scale = Math.max(0.1, Math.min(2.0, startScale * scaleFactor));
                    
                    e.preventDefault(); // Prevent zooming the page
                }
            });
            
            // Touch end
            canvas.addEventListener('touchend', (e) => {
                // Reset touch interactions
                if (isDragging && activeItemId) {
                    // If it was a short tap with minimal movement, open controls for the item
                    const jewelry = appState.activeJewelry.get(activeItemId);
                    const deltaX = Math.abs(jewelry.offset.x - startOffset.x);
                    const deltaY = Math.abs(jewelry.offset.y - startOffset.y);
                    
                    if (deltaX < 5 && deltaY < 5) {
                        // This was essentially a tap - open controls
                        toggleControlsPanel(true, activeItemId);
                    }
                    
                    isDragging = false;
                }
                
                activeItemId = null;
                activePinchId = null;
            });
            
            // Touch cancel - reset all interactions
            canvas.addEventListener('touchcancel', () => {
                isDragging = false;
                activeItemId = null;
                activePinchId = null;
            });
        }
        
        // Helper to find jewelry at touch point
        function findJewelryAtPoint(clientX, clientY) {
            if (appState.activeJewelry.size === 0) return null;
            
            // Convert client coordinates to canvas coordinates
            const rect = elements.canvas.getBoundingClientRect();
            const x = (clientX - rect.left) * (elements.canvas.width / rect.width);
            const y = (clientY - rect.top) * (elements.canvas.height / rect.height);
            
            // Simple hit testing for jewelry items
            for (const [id, jewelry] of appState.activeJewelry.entries()) {
                if (!jewelry.visible) continue;
                
                // Get position and size based on jewelry type
                let hitX, hitY, hitWidth, hitHeight;
                
                if (jewelry.type === 'necklace' && appState.poseLandmarks) {
                    // Approximate necklace position
                    const leftShoulder = appState.poseLandmarks[11];
                    const rightShoulder = appState.poseLandmarks[12];
                    
                    if (!leftShoulder || !rightShoulder) continue;
                    
                    const shoulderWidth = Math.abs(rightShoulder.x - leftShoulder.x) * elements.canvas.width;
                    const centerX = (leftShoulder.x + rightShoulder.x) / 2 * elements.canvas.width + jewelry.offset.x;
                    const centerY = leftShoulder.y * elements.canvas.height - 100 + jewelry.offset.y;
                    
                    hitX = centerX - (shoulderWidth * jewelry.scale) / 2;
                    hitY = centerY - (shoulderWidth * jewelry.scale) / 4;
                    hitWidth = shoulderWidth * jewelry.scale;
                    hitHeight = shoulderWidth * jewelry.scale / 2;
                } else if (jewelry.type === 'single' && appState.faceLandmarks) {
                    // Approximate tikka position
                    const centerPoint = appState.faceLandmarks[151];
                    if (!centerPoint) continue;
                    
                    hitX = centerPoint.x * elements.canvas.width - 50 * jewelry.scale + jewelry.offset.x;
                    hitY = centerPoint.y * elements.canvas.height - 50 * jewelry.scale + jewelry.offset.y;
                    hitWidth = 100 * jewelry.scale;
                    hitHeight = 100 * jewelry.scale;
                } else if (jewelry.type === 'earrings' && appState.faceLandmarks) {
                    // Check both earrings
                    const leftLobe = appState.faceLandmarks[177];
                    const rightLobe = appState.faceLandmarks[401];
                    
                    if (!leftLobe || !rightLobe) continue;
                    
                    // Check left earring hit
                    let leftX = leftLobe.x * elements.canvas.width + jewelry.offset.x;
                    let leftY = leftLobe.y * elements.canvas.height + jewelry.offset.y;
                    let hitSize = 50 * jewelry.scale;
                    
                    if (x >= leftX - hitSize && x <= leftX + hitSize && 
                        y >= leftY - hitSize && y <= leftY + hitSize) {
                        return id;
                    }
                    
                    // Check right earring hit
                    let rightX = rightLobe.x * elements.canvas.width + jewelry.offset.x;
                    let rightY = rightLobe.y * elements.canvas.height + jewelry.offset.y;
                    
                    if (x >= rightX - hitSize && x <= rightX + hitSize && 
                        y >= rightY - hitSize && y <= rightY + hitSize) {
                        return id;
                    }
                    
                    // Not a hit on either earring
                    continue;
                } else {
                    // Skip other jewelry types or those without landmarks
                    continue;
                }
                
                // Check if point is inside the jewelry's bounding box
                if (x >= hitX && x <= hitX + hitWidth && y >= hitY && y <= hitY + hitHeight) {
                    return id;
                }
            }
            
            // No jewelry found at this point
            return null;
        }
        
        // Double tap to toggle controls
        function setupDoubleTapHandler() {
            const canvas = elements.canvas;
            let lastTap = 0;
            let lastTapX = 0;
            let lastTapY = 0;
            
            canvas.addEventListener('touchend', (e) => {
                // Ignore multi-touch
                if (e.changedTouches.length !== 1) return;
                
                const currentTime = new Date().getTime();
                const tapLength = currentTime - lastTap;
                const touch = e.changedTouches[0];
                
                // Check if it's close to the last tap position
                const lastX = lastTapX;
                const lastY = lastTapY;
                const currentX = touch.clientX;
                const currentY = touch.clientY;
                const distanceSquared = Math.pow(currentX - lastX, 2) + Math.pow(currentY - lastY, 2);
                
                if (tapLength < 500 && distanceSquared < 900) {
                    // Double tap detected - find jewelry at this position
                    const jewelryId = findJewelryAtPoint(currentX, currentY);
                    if (jewelryId) {
                        toggleControlsPanel(true, jewelryId);
                        e.preventDefault();
                    }
                }
                
                // Store data for next tap comparison
                lastTap = currentTime;
                lastTapX = currentX;
                lastTapY = currentY;
            });
        }
        
        // Set up all the gesture handlers
        function initializeGestureSupport() {
            setupGestureHandlers();
            setupDoubleTapHandler();
        }
        
        // Add this to init() function before hideLoadingScreen():
        // initializeGestureSupport();
        
        // Browser compatibility check
        function checkBrowserCompatibility() {
            // Check for WebGL support
            const canvas = document.createElement('canvas');
            const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
            if (!gl) {
                return {
                    compatible: false,
                    reason: 'WebGL is not supported. Try a different browser.'
                };
            }
            
            // Check for MediaDevices API
            if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                return {
                    compatible: false,
                    reason: 'Camera access is not supported. Try a different browser.'
                };
            }
            
            // Check for touch support for mobile devices
            const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
            if (isMobile && !('ontouchstart' in window)) {
                return {
                    compatible: false,
                    reason: 'Touch events are not supported on your device.'
                };
            }
            
            return { compatible: true };
        }
        
        // Update the init() function to check compatibility first
        async function init() {
            try {
                console.log("Starting initialization...");
                updateLoadingStatus("Checking compatibility...");
                
                // Check browser compatibility
                const compatibility = checkBrowserCompatibility();
                if (!compatibility.compatible) {
                    throw new Error(compatibility.reason);
                }
                
                updateLoadingStatus("Initializing...");
                
                // Get DOM elements
                initializeElements();
                
                // Setup gesture handlers
                setupEventListeners();
                
                // Initialize camera
                await initializeCamera();
                
                // Initialize MediaPipe models
                await initializeAIModels();
                
                // Preload jewelry images
                await preloadJewelryImages();
                
                // Initialize UI
                initializeUI();
                
                // Initialize gesture support
                initializeGestureSupport();
                
                // Start detection loop
                appState.isInitialized = true;
                requestAnimationFrame(detectAll);
                
                // Hide loading screen
                hideLoadingScreen();
                
                console.log("Initialization complete!");
            } catch (error) {
                console.error("Initialization error:", error);
                showError(error.message || "Error initializing app. Please refresh the page.");
            }
        }
    </script>
</body>
</html>
